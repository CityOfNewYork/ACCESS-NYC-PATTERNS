var AccessNyc = (function () {
  'use strict';

  var Constants = {
    STRING: 'string',
    NUMBER: 0,
    FLOAT: 0.00
  };

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  /**
   * The Module styleguide
   * @class
   */

  var Module = function () {
    /**
     * @param  {object} settings This could be some configuration options for the
     *                           component or module.
     * @param  {object} data     This could be a set of data that is needed for
     *                           the component or module to render.
     * @constructor
     */
    function Module(settings, data) {
      classCallCheck(this, Module);

      this.data = data;
      this.settings = settings;
    }

    /**
     * Initializes the module
     */


    createClass(Module, [{
      key: 'init',
      value: function init() {
        console.log('Hello World!');
        this._constants(Constants);
      }

      /**
       * Logs constants to the debugger
       * @param  {object} param - our constants
       */

    }, {
      key: '_constants',
      value: function _constants(param) {
        console.dir(param);
      }
    }]);
    return Module;
  }();

  /**
   * The Simple Toggle class
   * @class
   */

  var Toggle = function () {
    /**
     * @constructor
     * @param  {object} s Settings for this Toggle instance
     * @return {object}   The Toggle class
     */
    function Toggle(s) {
      classCallCheck(this, Toggle);

      s = !s ? {} : s;

      this._settings = {
        selector: s.selector ? s.selector : Toggle.selector,
        namespace: s.namespace ? s.namespace : Toggle.namespace,
        inactiveClass: s.inactiveClass ? s.inactiveClass : Toggle.inactiveClass,
        activeClass: s.activeClass ? s.activeClass : Toggle.activeClass
      };

      return this;
    }

    /**
     * Initializes the module
     */


    createClass(Toggle, [{
      key: 'init',
      value: function init() {
        var _this = this;

        var body = document.querySelector('body');
        body.addEventListener('click', function (event) {
          var method = !event.target.matches ? 'msMatchesSelector' : 'matches';

          if (!event.target[method](_this._settings.selector)) return;

          event.preventDefault();

          _this._toggle(event);
        });
      }

      /**
       * Logs constants to the debugger
       * @param  {object} event  The main click event
       * @return {class}         The Toggle class
       */

    }, {
      key: '_toggle',
      value: function _toggle(event) {
        var _this2 = this;

        var el = event.target;
        var selector = el.getAttribute('href') ? el.getAttribute('href') : el.dataset[this._settings.namespace + 'Target'];
        var target = document.querySelector(selector);

        /**
         * Main
         */
        this._elementToggle(el, target);

        /**
         * Location
         * Change the window location
         */
        if (el.dataset[this._settings.namespace + 'Location']) window.location.hash = el.dataset[this._settings.namespace + 'Location'];

        /**
         * Undo
         * Add toggling event to the element that undoes the toggle
         */
        if (el.dataset[this._settings.namespace + 'Undo']) {
          var undo = document.querySelector(el.dataset[this._settings.namespace + 'Undo']);
          undo.addEventListener('click', function (event) {
            event.preventDefault();
            _this2._elementToggle(el, target);
            undo.removeEventListener('click');
          });
        }

        return this;
      }

      /**
       * The main toggling method
       * @param  {object} el     The current element to toggle active
       * @param  {object} target The target element to toggle active/hidden
       * @return {class}         The Toggle class
       */

    }, {
      key: '_elementToggle',
      value: function _elementToggle(el, target) {
        el.classList.toggle(this._settings.activeClass);
        target.classList.toggle(this._settings.activeClass);
        target.classList.toggle(this._settings.inactiveClass);
        target.setAttribute('aria-hidden', target.classList.contains(this._settings.inactiveClass));
        return this;
      }
    }]);
    return Toggle;
  }();

  /** @type {String} The main selector to add the toggling function to */


  Toggle.selector = '[data-js="toggle"]';

  /** @type {String} The namespace for our data attribute settings */
  Toggle.namespace = 'toggle';

  /** @type {String} The hide class */
  Toggle.inactiveClass = 'hidden';

  /** @type {String} The active class */
  Toggle.activeClass = 'active';

  /*!
   * Vue.js v2.5.16
   * (c) 2014-2018 Evan You
   * Released under the MIT License.
   */
  /*  */

  var emptyObject = Object.freeze({});

  // these helpers produces better vm code in JS engines due to their
  // explicitness and function inlining
  function isUndef(v) {
    return v === undefined || v === null;
  }

  function isDef(v) {
    return v !== undefined && v !== null;
  }

  function isTrue(v) {
    return v === true;
  }

  function isFalse(v) {
    return v === false;
  }

  /**
   * Check if value is primitive
   */
  function isPrimitive(value) {
    return typeof value === 'string' || typeof value === 'number' ||
    // $flow-disable-line
    (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol' || typeof value === 'boolean';
  }

  /**
   * Quick object check - this is primarily used to tell
   * Objects from primitive values when we know the value
   * is a JSON-compliant type.
   */
  function isObject(obj) {
    return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
  }

  /**
   * Get the raw type string of a value e.g. [object Object]
   */
  var _toString = Object.prototype.toString;

  function toRawType(value) {
    return _toString.call(value).slice(8, -1);
  }

  /**
   * Strict object type check. Only returns true
   * for plain JavaScript objects.
   */
  function isPlainObject(obj) {
    return _toString.call(obj) === '[object Object]';
  }

  function isRegExp(v) {
    return _toString.call(v) === '[object RegExp]';
  }

  /**
   * Check if val is a valid array index.
   */
  function isValidArrayIndex(val) {
    var n = parseFloat(String(val));
    return n >= 0 && Math.floor(n) === n && isFinite(val);
  }

  /**
   * Convert a value to a string that is actually rendered.
   */
  function toString(val) {
    return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);
  }

  /**
   * Convert a input value to a number for persistence.
   * If the conversion fails, return original string.
   */
  function toNumber(val) {
    var n = parseFloat(val);
    return isNaN(n) ? val : n;
  }

  /**
   * Make a map and return a function for checking if a key
   * is in that map.
   */
  function makeMap(str, expectsLowerCase) {
    var map = Object.create(null);
    var list = str.split(',');
    for (var i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase ? function (val) {
      return map[val.toLowerCase()];
    } : function (val) {
      return map[val];
    };
  }

  /**
   * Check if a tag is a built-in tag.
   */
  var isBuiltInTag = makeMap('slot,component', true);

  /**
   * Check if a attribute is a reserved attribute.
   */
  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

  /**
   * Remove an item from an array
   */
  function remove(arr, item) {
    if (arr.length) {
      var index = arr.indexOf(item);
      if (index > -1) {
        return arr.splice(index, 1);
      }
    }
  }

  /**
   * Check whether the object has the property.
   */
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function hasOwn(obj, key) {
    return hasOwnProperty.call(obj, key);
  }

  /**
   * Create a cached version of a pure function.
   */
  function cached(fn) {
    var cache = Object.create(null);
    return function cachedFn(str) {
      var hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  }

  /**
   * Camelize a hyphen-delimited string.
   */
  var camelizeRE = /-(\w)/g;
  var camelize = cached(function (str) {
    return str.replace(camelizeRE, function (_, c) {
      return c ? c.toUpperCase() : '';
    });
  });

  /**
   * Capitalize a string.
   */
  var capitalize = cached(function (str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });

  /**
   * Hyphenate a camelCase string.
   */
  var hyphenateRE = /\B([A-Z])/g;
  var hyphenate = cached(function (str) {
    return str.replace(hyphenateRE, '-$1').toLowerCase();
  });

  /**
   * Simple bind polyfill for environments that do not support it... e.g.
   * PhantomJS 1.x. Technically we don't need this anymore since native bind is
   * now more performant in most browsers, but removing it would be breaking for
   * code that was able to run in PhantomJS 1.x, so this must be kept for
   * backwards compatibility.
   */

  /* istanbul ignore next */
  function polyfillBind(fn, ctx) {
    function boundFn(a) {
      var l = arguments.length;
      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
    }

    boundFn._length = fn.length;
    return boundFn;
  }

  function nativeBind(fn, ctx) {
    return fn.bind(ctx);
  }

  var bind = Function.prototype.bind ? nativeBind : polyfillBind;

  /**
   * Convert an Array-like object to a real Array.
   */
  function toArray$1(list, start) {
    start = start || 0;
    var i = list.length - start;
    var ret = new Array(i);
    while (i--) {
      ret[i] = list[i + start];
    }
    return ret;
  }

  /**
   * Mix properties into target object.
   */
  function extend(to, _from) {
    for (var key in _from) {
      to[key] = _from[key];
    }
    return to;
  }

  /**
   * Merge an Array of Objects into a single Object.
   */
  function toObject(arr) {
    var res = {};
    for (var i = 0; i < arr.length; i++) {
      if (arr[i]) {
        extend(res, arr[i]);
      }
    }
    return res;
  }

  /**
   * Perform no operation.
   * Stubbing args to make Flow happy without leaving useless transpiled code
   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
   */
  function noop(a, b, c) {}

  /**
   * Always return false.
   */
  var no = function no(a, b, c) {
    return false;
  };

  /**
   * Return same value
   */
  var identity = function identity(_) {
    return _;
  };

  /**
   * Generate a static keys string from compiler modules.
   */
  function genStaticKeys(modules) {
    return modules.reduce(function (keys, m) {
      return keys.concat(m.staticKeys || []);
    }, []).join(',');
  }

  /**
   * Check if two values are loosely equal - that is,
   * if they are plain objects, do they have the same shape?
   */
  function looseEqual(a, b) {
    if (a === b) {
      return true;
    }
    var isObjectA = isObject(a);
    var isObjectB = isObject(b);
    if (isObjectA && isObjectB) {
      try {
        var isArrayA = Array.isArray(a);
        var isArrayB = Array.isArray(b);
        if (isArrayA && isArrayB) {
          return a.length === b.length && a.every(function (e, i) {
            return looseEqual(e, b[i]);
          });
        } else if (!isArrayA && !isArrayB) {
          var keysA = Object.keys(a);
          var keysB = Object.keys(b);
          return keysA.length === keysB.length && keysA.every(function (key) {
            return looseEqual(a[key], b[key]);
          });
        } else {
          /* istanbul ignore next */
          return false;
        }
      } catch (e) {
        /* istanbul ignore next */
        return false;
      }
    } else if (!isObjectA && !isObjectB) {
      return String(a) === String(b);
    } else {
      return false;
    }
  }

  function looseIndexOf(arr, val) {
    for (var i = 0; i < arr.length; i++) {
      if (looseEqual(arr[i], val)) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Ensure a function is called only once.
   */
  function once(fn) {
    var called = false;
    return function () {
      if (!called) {
        called = true;
        fn.apply(this, arguments);
      }
    };
  }

  var SSR_ATTR = 'data-server-rendered';

  var ASSET_TYPES = ['component', 'directive', 'filter'];

  var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured'];

  /*  */

  var config = {
    /**
     * Option merge strategies (used in core/util/options)
     */
    // $flow-disable-line
    optionMergeStrategies: Object.create(null),

    /**
     * Whether to suppress warnings.
     */
    silent: false,

    /**
     * Show production mode tip message on boot?
     */
    productionTip: "production" !== 'production',

    /**
     * Whether to enable devtools
     */
    devtools: "production" !== 'production',

    /**
     * Whether to record perf
     */
    performance: false,

    /**
     * Error handler for watcher errors
     */
    errorHandler: null,

    /**
     * Warn handler for watcher warns
     */
    warnHandler: null,

    /**
     * Ignore certain custom elements
     */
    ignoredElements: [],

    /**
     * Custom user key aliases for v-on
     */
    // $flow-disable-line
    keyCodes: Object.create(null),

    /**
     * Check if a tag is reserved so that it cannot be registered as a
     * component. This is platform-dependent and may be overwritten.
     */
    isReservedTag: no,

    /**
     * Check if an attribute is reserved so that it cannot be used as a component
     * prop. This is platform-dependent and may be overwritten.
     */
    isReservedAttr: no,

    /**
     * Check if a tag is an unknown element.
     * Platform-dependent.
     */
    isUnknownElement: no,

    /**
     * Get the namespace of an element
     */
    getTagNamespace: noop,

    /**
     * Parse the real tag name for the specific platform.
     */
    parsePlatformTagName: identity,

    /**
     * Check if an attribute must be bound using property, e.g. value
     * Platform-dependent.
     */
    mustUseProp: no,

    /**
     * Exposed for legacy reasons
     */
    _lifecycleHooks: LIFECYCLE_HOOKS
  };

  /*  */

  /**
   * Check if a string starts with $ or _
   */
  function isReserved(str) {
    var c = (str + '').charCodeAt(0);
    return c === 0x24 || c === 0x5F;
  }

  /**
   * Define a property.
   */
  function def(obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
      value: val,
      enumerable: !!enumerable,
      writable: true,
      configurable: true
    });
  }

  /**
   * Parse simple path.
   */
  var bailRE = /[^\w.$]/;
  function parsePath(path) {
    if (bailRE.test(path)) {
      return;
    }
    var segments = path.split('.');
    return function (obj) {
      for (var i = 0; i < segments.length; i++) {
        if (!obj) {
          return;
        }
        obj = obj[segments[i]];
      }
      return obj;
    };
  }

  /*  */

  // can we use __proto__?
  var hasProto = '__proto__' in {};

  // Browser environment sniffing
  var inBrowser = typeof window !== 'undefined';
  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
  var UA = inBrowser && window.navigator.userAgent.toLowerCase();
  var isIE = UA && /msie|trident/.test(UA);
  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
  var isEdge = UA && UA.indexOf('edge/') > 0;
  var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
  var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

  // Firefox has a "watch" function on Object.prototype...
  var nativeWatch = {}.watch;

  var supportsPassive = false;
  if (inBrowser) {
    try {
      var opts = {};
      Object.defineProperty(opts, 'passive', {
        get: function get$$1() {
          /* istanbul ignore next */
          supportsPassive = true;
        }
      }); // https://github.com/facebook/flow/issues/285
      window.addEventListener('test-passive', null, opts);
    } catch (e) {}
  }

  // this needs to be lazy-evaled because vue may be required before
  // vue-server-renderer can set VUE_ENV
  var _isServer;
  var isServerRendering = function isServerRendering() {
    if (_isServer === undefined) {
      /* istanbul ignore if */
      if (!inBrowser && !inWeex && typeof global !== 'undefined') {
        // detect presence of vue-server-renderer and avoid
        // Webpack shimming the process
        _isServer = global['process'].env.VUE_ENV === 'server';
      } else {
        _isServer = false;
      }
    }
    return _isServer;
  };

  // detect devtools
  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

  /* istanbul ignore next */
  function isNative(Ctor) {
    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
  }

  var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

  var _Set;
  /* istanbul ignore if */ // $flow-disable-line
  if (typeof Set !== 'undefined' && isNative(Set)) {
    // use native Set when available.
    _Set = Set;
  } else {
    // a non-standard Set polyfill that only works with primitive keys.
    _Set = function () {
      function Set() {
        this.set = Object.create(null);
      }
      Set.prototype.has = function has(key) {
        return this.set[key] === true;
      };
      Set.prototype.add = function add(key) {
        this.set[key] = true;
      };
      Set.prototype.clear = function clear() {
        this.set = Object.create(null);
      };

      return Set;
    }();
  }

  /*  */

  var warn = noop;



  /*  */

  var uid = 0;

  /**
   * A dep is an observable that can have multiple
   * directives subscribing to it.
   */
  var Dep = function Dep() {
    this.id = uid++;
    this.subs = [];
  };

  Dep.prototype.addSub = function addSub(sub) {
    this.subs.push(sub);
  };

  Dep.prototype.removeSub = function removeSub(sub) {
    remove(this.subs, sub);
  };

  Dep.prototype.depend = function depend() {
    if (Dep.target) {
      Dep.target.addDep(this);
    }
  };

  Dep.prototype.notify = function notify() {
    // stabilize the subscriber list first
    var subs = this.subs.slice();
    for (var i = 0, l = subs.length; i < l; i++) {
      subs[i].update();
    }
  };

  // the current target watcher being evaluated.
  // this is globally unique because there could be only one
  // watcher being evaluated at any time.
  Dep.target = null;
  var targetStack = [];

  function pushTarget(_target) {
    if (Dep.target) {
      targetStack.push(Dep.target);
    }
    Dep.target = _target;
  }

  function popTarget() {
    Dep.target = targetStack.pop();
  }

  /*  */

  var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
    this.tag = tag;
    this.data = data;
    this.children = children;
    this.text = text;
    this.elm = elm;
    this.ns = undefined;
    this.context = context;
    this.fnContext = undefined;
    this.fnOptions = undefined;
    this.fnScopeId = undefined;
    this.key = data && data.key;
    this.componentOptions = componentOptions;
    this.componentInstance = undefined;
    this.parent = undefined;
    this.raw = false;
    this.isStatic = false;
    this.isRootInsert = true;
    this.isComment = false;
    this.isCloned = false;
    this.isOnce = false;
    this.asyncFactory = asyncFactory;
    this.asyncMeta = undefined;
    this.isAsyncPlaceholder = false;
  };

  var prototypeAccessors = { child: { configurable: true } };

  // DEPRECATED: alias for componentInstance for backwards compat.
  /* istanbul ignore next */
  prototypeAccessors.child.get = function () {
    return this.componentInstance;
  };

  Object.defineProperties(VNode.prototype, prototypeAccessors);

  var createEmptyVNode = function createEmptyVNode(text) {
    if (text === void 0) text = '';

    var node = new VNode();
    node.text = text;
    node.isComment = true;
    return node;
  };

  function createTextVNode(val) {
    return new VNode(undefined, undefined, undefined, String(val));
  }

  // optimized shallow clone
  // used for static nodes and slot nodes because they may be reused across
  // multiple renders, cloning them avoids errors when DOM manipulations rely
  // on their elm reference.
  function cloneVNode(vnode) {
    var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
    cloned.ns = vnode.ns;
    cloned.isStatic = vnode.isStatic;
    cloned.key = vnode.key;
    cloned.isComment = vnode.isComment;
    cloned.fnContext = vnode.fnContext;
    cloned.fnOptions = vnode.fnOptions;
    cloned.fnScopeId = vnode.fnScopeId;
    cloned.isCloned = true;
    return cloned;
  }

  /*
   * not type checking this file because flow doesn't play well with
   * dynamically accessing methods on Array prototype
   */

  var arrayProto = Array.prototype;
  var arrayMethods = Object.create(arrayProto);

  var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];

  /**
   * Intercept mutating methods and emit events
   */
  methodsToPatch.forEach(function (method) {
    // cache original method
    var original = arrayProto[method];
    def(arrayMethods, method, function mutator() {
      var args = [],
          len = arguments.length;
      while (len--) {
        args[len] = arguments[len];
      }var result = original.apply(this, args);
      var ob = this.__ob__;
      var inserted;
      switch (method) {
        case 'push':
        case 'unshift':
          inserted = args;
          break;
        case 'splice':
          inserted = args.slice(2);
          break;
      }
      if (inserted) {
        ob.observeArray(inserted);
      }
      // notify change
      ob.dep.notify();
      return result;
    });
  });

  /*  */

  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

  /**
   * In some cases we may want to disable observation inside a component's
   * update computation.
   */
  var shouldObserve = true;

  function toggleObserving(value) {
    shouldObserve = value;
  }

  /**
   * Observer class that is attached to each observed
   * object. Once attached, the observer converts the target
   * object's property keys into getter/setters that
   * collect dependencies and dispatch updates.
   */
  var Observer = function Observer(value) {
    this.value = value;
    this.dep = new Dep();
    this.vmCount = 0;
    def(value, '__ob__', this);
    if (Array.isArray(value)) {
      var augment = hasProto ? protoAugment : copyAugment;
      augment(value, arrayMethods, arrayKeys);
      this.observeArray(value);
    } else {
      this.walk(value);
    }
  };

  /**
   * Walk through each property and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  Observer.prototype.walk = function walk(obj) {
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i]);
    }
  };

  /**
   * Observe a list of Array items.
   */
  Observer.prototype.observeArray = function observeArray(items) {
    for (var i = 0, l = items.length; i < l; i++) {
      observe(items[i]);
    }
  };

  // helpers

  /**
   * Augment an target Object or Array by intercepting
   * the prototype chain using __proto__
   */
  function protoAugment(target, src, keys) {
    /* eslint-disable no-proto */
    target.__proto__ = src;
    /* eslint-enable no-proto */
  }

  /**
   * Augment an target Object or Array by defining
   * hidden properties.
   */
  /* istanbul ignore next */
  function copyAugment(target, src, keys) {
    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      def(target, key, src[key]);
    }
  }

  /**
   * Attempt to create an observer instance for a value,
   * returns the new observer if successfully observed,
   * or the existing observer if the value already has one.
   */
  function observe(value, asRootData) {
    if (!isObject(value) || value instanceof VNode) {
      return;
    }
    var ob;
    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
      ob = value.__ob__;
    } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
      ob = new Observer(value);
    }
    if (asRootData && ob) {
      ob.vmCount++;
    }
    return ob;
  }

  /**
   * Define a reactive property on an Object.
   */
  function defineReactive(obj, key, val, customSetter, shallow) {
    var dep = new Dep();

    var property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
      return;
    }

    // cater for pre-defined getter/setters
    var getter = property && property.get;
    if (!getter && arguments.length === 2) {
      val = obj[key];
    }
    var setter = property && property.set;

    var childOb = !shallow && observe(val);
    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get: function reactiveGetter() {
        var value = getter ? getter.call(obj) : val;
        if (Dep.target) {
          dep.depend();
          if (childOb) {
            childOb.dep.depend();
            if (Array.isArray(value)) {
              dependArray(value);
            }
          }
        }
        return value;
      },
      set: function reactiveSetter(newVal) {
        var value = getter ? getter.call(obj) : val;
        /* eslint-disable no-self-compare */
        if (newVal === value || newVal !== newVal && value !== value) {
          return;
        }
        if (setter) {
          setter.call(obj, newVal);
        } else {
          val = newVal;
        }
        childOb = !shallow && observe(newVal);
        dep.notify();
      }
    });
  }

  /**
   * Set a property on an object. Adds the new property and
   * triggers change notification if the property doesn't
   * already exist.
   */
  function set$1(target, key, val) {
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.length = Math.max(target.length, key);
      target.splice(key, 1, val);
      return val;
    }
    if (key in target && !(key in Object.prototype)) {
      target[key] = val;
      return val;
    }
    var ob = target.__ob__;
    if (target._isVue || ob && ob.vmCount) {
      return val;
    }
    if (!ob) {
      target[key] = val;
      return val;
    }
    defineReactive(ob.value, key, val);
    ob.dep.notify();
    return val;
  }

  /**
   * Delete a property and trigger change if necessary.
   */
  function del(target, key) {
    if (Array.isArray(target) && isValidArrayIndex(key)) {
      target.splice(key, 1);
      return;
    }
    var ob = target.__ob__;
    if (target._isVue || ob && ob.vmCount) {
      return;
    }
    if (!hasOwn(target, key)) {
      return;
    }
    delete target[key];
    if (!ob) {
      return;
    }
    ob.dep.notify();
  }

  /**
   * Collect dependencies on array elements when the array is touched, since
   * we cannot intercept array element access like property getters.
   */
  function dependArray(value) {
    for (var e = void 0, i = 0, l = value.length; i < l; i++) {
      e = value[i];
      e && e.__ob__ && e.__ob__.dep.depend();
      if (Array.isArray(e)) {
        dependArray(e);
      }
    }
  }

  /*  */

  /**
   * Option overwriting strategies are functions that handle
   * how to merge a parent option value and a child option
   * value into the final value.
   */
  var strats = config.optionMergeStrategies;

  /**
   * Helper that recursively merges two data objects together.
   */
  function mergeData(to, from) {
    if (!from) {
      return to;
    }
    var key, toVal, fromVal;
    var keys = Object.keys(from);
    for (var i = 0; i < keys.length; i++) {
      key = keys[i];
      toVal = to[key];
      fromVal = from[key];
      if (!hasOwn(to, key)) {
        set$1(to, key, fromVal);
      } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
        mergeData(toVal, fromVal);
      }
    }
    return to;
  }

  /**
   * Data
   */
  function mergeDataOrFn(parentVal, childVal, vm) {
    if (!vm) {
      // in a Vue.extend merge, both should be functions
      if (!childVal) {
        return parentVal;
      }
      if (!parentVal) {
        return childVal;
      }
      // when parentVal & childVal are both present,
      // we need to return a function that returns the
      // merged result of both functions... no need to
      // check if parentVal is a function here because
      // it has to be a function to pass previous merges.
      return function mergedDataFn() {
        return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);
      };
    } else {
      return function mergedInstanceDataFn() {
        // instance merge
        var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;
        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;
        if (instanceData) {
          return mergeData(instanceData, defaultData);
        } else {
          return defaultData;
        }
      };
    }
  }

  strats.data = function (parentVal, childVal, vm) {
    if (!vm) {
      if (childVal && typeof childVal !== 'function') {

        return parentVal;
      }
      return mergeDataOrFn(parentVal, childVal);
    }

    return mergeDataOrFn(parentVal, childVal, vm);
  };

  /**
   * Hooks and props are merged as arrays.
   */
  function mergeHook(parentVal, childVal) {
    return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
  }

  LIFECYCLE_HOOKS.forEach(function (hook) {
    strats[hook] = mergeHook;
  });

  /**
   * Assets
   *
   * When a vm is present (instance creation), we need to do
   * a three-way merge between constructor options, instance
   * options and parent options.
   */
  function mergeAssets(parentVal, childVal, vm, key) {
    var res = Object.create(parentVal || null);
    if (childVal) {
      return extend(res, childVal);
    } else {
      return res;
    }
  }

  ASSET_TYPES.forEach(function (type) {
    strats[type + 's'] = mergeAssets;
  });

  /**
   * Watchers.
   *
   * Watchers hashes should not overwrite one
   * another, so we merge them as arrays.
   */
  strats.watch = function (parentVal, childVal, vm, key) {
    // work around Firefox's Object.prototype.watch...
    if (parentVal === nativeWatch) {
      parentVal = undefined;
    }
    if (childVal === nativeWatch) {
      childVal = undefined;
    }
    /* istanbul ignore if */
    if (!childVal) {
      return Object.create(parentVal || null);
    }
    if (!parentVal) {
      return childVal;
    }
    var ret = {};
    extend(ret, parentVal);
    for (var key$1 in childVal) {
      var parent = ret[key$1];
      var child = childVal[key$1];
      if (parent && !Array.isArray(parent)) {
        parent = [parent];
      }
      ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
    }
    return ret;
  };

  /**
   * Other object hashes.
   */
  strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
    if (childVal && "production" !== 'production') {
      assertObjectType(key, childVal, vm);
    }
    if (!parentVal) {
      return childVal;
    }
    var ret = Object.create(null);
    extend(ret, parentVal);
    if (childVal) {
      extend(ret, childVal);
    }
    return ret;
  };
  strats.provide = mergeDataOrFn;

  /**
   * Default strategy.
   */
  var defaultStrat = function defaultStrat(parentVal, childVal) {
    return childVal === undefined ? parentVal : childVal;
  };

  /**
   * Ensure all props option syntax are normalized into the
   * Object-based format.
   */
  function normalizeProps(options, vm) {
    var props = options.props;
    if (!props) {
      return;
    }
    var res = {};
    var i, val, name;
    if (Array.isArray(props)) {
      i = props.length;
      while (i--) {
        val = props[i];
        if (typeof val === 'string') {
          name = camelize(val);
          res[name] = { type: null };
        } else {}
      }
    } else if (isPlainObject(props)) {
      for (var key in props) {
        val = props[key];
        name = camelize(key);
        res[name] = isPlainObject(val) ? val : { type: val };
      }
    } else {}
    options.props = res;
  }

  /**
   * Normalize all injections into Object-based format
   */
  function normalizeInject(options, vm) {
    var inject = options.inject;
    if (!inject) {
      return;
    }
    var normalized = options.inject = {};
    if (Array.isArray(inject)) {
      for (var i = 0; i < inject.length; i++) {
        normalized[inject[i]] = { from: inject[i] };
      }
    } else if (isPlainObject(inject)) {
      for (var key in inject) {
        var val = inject[key];
        normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };
      }
    } else {}
  }

  /**
   * Normalize raw function directives into object format.
   */
  function normalizeDirectives(options) {
    var dirs = options.directives;
    if (dirs) {
      for (var key in dirs) {
        var def = dirs[key];
        if (typeof def === 'function') {
          dirs[key] = { bind: def, update: def };
        }
      }
    }
  }

  function assertObjectType(name, value, vm) {
    if (!isPlainObject(value)) {
      warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
    }
  }

  /**
   * Merge two option objects into a new one.
   * Core utility used in both instantiation and inheritance.
   */
  function mergeOptions(parent, child, vm) {

    if (typeof child === 'function') {
      child = child.options;
    }

    normalizeProps(child, vm);
    normalizeInject(child, vm);
    normalizeDirectives(child);
    var extendsFrom = child.extends;
    if (extendsFrom) {
      parent = mergeOptions(parent, extendsFrom, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
    var options = {};
    var key;
    for (key in parent) {
      mergeField(key);
    }
    for (key in child) {
      if (!hasOwn(parent, key)) {
        mergeField(key);
      }
    }
    function mergeField(key) {
      var strat = strats[key] || defaultStrat;
      options[key] = strat(parent[key], child[key], vm, key);
    }
    return options;
  }

  /**
   * Resolve an asset.
   * This function is used because child instances need access
   * to assets defined in its ancestor chain.
   */
  function resolveAsset(options, type, id, warnMissing) {
    /* istanbul ignore if */
    if (typeof id !== 'string') {
      return;
    }
    var assets = options[type];
    // check local registration variations first
    if (hasOwn(assets, id)) {
      return assets[id];
    }
    var camelizedId = camelize(id);
    if (hasOwn(assets, camelizedId)) {
      return assets[camelizedId];
    }
    var PascalCaseId = capitalize(camelizedId);
    if (hasOwn(assets, PascalCaseId)) {
      return assets[PascalCaseId];
    }
    // fallback to prototype chain
    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    return res;
  }

  /*  */

  function validateProp(key, propOptions, propsData, vm) {
    var prop = propOptions[key];
    var absent = !hasOwn(propsData, key);
    var value = propsData[key];
    // boolean casting
    var booleanIndex = getTypeIndex(Boolean, prop.type);
    if (booleanIndex > -1) {
      if (absent && !hasOwn(prop, 'default')) {
        value = false;
      } else if (value === '' || value === hyphenate(key)) {
        // only cast empty string / same name to boolean if
        // boolean has higher priority
        var stringIndex = getTypeIndex(String, prop.type);
        if (stringIndex < 0 || booleanIndex < stringIndex) {
          value = true;
        }
      }
    }
    // check default value
    if (value === undefined) {
      value = getPropDefaultValue(vm, prop, key);
      // since the default value is a fresh copy,
      // make sure to observe it.
      var prevShouldObserve = shouldObserve;
      toggleObserving(true);
      observe(value);
      toggleObserving(prevShouldObserve);
    }
    return value;
  }

  /**
   * Get the default value of a prop.
   */
  function getPropDefaultValue(vm, prop, key) {
    // no default, return undefined
    if (!hasOwn(prop, 'default')) {
      return undefined;
    }
    var def = prop.default;
    // the raw prop value was also undefined from previous render,
    // return previous default value to avoid unnecessary watcher trigger
    if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
      return vm._props[key];
    }
    // call factory function for non-Function types
    // a value is Function if its prototype is function even across different execution context
    return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
  }

  /**
   * Use function string name to check built-in types,
   * because a simple equality check will fail when running
   * across different vms / iframes.
   */
  function getType(fn) {
    var match = fn && fn.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : '';
  }

  function isSameType(a, b) {
    return getType(a) === getType(b);
  }

  function getTypeIndex(type, expectedTypes) {
    if (!Array.isArray(expectedTypes)) {
      return isSameType(expectedTypes, type) ? 0 : -1;
    }
    for (var i = 0, len = expectedTypes.length; i < len; i++) {
      if (isSameType(expectedTypes[i], type)) {
        return i;
      }
    }
    return -1;
  }

  /*  */

  function handleError(err, vm, info) {
    if (vm) {
      var cur = vm;
      while (cur = cur.$parent) {
        var hooks = cur.$options.errorCaptured;
        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;
              if (capture) {
                return;
              }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  }

  function globalHandleError(err, vm, info) {
    if (config.errorHandler) {
      try {
        return config.errorHandler.call(null, err, vm, info);
      } catch (e) {
        logError(e, null, 'config.errorHandler');
      }
    }
    logError(err, vm, info);
  }

  function logError(err, vm, info) {
    /* istanbul ignore else */
    if ((inBrowser || inWeex) && typeof console !== 'undefined') {
      console.error(err);
    } else {
      throw err;
    }
  }

  /*  */
  /* globals MessageChannel */

  var callbacks = [];
  var pending = false;

  function flushCallbacks() {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
      copies[i]();
    }
  }

  // Here we have async deferring wrappers using both microtasks and (macro) tasks.
  // In < 2.4 we used microtasks everywhere, but there are some scenarios where
  // microtasks have too high a priority and fire in between supposedly
  // sequential events (e.g. #4521, #6690) or even between bubbling of the same
  // event (#6566). However, using (macro) tasks everywhere also has subtle problems
  // when state is changed right before repaint (e.g. #6813, out-in transitions).
  // Here we use microtask by default, but expose a way to force (macro) task when
  // needed (e.g. in event handlers attached by v-on).
  var microTimerFunc;
  var macroTimerFunc;
  var useMacroTask = false;

  // Determine (macro) task defer implementation.
  // Technically setImmediate should be the ideal choice, but it's only available
  // in IE. The only polyfill that consistently queues the callback after all DOM
  // events triggered in the same loop is by using MessageChannel.
  /* istanbul ignore if */
  if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    macroTimerFunc = function macroTimerFunc() {
      setImmediate(flushCallbacks);
    };
  } else if (typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === '[object MessageChannelConstructor]')) {
    var channel = new MessageChannel();
    var port = channel.port2;
    channel.port1.onmessage = flushCallbacks;
    macroTimerFunc = function macroTimerFunc() {
      port.postMessage(1);
    };
  } else {
    /* istanbul ignore next */
    macroTimerFunc = function macroTimerFunc() {
      setTimeout(flushCallbacks, 0);
    };
  }

  // Determine microtask defer implementation.
  /* istanbul ignore next, $flow-disable-line */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    microTimerFunc = function microTimerFunc() {
      p.then(flushCallbacks);
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) {
        setTimeout(noop);
      }
    };
  } else {
    // fallback to macro
    microTimerFunc = macroTimerFunc;
  }

  /**
   * Wrap a function so that if any code inside triggers state change,
   * the changes are queued using a (macro) task instead of a microtask.
   */
  function withMacroTask(fn) {
    return fn._withTask || (fn._withTask = function () {
      useMacroTask = true;
      var res = fn.apply(null, arguments);
      useMacroTask = false;
      return res;
    });
  }

  function nextTick(cb, ctx) {
    var _resolve;
    callbacks.push(function () {
      if (cb) {
        try {
          cb.call(ctx);
        } catch (e) {
          handleError(e, ctx, 'nextTick');
        }
      } else if (_resolve) {
        _resolve(ctx);
      }
    });
    if (!pending) {
      pending = true;
      if (useMacroTask) {
        macroTimerFunc();
      } else {
        microTimerFunc();
      }
    }
    // $flow-disable-line
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise(function (resolve) {
        _resolve = resolve;
      });
    }
  }

  /*  */

  var mark;





  /*  */

  var seenObjects = new _Set();

  /**
   * Recursively traverse an object to evoke all converted
   * getters, so that every nested property inside the object
   * is collected as a "deep" dependency.
   */
  function traverse(val) {
    _traverse(val, seenObjects);
    seenObjects.clear();
  }

  function _traverse(val, seen) {
    var i, keys;
    var isA = Array.isArray(val);
    if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {
      return;
    }
    if (val.__ob__) {
      var depId = val.__ob__.dep.id;
      if (seen.has(depId)) {
        return;
      }
      seen.add(depId);
    }
    if (isA) {
      i = val.length;
      while (i--) {
        _traverse(val[i], seen);
      }
    } else {
      keys = Object.keys(val);
      i = keys.length;
      while (i--) {
        _traverse(val[keys[i]], seen);
      }
    }
  }

  /*  */

  var normalizeEvent = cached(function (name) {
    var passive = name.charAt(0) === '&';
    name = passive ? name.slice(1) : name;
    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
    name = once$$1 ? name.slice(1) : name;
    var capture = name.charAt(0) === '!';
    name = capture ? name.slice(1) : name;
    return {
      name: name,
      once: once$$1,
      capture: capture,
      passive: passive
    };
  });

  function createFnInvoker(fns) {
    function invoker() {
      var arguments$1 = arguments;

      var fns = invoker.fns;
      if (Array.isArray(fns)) {
        var cloned = fns.slice();
        for (var i = 0; i < cloned.length; i++) {
          cloned[i].apply(null, arguments$1);
        }
      } else {
        // return handler return value for single handlers
        return fns.apply(null, arguments);
      }
    }
    invoker.fns = fns;
    return invoker;
  }

  function updateListeners(on, oldOn, add, remove$$1, vm) {
    var name, def, cur, old, event;
    for (name in on) {
      def = cur = on[name];
      old = oldOn[name];
      event = normalizeEvent(name);
      /* istanbul ignore if */
      if (isUndef(cur)) {
      } else if (isUndef(old)) {
        if (isUndef(cur.fns)) {
          cur = on[name] = createFnInvoker(cur);
        }
        add(event.name, cur, event.once, event.capture, event.passive, event.params);
      } else if (cur !== old) {
        old.fns = cur;
        on[name] = old;
      }
    }
    for (name in oldOn) {
      if (isUndef(on[name])) {
        event = normalizeEvent(name);
        remove$$1(event.name, oldOn[name], event.capture);
      }
    }
  }

  /*  */

  function mergeVNodeHook(def, hookKey, hook) {
    if (def instanceof VNode) {
      def = def.data.hook || (def.data.hook = {});
    }
    var invoker;
    var oldHook = def[hookKey];

    function wrappedHook() {
      hook.apply(this, arguments);
      // important: remove merged hook to ensure it's called only once
      // and prevent memory leak
      remove(invoker.fns, wrappedHook);
    }

    if (isUndef(oldHook)) {
      // no existing hook
      invoker = createFnInvoker([wrappedHook]);
    } else {
      /* istanbul ignore if */
      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
        // already a merged invoker
        invoker = oldHook;
        invoker.fns.push(wrappedHook);
      } else {
        // existing plain hook
        invoker = createFnInvoker([oldHook, wrappedHook]);
      }
    }

    invoker.merged = true;
    def[hookKey] = invoker;
  }

  /*  */

  function extractPropsFromVNodeData(data, Ctor, tag) {
    // we are only extracting raw values here.
    // validation and default values are handled in the child
    // component itself.
    var propOptions = Ctor.options.props;
    if (isUndef(propOptions)) {
      return;
    }
    var res = {};
    var attrs = data.attrs;
    var props = data.props;
    if (isDef(attrs) || isDef(props)) {
      for (var key in propOptions) {
        var altKey = hyphenate(key);
        
        checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
      }
    }
    return res;
  }

  function checkProp(res, hash, key, altKey, preserve) {
    if (isDef(hash)) {
      if (hasOwn(hash, key)) {
        res[key] = hash[key];
        if (!preserve) {
          delete hash[key];
        }
        return true;
      } else if (hasOwn(hash, altKey)) {
        res[key] = hash[altKey];
        if (!preserve) {
          delete hash[altKey];
        }
        return true;
      }
    }
    return false;
  }

  /*  */

  // The template compiler attempts to minimize the need for normalization by
  // statically analyzing the template at compile time.
  //
  // For plain HTML markup, normalization can be completely skipped because the
  // generated render function is guaranteed to return Array<VNode>. There are
  // two cases where extra normalization is needed:

  // 1. When the children contains components - because a functional component
  // may return an Array instead of a single root. In this case, just a simple
  // normalization is needed - if any child is an Array, we flatten the whole
  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
  // because functional components already normalize their own children.
  function simpleNormalizeChildren(children) {
    for (var i = 0; i < children.length; i++) {
      if (Array.isArray(children[i])) {
        return Array.prototype.concat.apply([], children);
      }
    }
    return children;
  }

  // 2. When the children contains constructs that always generated nested Arrays,
  // e.g. <template>, <slot>, v-for, or when the children is provided by user
  // with hand-written render functions / JSX. In such cases a full normalization
  // is needed to cater to all possible types of children values.
  function normalizeChildren(children) {
    return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
  }

  function isTextNode(node) {
    return isDef(node) && isDef(node.text) && isFalse(node.isComment);
  }

  function normalizeArrayChildren(children, nestedIndex) {
    var res = [];
    var i, c, lastIndex, last;
    for (i = 0; i < children.length; i++) {
      c = children[i];
      if (isUndef(c) || typeof c === 'boolean') {
        continue;
      }
      lastIndex = res.length - 1;
      last = res[lastIndex];
      //  nested
      if (Array.isArray(c)) {
        if (c.length > 0) {
          c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i);
          // merge adjacent text nodes
          if (isTextNode(c[0]) && isTextNode(last)) {
            res[lastIndex] = createTextVNode(last.text + c[0].text);
            c.shift();
          }
          res.push.apply(res, c);
        }
      } else if (isPrimitive(c)) {
        if (isTextNode(last)) {
          // merge adjacent text nodes
          // this is necessary for SSR hydration because text nodes are
          // essentially merged when rendered to HTML strings
          res[lastIndex] = createTextVNode(last.text + c);
        } else if (c !== '') {
          // convert primitive to vnode
          res.push(createTextVNode(c));
        }
      } else {
        if (isTextNode(c) && isTextNode(last)) {
          // merge adjacent text nodes
          res[lastIndex] = createTextVNode(last.text + c.text);
        } else {
          // default key for nested array children (likely generated by v-for)
          if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
            c.key = "__vlist" + nestedIndex + "_" + i + "__";
          }
          res.push(c);
        }
      }
    }
    return res;
  }

  /*  */

  function ensureCtor(comp, base) {
    if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
      comp = comp.default;
    }
    return isObject(comp) ? base.extend(comp) : comp;
  }

  function createAsyncPlaceholder(factory, data, context, children, tag) {
    var node = createEmptyVNode();
    node.asyncFactory = factory;
    node.asyncMeta = { data: data, context: context, children: children, tag: tag };
    return node;
  }

  function resolveAsyncComponent(factory, baseCtor, context) {
    if (isTrue(factory.error) && isDef(factory.errorComp)) {
      return factory.errorComp;
    }

    if (isDef(factory.resolved)) {
      return factory.resolved;
    }

    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
      return factory.loadingComp;
    }

    if (isDef(factory.contexts)) {
      // already pending
      factory.contexts.push(context);
    } else {
      var contexts = factory.contexts = [context];
      var sync = true;

      var forceRender = function forceRender() {
        for (var i = 0, l = contexts.length; i < l; i++) {
          contexts[i].$forceUpdate();
        }
      };

      var resolve = once(function (res) {
        // cache resolved
        factory.resolved = ensureCtor(res, baseCtor);
        // invoke callbacks only if this is not a synchronous resolve
        // (async resolves are shimmed as synchronous during SSR)
        if (!sync) {
          forceRender();
        }
      });

      var reject = once(function (reason) {
        if (isDef(factory.errorComp)) {
          factory.error = true;
          forceRender();
        }
      });

      var res = factory(resolve, reject);

      if (isObject(res)) {
        if (typeof res.then === 'function') {
          // () => Promise
          if (isUndef(factory.resolved)) {
            res.then(resolve, reject);
          }
        } else if (isDef(res.component) && typeof res.component.then === 'function') {
          res.component.then(resolve, reject);

          if (isDef(res.error)) {
            factory.errorComp = ensureCtor(res.error, baseCtor);
          }

          if (isDef(res.loading)) {
            factory.loadingComp = ensureCtor(res.loading, baseCtor);
            if (res.delay === 0) {
              factory.loading = true;
            } else {
              setTimeout(function () {
                if (isUndef(factory.resolved) && isUndef(factory.error)) {
                  factory.loading = true;
                  forceRender();
                }
              }, res.delay || 200);
            }
          }

          if (isDef(res.timeout)) {
            setTimeout(function () {
              if (isUndef(factory.resolved)) {
                reject(null);
              }
            }, res.timeout);
          }
        }
      }

      sync = false;
      // return in case resolved synchronously
      return factory.loading ? factory.loadingComp : factory.resolved;
    }
  }

  /*  */

  function isAsyncPlaceholder(node) {
    return node.isComment && node.asyncFactory;
  }

  /*  */

  function getFirstComponentChild(children) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        var c = children[i];
        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
          return c;
        }
      }
    }
  }

  /*  */

  /*  */

  function initEvents(vm) {
    vm._events = Object.create(null);
    vm._hasHookEvent = false;
    // init parent attached events
    var listeners = vm.$options._parentListeners;
    if (listeners) {
      updateComponentListeners(vm, listeners);
    }
  }

  var target;

  function add(event, fn, once) {
    if (once) {
      target.$once(event, fn);
    } else {
      target.$on(event, fn);
    }
  }

  function remove$1(event, fn) {
    target.$off(event, fn);
  }

  function updateComponentListeners(vm, listeners, oldListeners) {
    target = vm;
    updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
    target = undefined;
  }

  function eventsMixin(Vue) {
    var hookRE = /^hook:/;
    Vue.prototype.$on = function (event, fn) {
      var this$1 = this;

      var vm = this;
      if (Array.isArray(event)) {
        for (var i = 0, l = event.length; i < l; i++) {
          this$1.$on(event[i], fn);
        }
      } else {
        (vm._events[event] || (vm._events[event] = [])).push(fn);
        // optimize hook:event cost by using a boolean flag marked at registration
        // instead of a hash lookup
        if (hookRE.test(event)) {
          vm._hasHookEvent = true;
        }
      }
      return vm;
    };

    Vue.prototype.$once = function (event, fn) {
      var vm = this;
      function on() {
        vm.$off(event, on);
        fn.apply(vm, arguments);
      }
      on.fn = fn;
      vm.$on(event, on);
      return vm;
    };

    Vue.prototype.$off = function (event, fn) {
      var this$1 = this;

      var vm = this;
      // all
      if (!arguments.length) {
        vm._events = Object.create(null);
        return vm;
      }
      // array of events
      if (Array.isArray(event)) {
        for (var i = 0, l = event.length; i < l; i++) {
          this$1.$off(event[i], fn);
        }
        return vm;
      }
      // specific event
      var cbs = vm._events[event];
      if (!cbs) {
        return vm;
      }
      if (!fn) {
        vm._events[event] = null;
        return vm;
      }
      if (fn) {
        // specific handler
        var cb;
        var i$1 = cbs.length;
        while (i$1--) {
          cb = cbs[i$1];
          if (cb === fn || cb.fn === fn) {
            cbs.splice(i$1, 1);
            break;
          }
        }
      }
      return vm;
    };

    Vue.prototype.$emit = function (event) {
      var vm = this;
      
      var cbs = vm._events[event];
      if (cbs) {
        cbs = cbs.length > 1 ? toArray$1(cbs) : cbs;
        var args = toArray$1(arguments, 1);
        for (var i = 0, l = cbs.length; i < l; i++) {
          try {
            cbs[i].apply(vm, args);
          } catch (e) {
            handleError(e, vm, "event handler for \"" + event + "\"");
          }
        }
      }
      return vm;
    };
  }

  /*  */

  /**
   * Runtime helper for resolving raw children VNodes into a slot object.
   */
  function resolveSlots(children, context) {
    var slots = {};
    if (!children) {
      return slots;
    }
    for (var i = 0, l = children.length; i < l; i++) {
      var child = children[i];
      var data = child.data;
      // remove slot attribute if the node is resolved as a Vue slot node
      if (data && data.attrs && data.attrs.slot) {
        delete data.attrs.slot;
      }
      // named slots should only be respected if the vnode was rendered in the
      // same context.
      if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
        var name = data.slot;
        var slot = slots[name] || (slots[name] = []);
        if (child.tag === 'template') {
          slot.push.apply(slot, child.children || []);
        } else {
          slot.push(child);
        }
      } else {
        (slots.default || (slots.default = [])).push(child);
      }
    }
    // ignore slots that contains only whitespace
    for (var name$1 in slots) {
      if (slots[name$1].every(isWhitespace)) {
        delete slots[name$1];
      }
    }
    return slots;
  }

  function isWhitespace(node) {
    return node.isComment && !node.asyncFactory || node.text === ' ';
  }

  function resolveScopedSlots(fns, // see flow/vnode
  res) {
    res = res || {};
    for (var i = 0; i < fns.length; i++) {
      if (Array.isArray(fns[i])) {
        resolveScopedSlots(fns[i], res);
      } else {
        res[fns[i].key] = fns[i].fn;
      }
    }
    return res;
  }

  /*  */

  var activeInstance = null;

  function initLifecycle(vm) {
    var options = vm.$options;

    // locate first non-abstract parent
    var parent = options.parent;
    if (parent && !options.abstract) {
      while (parent.$options.abstract && parent.$parent) {
        parent = parent.$parent;
      }
      parent.$children.push(vm);
    }

    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;

    vm.$children = [];
    vm.$refs = {};

    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    vm._isMounted = false;
    vm._isDestroyed = false;
    vm._isBeingDestroyed = false;
  }

  function lifecycleMixin(Vue) {
    Vue.prototype._update = function (vnode, hydrating) {
      var vm = this;
      if (vm._isMounted) {
        callHook(vm, 'beforeUpdate');
      }
      var prevEl = vm.$el;
      var prevVnode = vm._vnode;
      var prevActiveInstance = activeInstance;
      activeInstance = vm;
      vm._vnode = vnode;
      // Vue.prototype.__patch__ is injected in entry points
      // based on the rendering backend used.
      if (!prevVnode) {
        // initial render
        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
        , vm.$options._parentElm, vm.$options._refElm);
        // no need for the ref nodes after initial patch
        // this prevents keeping a detached DOM tree in memory (#5851)
        vm.$options._parentElm = vm.$options._refElm = null;
      } else {
        // updates
        vm.$el = vm.__patch__(prevVnode, vnode);
      }
      activeInstance = prevActiveInstance;
      // update __vue__ reference
      if (prevEl) {
        prevEl.__vue__ = null;
      }
      if (vm.$el) {
        vm.$el.__vue__ = vm;
      }
      // if parent is an HOC, update its $el as well
      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
        vm.$parent.$el = vm.$el;
      }
      // updated hook is called by the scheduler to ensure that children are
      // updated in a parent's updated hook.
    };

    Vue.prototype.$forceUpdate = function () {
      var vm = this;
      if (vm._watcher) {
        vm._watcher.update();
      }
    };

    Vue.prototype.$destroy = function () {
      var vm = this;
      if (vm._isBeingDestroyed) {
        return;
      }
      callHook(vm, 'beforeDestroy');
      vm._isBeingDestroyed = true;
      // remove self from parent
      var parent = vm.$parent;
      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
        remove(parent.$children, vm);
      }
      // teardown watchers
      if (vm._watcher) {
        vm._watcher.teardown();
      }
      var i = vm._watchers.length;
      while (i--) {
        vm._watchers[i].teardown();
      }
      // remove reference from data ob
      // frozen object may not have observer.
      if (vm._data.__ob__) {
        vm._data.__ob__.vmCount--;
      }
      // call the last hook...
      vm._isDestroyed = true;
      // invoke destroy hooks on current rendered tree
      vm.__patch__(vm._vnode, null);
      // fire destroyed hook
      callHook(vm, 'destroyed');
      // turn off all instance listeners.
      vm.$off();
      // remove __vue__ reference
      if (vm.$el) {
        vm.$el.__vue__ = null;
      }
      // release circular reference (#6759)
      if (vm.$vnode) {
        vm.$vnode.parent = null;
      }
    };
  }

  function mountComponent(vm, el, hydrating) {
    vm.$el = el;
    if (!vm.$options.render) {
      vm.$options.render = createEmptyVNode;
    }
    callHook(vm, 'beforeMount');

    var updateComponent;
    /* istanbul ignore if */
    {
      updateComponent = function updateComponent() {
        vm._update(vm._render(), hydrating);
      };
    }

    // we set this to vm._watcher inside the watcher's constructor
    // since the watcher's initial patch may call $forceUpdate (e.g. inside child
    // component's mounted hook), which relies on vm._watcher being already defined
    new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);
    hydrating = false;

    // manually mounted instance, call mounted on self
    // mounted is called for render-created child components in its inserted hook
    if (vm.$vnode == null) {
      vm._isMounted = true;
      callHook(vm, 'mounted');
    }
    return vm;
  }

  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {

    // determine whether component has slot children
    // we need to do this before overwriting $options._renderChildren
    var hasChildren = !!(renderChildren || // has new static slots
    vm.$options._renderChildren || // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
    );

    vm.$options._parentVnode = parentVnode;
    vm.$vnode = parentVnode; // update vm's placeholder node without re-render

    if (vm._vnode) {
      // update child tree's parent
      vm._vnode.parent = parentVnode;
    }
    vm.$options._renderChildren = renderChildren;

    // update $attrs and $listeners hash
    // these are also reactive so they may trigger child update if the child
    // used them during render
    vm.$attrs = parentVnode.data.attrs || emptyObject;
    vm.$listeners = listeners || emptyObject;

    // update props
    if (propsData && vm.$options.props) {
      toggleObserving(false);
      var props = vm._props;
      var propKeys = vm.$options._propKeys || [];
      for (var i = 0; i < propKeys.length; i++) {
        var key = propKeys[i];
        var propOptions = vm.$options.props; // wtf flow?
        props[key] = validateProp(key, propOptions, propsData, vm);
      }
      toggleObserving(true);
      // keep a copy of raw propsData
      vm.$options.propsData = propsData;
    }

    // update listeners
    listeners = listeners || emptyObject;
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);

    // resolve slots + force update if has children
    if (hasChildren) {
      vm.$slots = resolveSlots(renderChildren, parentVnode.context);
      vm.$forceUpdate();
    }
  }

  function isInInactiveTree(vm) {
    while (vm && (vm = vm.$parent)) {
      if (vm._inactive) {
        return true;
      }
    }
    return false;
  }

  function activateChildComponent(vm, direct) {
    if (direct) {
      vm._directInactive = false;
      if (isInInactiveTree(vm)) {
        return;
      }
    } else if (vm._directInactive) {
      return;
    }
    if (vm._inactive || vm._inactive === null) {
      vm._inactive = false;
      for (var i = 0; i < vm.$children.length; i++) {
        activateChildComponent(vm.$children[i]);
      }
      callHook(vm, 'activated');
    }
  }

  function deactivateChildComponent(vm, direct) {
    if (direct) {
      vm._directInactive = true;
      if (isInInactiveTree(vm)) {
        return;
      }
    }
    if (!vm._inactive) {
      vm._inactive = true;
      for (var i = 0; i < vm.$children.length; i++) {
        deactivateChildComponent(vm.$children[i]);
      }
      callHook(vm, 'deactivated');
    }
  }

  function callHook(vm, hook) {
    // #7573 disable dep collection when invoking lifecycle hooks
    pushTarget();
    var handlers = vm.$options[hook];
    if (handlers) {
      for (var i = 0, j = handlers.length; i < j; i++) {
        try {
          handlers[i].call(vm);
        } catch (e) {
          handleError(e, vm, hook + " hook");
        }
      }
    }
    if (vm._hasHookEvent) {
      vm.$emit('hook:' + hook);
    }
    popTarget();
  }

  var queue = [];
  var activatedChildren = [];
  var has = {};
  var waiting = false;
  var flushing = false;
  var index = 0;

  /**
   * Reset the scheduler's state.
   */
  function resetSchedulerState() {
    index = queue.length = activatedChildren.length = 0;
    has = {};
    waiting = flushing = false;
  }

  /**
   * Flush both queues and run the watchers.
   */
  function flushSchedulerQueue() {
    flushing = true;
    var watcher, id;

    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child)
    // 2. A component's user watchers are run before its render watcher (because
    //    user watchers are created before the render watcher)
    // 3. If a component is destroyed during a parent component's watcher run,
    //    its watchers can be skipped.
    queue.sort(function (a, b) {
      return a.id - b.id;
    });

    // do not cache length because more watchers might be pushed
    // as we run existing watchers
    for (index = 0; index < queue.length; index++) {
      watcher = queue[index];
      id = watcher.id;
      has[id] = null;
      watcher.run();
    }

    // keep copies of post queues before resetting state
    var activatedQueue = activatedChildren.slice();
    var updatedQueue = queue.slice();

    resetSchedulerState();

    // call component updated and activated hooks
    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);

    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
      devtools.emit('flush');
    }
  }

  function callUpdatedHooks(queue) {
    var i = queue.length;
    while (i--) {
      var watcher = queue[i];
      var vm = watcher.vm;
      if (vm._watcher === watcher && vm._isMounted) {
        callHook(vm, 'updated');
      }
    }
  }

  /**
   * Queue a kept-alive component that was activated during patch.
   * The queue will be processed after the entire tree has been patched.
   */
  function queueActivatedComponent(vm) {
    // setting _inactive to false here so that a render function can
    // rely on checking whether it's in an inactive tree (e.g. router-view)
    vm._inactive = false;
    activatedChildren.push(vm);
  }

  function callActivatedHooks(queue) {
    for (var i = 0; i < queue.length; i++) {
      queue[i]._inactive = true;
      activateChildComponent(queue[i], true /* true */);
    }
  }

  /**
   * Push a watcher into the watcher queue.
   * Jobs with duplicate IDs will be skipped unless it's
   * pushed when the queue is being flushed.
   */
  function queueWatcher(watcher) {
    var id = watcher.id;
    if (has[id] == null) {
      has[id] = true;
      if (!flushing) {
        queue.push(watcher);
      } else {
        // if already flushing, splice the watcher based on its id
        // if already past its id, it will be run next immediately.
        var i = queue.length - 1;
        while (i > index && queue[i].id > watcher.id) {
          i--;
        }
        queue.splice(i + 1, 0, watcher);
      }
      // queue the flush
      if (!waiting) {
        waiting = true;
        nextTick(flushSchedulerQueue);
      }
    }
  }

  /*  */

  var uid$1 = 0;

  /**
   * A watcher parses an expression, collects dependencies,
   * and fires callback when the expression value changes.
   * This is used for both the $watch() api and directives.
   */
  var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
    this.vm = vm;
    if (isRenderWatcher) {
      vm._watcher = this;
    }
    vm._watchers.push(this);
    // options
    if (options) {
      this.deep = !!options.deep;
      this.user = !!options.user;
      this.lazy = !!options.lazy;
      this.sync = !!options.sync;
    } else {
      this.deep = this.user = this.lazy = this.sync = false;
    }
    this.cb = cb;
    this.id = ++uid$1; // uid for batching
    this.active = true;
    this.dirty = this.lazy; // for lazy watchers
    this.deps = [];
    this.newDeps = [];
    this.depIds = new _Set();
    this.newDepIds = new _Set();
    this.expression = '';
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn;
    } else {
      this.getter = parsePath(expOrFn);
      if (!this.getter) {
        this.getter = function () {};
      }
    }
    this.value = this.lazy ? undefined : this.get();
  };

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  Watcher.prototype.get = function get$$1() {
    pushTarget(this);
    var value;
    var vm = this.vm;
    try {
      value = this.getter.call(vm, vm);
    } catch (e) {
      if (this.user) {
        handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
      } else {
        throw e;
      }
    } finally {
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value);
      }
      popTarget();
      this.cleanupDeps();
    }
    return value;
  };

  /**
   * Add a dependency to this directive.
   */
  Watcher.prototype.addDep = function addDep(dep) {
    var id = dep.id;
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id);
      this.newDeps.push(dep);
      if (!this.depIds.has(id)) {
        dep.addSub(this);
      }
    }
  };

  /**
   * Clean up for dependency collection.
   */
  Watcher.prototype.cleanupDeps = function cleanupDeps() {
    var this$1 = this;

    var i = this.deps.length;
    while (i--) {
      var dep = this$1.deps[i];
      if (!this$1.newDepIds.has(dep.id)) {
        dep.removeSub(this$1);
      }
    }
    var tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
  };

  /**
   * Subscriber interface.
   * Will be called when a dependency changes.
   */
  Watcher.prototype.update = function update() {
    /* istanbul ignore else */
    if (this.lazy) {
      this.dirty = true;
    } else if (this.sync) {
      this.run();
    } else {
      queueWatcher(this);
    }
  };

  /**
   * Scheduler job interface.
   * Will be called by the scheduler.
   */
  Watcher.prototype.run = function run() {
    if (this.active) {
      var value = this.get();
      if (value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) || this.deep) {
        // set new value
        var oldValue = this.value;
        this.value = value;
        if (this.user) {
          try {
            this.cb.call(this.vm, value, oldValue);
          } catch (e) {
            handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
          }
        } else {
          this.cb.call(this.vm, value, oldValue);
        }
      }
    }
  };

  /**
   * Evaluate the value of the watcher.
   * This only gets called for lazy watchers.
   */
  Watcher.prototype.evaluate = function evaluate() {
    this.value = this.get();
    this.dirty = false;
  };

  /**
   * Depend on all deps collected by this watcher.
   */
  Watcher.prototype.depend = function depend() {
    var this$1 = this;

    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].depend();
    }
  };

  /**
   * Remove self from all dependencies' subscriber list.
   */
  Watcher.prototype.teardown = function teardown() {
    var this$1 = this;

    if (this.active) {
      // remove self from vm's watcher list
      // this is a somewhat expensive operation so we skip it
      // if the vm is being destroyed.
      if (!this.vm._isBeingDestroyed) {
        remove(this.vm._watchers, this);
      }
      var i = this.deps.length;
      while (i--) {
        this$1.deps[i].removeSub(this$1);
      }
      this.active = false;
    }
  };

  /*  */

  var sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop
  };

  function proxy(target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter() {
      return this[sourceKey][key];
    };
    sharedPropertyDefinition.set = function proxySetter(val) {
      this[sourceKey][key] = val;
    };
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function initState(vm) {
    vm._watchers = [];
    var opts = vm.$options;
    if (opts.props) {
      initProps(vm, opts.props);
    }
    if (opts.methods) {
      initMethods(vm, opts.methods);
    }
    if (opts.data) {
      initData(vm);
    } else {
      observe(vm._data = {}, true /* asRootData */);
    }
    if (opts.computed) {
      initComputed(vm, opts.computed);
    }
    if (opts.watch && opts.watch !== nativeWatch) {
      initWatch(vm, opts.watch);
    }
  }

  function initProps(vm, propsOptions) {
    var propsData = vm.$options.propsData || {};
    var props = vm._props = {};
    // cache prop keys so that future props updates can iterate using Array
    // instead of dynamic object key enumeration.
    var keys = vm.$options._propKeys = [];
    var isRoot = !vm.$parent;
    // root instance props should be converted
    if (!isRoot) {
      toggleObserving(false);
    }
    var loop = function loop(key) {
      keys.push(key);
      var value = validateProp(key, propsOptions, propsData, vm);
      /* istanbul ignore else */
      {
        defineReactive(props, key, value);
      }
      // static props are already proxied on the component's prototype
      // during Vue.extend(). We only need to proxy props defined at
      // instantiation here.
      if (!(key in vm)) {
        proxy(vm, "_props", key);
      }
    };

    for (var key in propsOptions) {
      loop(key);
    }toggleObserving(true);
  }

  function initData(vm) {
    var data = vm.$options.data;
    data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
    if (!isPlainObject(data)) {
      data = {};
    }
    // proxy data on instance
    var keys = Object.keys(data);
    var props = vm.$options.props;
    var methods = vm.$options.methods;
    var i = keys.length;
    while (i--) {
      var key = keys[i];
      if (props && hasOwn(props, key)) {
      } else if (!isReserved(key)) {
        proxy(vm, "_data", key);
      }
    }
    // observe data
    observe(data, true /* asRootData */);
  }

  function getData(data, vm) {
    // #7573 disable dep collection when invoking data getters
    pushTarget();
    try {
      return data.call(vm, vm);
    } catch (e) {
      handleError(e, vm, "data()");
      return {};
    } finally {
      popTarget();
    }
  }

  var computedWatcherOptions = { lazy: true };

  function initComputed(vm, computed) {
    // $flow-disable-line
    var watchers = vm._computedWatchers = Object.create(null);
    // computed properties are just getters during SSR
    var isSSR = isServerRendering();

    for (var key in computed) {
      var userDef = computed[key];
      var getter = typeof userDef === 'function' ? userDef : userDef.get;

      if (!isSSR) {
        // create internal watcher for the computed property.
        watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
      }

      // component-defined computed properties are already defined on the
      // component prototype. We only need to define computed properties defined
      // at instantiation here.
      if (!(key in vm)) {
        defineComputed(vm, key, userDef);
      } else {}
    }
  }

  function defineComputed(target, key, userDef) {
    var shouldCache = !isServerRendering();
    if (typeof userDef === 'function') {
      sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef;
      sharedPropertyDefinition.set = noop;
    } else {
      sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
      sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
    }
    Object.defineProperty(target, key, sharedPropertyDefinition);
  }

  function createComputedGetter(key) {
    return function computedGetter() {
      var watcher = this._computedWatchers && this._computedWatchers[key];
      if (watcher) {
        if (watcher.dirty) {
          watcher.evaluate();
        }
        if (Dep.target) {
          watcher.depend();
        }
        return watcher.value;
      }
    };
  }

  function initMethods(vm, methods) {
    var props = vm.$options.props;
    for (var key in methods) {
      vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
    }
  }

  function initWatch(vm, watch) {
    for (var key in watch) {
      var handler = watch[key];
      if (Array.isArray(handler)) {
        for (var i = 0; i < handler.length; i++) {
          createWatcher(vm, key, handler[i]);
        }
      } else {
        createWatcher(vm, key, handler);
      }
    }
  }

  function createWatcher(vm, expOrFn, handler, options) {
    if (isPlainObject(handler)) {
      options = handler;
      handler = handler.handler;
    }
    if (typeof handler === 'string') {
      handler = vm[handler];
    }
    return vm.$watch(expOrFn, handler, options);
  }

  function stateMixin(Vue) {
    // flow somehow has problems with directly declared definition object
    // when using Object.defineProperty, so we have to procedurally build up
    // the object here.
    var dataDef = {};
    dataDef.get = function () {
      return this._data;
    };
    var propsDef = {};
    propsDef.get = function () {
      return this._props;
    };
    Object.defineProperty(Vue.prototype, '$data', dataDef);
    Object.defineProperty(Vue.prototype, '$props', propsDef);

    Vue.prototype.$set = set$1;
    Vue.prototype.$delete = del;

    Vue.prototype.$watch = function (expOrFn, cb, options) {
      var vm = this;
      if (isPlainObject(cb)) {
        return createWatcher(vm, expOrFn, cb, options);
      }
      options = options || {};
      options.user = true;
      var watcher = new Watcher(vm, expOrFn, cb, options);
      if (options.immediate) {
        cb.call(vm, watcher.value);
      }
      return function unwatchFn() {
        watcher.teardown();
      };
    };
  }

  /*  */

  function initProvide(vm) {
    var provide = vm.$options.provide;
    if (provide) {
      vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
    }
  }

  function initInjections(vm) {
    var result = resolveInject(vm.$options.inject, vm);
    if (result) {
      toggleObserving(false);
      Object.keys(result).forEach(function (key) {
        /* istanbul ignore else */
        {
          defineReactive(vm, key, result[key]);
        }
      });
      toggleObserving(true);
    }
  }

  function resolveInject(inject, vm) {
    if (inject) {
      // inject is :any because flow is not smart enough to figure out cached
      var result = Object.create(null);
      var keys = hasSymbol ? Reflect.ownKeys(inject).filter(function (key) {
        /* istanbul ignore next */
        return Object.getOwnPropertyDescriptor(inject, key).enumerable;
      }) : Object.keys(inject);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var provideKey = inject[key].from;
        var source = vm;
        while (source) {
          if (source._provided && hasOwn(source._provided, provideKey)) {
            result[key] = source._provided[provideKey];
            break;
          }
          source = source.$parent;
        }
        if (!source) {
          if ('default' in inject[key]) {
            var provideDefault = inject[key].default;
            result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
          } else {}
        }
      }
      return result;
    }
  }

  /*  */

  /**
   * Runtime helper for rendering v-for lists.
   */
  function renderList(val, render) {
    var ret, i, l, keys, key;
    if (Array.isArray(val) || typeof val === 'string') {
      ret = new Array(val.length);
      for (i = 0, l = val.length; i < l; i++) {
        ret[i] = render(val[i], i);
      }
    } else if (typeof val === 'number') {
      ret = new Array(val);
      for (i = 0; i < val; i++) {
        ret[i] = render(i + 1, i);
      }
    } else if (isObject(val)) {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
    if (isDef(ret)) {
      ret._isVList = true;
    }
    return ret;
  }

  /*  */

  /**
   * Runtime helper for rendering <slot>
   */
  function renderSlot(name, fallback, props, bindObject) {
    var scopedSlotFn = this.$scopedSlots[name];
    var nodes;
    if (scopedSlotFn) {
      // scoped slot
      props = props || {};
      if (bindObject) {
        props = extend(extend({}, bindObject), props);
      }
      nodes = scopedSlotFn(props) || fallback;
    } else {
      var slotNodes = this.$slots[name];
      // warn duplicate slot usage
      if (slotNodes) {
        slotNodes._rendered = true;
      }
      nodes = slotNodes || fallback;
    }

    var target = props && props.slot;
    if (target) {
      return this.$createElement('template', { slot: target }, nodes);
    } else {
      return nodes;
    }
  }

  /*  */

  /**
   * Runtime helper for resolving filters
   */
  function resolveFilter(id) {
    return resolveAsset(this.$options, 'filters', id, true) || identity;
  }

  /*  */

  function isKeyNotMatch(expect, actual) {
    if (Array.isArray(expect)) {
      return expect.indexOf(actual) === -1;
    } else {
      return expect !== actual;
    }
  }

  /**
   * Runtime helper for checking keyCodes from config.
   * exposed as Vue.prototype._k
   * passing in eventKeyName as last argument separately for backwards compat
   */
  function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
      return isKeyNotMatch(builtInKeyName, eventKeyName);
    } else if (mappedKeyCode) {
      return isKeyNotMatch(mappedKeyCode, eventKeyCode);
    } else if (eventKeyName) {
      return hyphenate(eventKeyName) !== key;
    }
  }

  /*  */

  /**
   * Runtime helper for merging v-bind="object" into a VNode's data.
   */
  function bindObjectProps(data, tag, value, asProp, isSync) {
    if (value) {
      if (!isObject(value)) {
      } else {
        if (Array.isArray(value)) {
          value = toObject(value);
        }
        var hash;
        var loop = function loop(key) {
          if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
            hash = data;
          } else {
            var type = data.attrs && data.attrs.type;
            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
          }
          if (!(key in hash)) {
            hash[key] = value[key];

            if (isSync) {
              var on = data.on || (data.on = {});
              on["update:" + key] = function ($event) {
                value[key] = $event;
              };
            }
          }
        };

        for (var key in value) {
          loop(key);
        }
      }
    }
    return data;
  }

  /*  */

  /**
   * Runtime helper for rendering static trees.
   */
  function renderStatic(index, isInFor) {
    var cached = this._staticTrees || (this._staticTrees = []);
    var tree = cached[index];
    // if has already-rendered static tree and not inside v-for,
    // we can reuse the same tree.
    if (tree && !isInFor) {
      return tree;
    }
    // otherwise, render a fresh tree.
    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates
    );
    markStatic(tree, "__static__" + index, false);
    return tree;
  }

  /**
   * Runtime helper for v-once.
   * Effectively it means marking the node as static with a unique key.
   */
  function markOnce(tree, index, key) {
    markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
    return tree;
  }

  function markStatic(tree, key, isOnce) {
    if (Array.isArray(tree)) {
      for (var i = 0; i < tree.length; i++) {
        if (tree[i] && typeof tree[i] !== 'string') {
          markStaticNode(tree[i], key + "_" + i, isOnce);
        }
      }
    } else {
      markStaticNode(tree, key, isOnce);
    }
  }

  function markStaticNode(node, key, isOnce) {
    node.isStatic = true;
    node.key = key;
    node.isOnce = isOnce;
  }

  /*  */

  function bindObjectListeners(data, value) {
    if (value) {
      if (!isPlainObject(value)) {
      } else {
        var on = data.on = data.on ? extend({}, data.on) : {};
        for (var key in value) {
          var existing = on[key];
          var ours = value[key];
          on[key] = existing ? [].concat(existing, ours) : ours;
        }
      }
    }
    return data;
  }

  /*  */

  function installRenderHelpers(target) {
    target._o = markOnce;
    target._n = toNumber;
    target._s = toString;
    target._l = renderList;
    target._t = renderSlot;
    target._q = looseEqual;
    target._i = looseIndexOf;
    target._m = renderStatic;
    target._f = resolveFilter;
    target._k = checkKeyCodes;
    target._b = bindObjectProps;
    target._v = createTextVNode;
    target._e = createEmptyVNode;
    target._u = resolveScopedSlots;
    target._g = bindObjectListeners;
  }

  /*  */

  function FunctionalRenderContext(data, props, children, parent, Ctor) {
    var options = Ctor.options;
    // ensure the createElement function in functional components
    // gets a unique context - this is necessary for correct named slot check
    var contextVm;
    if (hasOwn(parent, '_uid')) {
      contextVm = Object.create(parent);
      // $flow-disable-line
      contextVm._original = parent;
    } else {
      // the context vm passed in is a functional context as well.
      // in this case we want to make sure we are able to get a hold to the
      // real context instance.
      contextVm = parent;
      // $flow-disable-line
      parent = parent._original;
    }
    var isCompiled = isTrue(options._compiled);
    var needNormalization = !isCompiled;

    this.data = data;
    this.props = props;
    this.children = children;
    this.parent = parent;
    this.listeners = data.on || emptyObject;
    this.injections = resolveInject(options.inject, parent);
    this.slots = function () {
      return resolveSlots(children, parent);
    };

    // support for compiled functional template
    if (isCompiled) {
      // exposing $options for renderStatic()
      this.$options = options;
      // pre-resolve slots for renderSlot()
      this.$slots = this.slots();
      this.$scopedSlots = data.scopedSlots || emptyObject;
    }

    if (options._scopeId) {
      this._c = function (a, b, c, d) {
        var vnode = createElement(contextVm, a, b, c, d, needNormalization);
        if (vnode && !Array.isArray(vnode)) {
          vnode.fnScopeId = options._scopeId;
          vnode.fnContext = parent;
        }
        return vnode;
      };
    } else {
      this._c = function (a, b, c, d) {
        return createElement(contextVm, a, b, c, d, needNormalization);
      };
    }
  }

  installRenderHelpers(FunctionalRenderContext.prototype);

  function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
    var options = Ctor.options;
    var props = {};
    var propOptions = options.props;
    if (isDef(propOptions)) {
      for (var key in propOptions) {
        props[key] = validateProp(key, propOptions, propsData || emptyObject);
      }
    } else {
      if (isDef(data.attrs)) {
        mergeProps(props, data.attrs);
      }
      if (isDef(data.props)) {
        mergeProps(props, data.props);
      }
    }

    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);

    var vnode = options.render.call(null, renderContext._c, renderContext);

    if (vnode instanceof VNode) {
      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options);
    } else if (Array.isArray(vnode)) {
      var vnodes = normalizeChildren(vnode) || [];
      var res = new Array(vnodes.length);
      for (var i = 0; i < vnodes.length; i++) {
        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);
      }
      return res;
    }
  }

  function cloneAndMarkFunctionalResult(vnode, data, contextVm, options) {
    // #7817 clone node before setting fnContext, otherwise if the node is reused
    // (e.g. it was from a cached normal slot) the fnContext causes named slots
    // that should not be matched to match.
    var clone = cloneVNode(vnode);
    clone.fnContext = contextVm;
    clone.fnOptions = options;
    if (data.slot) {
      (clone.data || (clone.data = {})).slot = data.slot;
    }
    return clone;
  }

  function mergeProps(to, from) {
    for (var key in from) {
      to[camelize(key)] = from[key];
    }
  }

  /*  */

  // Register the component hook to weex native render engine.
  // The hook will be triggered by native, not javascript.


  // Updates the state of the component to weex native render engine.

  /*  */

  // https://github.com/Hanks10100/weex-native-directive/tree/master/component

  // listening on native callback

  /*  */

  /*  */

  // inline hooks to be invoked on component VNodes during patch
  var componentVNodeHooks = {
    init: function init(vnode, hydrating, parentElm, refElm) {
      if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {
        // kept-alive components, treat as a patch
        var mountedNode = vnode; // work around flow
        componentVNodeHooks.prepatch(mountedNode, mountedNode);
      } else {
        var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
        child.$mount(hydrating ? vnode.elm : undefined, hydrating);
      }
    },

    prepatch: function prepatch(oldVnode, vnode) {
      var options = vnode.componentOptions;
      var child = vnode.componentInstance = oldVnode.componentInstance;
      updateChildComponent(child, options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
      );
    },

    insert: function insert(vnode) {
      var context = vnode.context;
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isMounted) {
        componentInstance._isMounted = true;
        callHook(componentInstance, 'mounted');
      }
      if (vnode.data.keepAlive) {
        if (context._isMounted) {
          // vue-router#1212
          // During updates, a kept-alive component's child components may
          // change, so directly walking the tree here may call activated hooks
          // on incorrect children. Instead we push them into a queue which will
          // be processed after the whole patch process ended.
          queueActivatedComponent(componentInstance);
        } else {
          activateChildComponent(componentInstance, true /* direct */);
        }
      }
    },

    destroy: function destroy(vnode) {
      var componentInstance = vnode.componentInstance;
      if (!componentInstance._isDestroyed) {
        if (!vnode.data.keepAlive) {
          componentInstance.$destroy();
        } else {
          deactivateChildComponent(componentInstance, true /* direct */);
        }
      }
    }
  };

  var hooksToMerge = Object.keys(componentVNodeHooks);

  function createComponent(Ctor, data, context, children, tag) {
    if (isUndef(Ctor)) {
      return;
    }

    var baseCtor = context.$options._base;

    // plain options object: turn it into a constructor
    if (isObject(Ctor)) {
      Ctor = baseCtor.extend(Ctor);
    }

    // if at this stage it's not a constructor or an async component factory,
    // reject.
    if (typeof Ctor !== 'function') {
      return;
    }

    // async component
    var asyncFactory;
    if (isUndef(Ctor.cid)) {
      asyncFactory = Ctor;
      Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
      if (Ctor === undefined) {
        // return a placeholder node for async component, which is rendered
        // as a comment node but preserves all the raw information for the node.
        // the information will be used for async server-rendering and hydration.
        return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
      }
    }

    data = data || {};

    // resolve constructor options in case global mixins are applied after
    // component constructor creation
    resolveConstructorOptions(Ctor);

    // transform component v-model data into props & events
    if (isDef(data.model)) {
      transformModel(Ctor.options, data);
    }

    // extract props
    var propsData = extractPropsFromVNodeData(data, Ctor, tag);

    // functional component
    if (isTrue(Ctor.options.functional)) {
      return createFunctionalComponent(Ctor, propsData, data, context, children);
    }

    // extract listeners, since these needs to be treated as
    // child component listeners instead of DOM listeners
    var listeners = data.on;
    // replace with listeners with .native modifier
    // so it gets processed during parent component patch.
    data.on = data.nativeOn;

    if (isTrue(Ctor.options.abstract)) {
      // abstract components do not keep anything
      // other than props & listeners & slot

      // work around flow
      var slot = data.slot;
      data = {};
      if (slot) {
        data.slot = slot;
      }
    }

    // install component management hooks onto the placeholder node
    installComponentHooks(data);

    // return a placeholder vnode
    var name = Ctor.options.name || tag;
    var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);

    // Weex specific: invoke recycle-list optimized @render function for
    // extracting cell-slot template.
    // https://github.com/Hanks10100/weex-native-directive/tree/master/component
    /* istanbul ignore if */
    return vnode;
  }

  function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm, refElm) {
    var options = {
      _isComponent: true,
      parent: parent,
      _parentVnode: vnode,
      _parentElm: parentElm || null,
      _refElm: refElm || null
    };
    // check inline-template render functions
    var inlineTemplate = vnode.data.inlineTemplate;
    if (isDef(inlineTemplate)) {
      options.render = inlineTemplate.render;
      options.staticRenderFns = inlineTemplate.staticRenderFns;
    }
    return new vnode.componentOptions.Ctor(options);
  }

  function installComponentHooks(data) {
    var hooks = data.hook || (data.hook = {});
    for (var i = 0; i < hooksToMerge.length; i++) {
      var key = hooksToMerge[i];
      hooks[key] = componentVNodeHooks[key];
    }
  }

  // transform component v-model info (value and callback) into
  // prop and event handler respectively.
  function transformModel(options, data) {
    var prop = options.model && options.model.prop || 'value';
    var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
    var on = data.on || (data.on = {});
    if (isDef(on[event])) {
      on[event] = [data.model.callback].concat(on[event]);
    } else {
      on[event] = data.model.callback;
    }
  }

  /*  */

  var SIMPLE_NORMALIZE = 1;
  var ALWAYS_NORMALIZE = 2;

  // wrapper function for providing a more flexible interface
  // without getting yelled at by flow
  function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
    if (Array.isArray(data) || isPrimitive(data)) {
      normalizationType = children;
      children = data;
      data = undefined;
    }
    if (isTrue(alwaysNormalize)) {
      normalizationType = ALWAYS_NORMALIZE;
    }
    return _createElement(context, tag, data, children, normalizationType);
  }

  function _createElement(context, tag, data, children, normalizationType) {
    if (isDef(data) && isDef(data.__ob__)) {
      return createEmptyVNode();
    }
    // object syntax in v-bind
    if (isDef(data) && isDef(data.is)) {
      tag = data.is;
    }
    if (!tag) {
      // in case of component :is set to falsy value
      return createEmptyVNode();
    }
    // support single function children as default scoped slot
    if (Array.isArray(children) && typeof children[0] === 'function') {
      data = data || {};
      data.scopedSlots = { default: children[0] };
      children.length = 0;
    }
    if (normalizationType === ALWAYS_NORMALIZE) {
      children = normalizeChildren(children);
    } else if (normalizationType === SIMPLE_NORMALIZE) {
      children = simpleNormalizeChildren(children);
    }
    var vnode, ns;
    if (typeof tag === 'string') {
      var Ctor;
      ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
      if (config.isReservedTag(tag)) {
        // platform built-in elements
        vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
      } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
        // component
        vnode = createComponent(Ctor, data, context, children, tag);
      } else {
        // unknown or unlisted namespaced elements
        // check at runtime because it may get assigned a namespace when its
        // parent normalizes children
        vnode = new VNode(tag, data, children, undefined, undefined, context);
      }
    } else {
      // direct component options / constructor
      vnode = createComponent(tag, data, context, children);
    }
    if (Array.isArray(vnode)) {
      return vnode;
    } else if (isDef(vnode)) {
      if (isDef(ns)) {
        applyNS(vnode, ns);
      }
      if (isDef(data)) {
        registerDeepBindings(data);
      }
      return vnode;
    } else {
      return createEmptyVNode();
    }
  }

  function applyNS(vnode, ns, force) {
    vnode.ns = ns;
    if (vnode.tag === 'foreignObject') {
      // use default namespace inside foreignObject
      ns = undefined;
      force = true;
    }
    if (isDef(vnode.children)) {
      for (var i = 0, l = vnode.children.length; i < l; i++) {
        var child = vnode.children[i];
        if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {
          applyNS(child, ns, force);
        }
      }
    }
  }

  // ref #5318
  // necessary to ensure parent re-render when deep bindings like :style and
  // :class are used on slot nodes
  function registerDeepBindings(data) {
    if (isObject(data.style)) {
      traverse(data.style);
    }
    if (isObject(data.class)) {
      traverse(data.class);
    }
  }

  /*  */

  function initRender(vm) {
    vm._vnode = null; // the root of the child tree
    vm._staticTrees = null; // v-once cached trees
    var options = vm.$options;
    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
    var renderContext = parentVnode && parentVnode.context;
    vm.$slots = resolveSlots(options._renderChildren, renderContext);
    vm.$scopedSlots = emptyObject;
    // bind the createElement fn to this instance
    // so that we get proper render context inside it.
    // args order: tag, data, children, normalizationType, alwaysNormalize
    // internal version is used by render functions compiled from templates
    vm._c = function (a, b, c, d) {
      return createElement(vm, a, b, c, d, false);
    };
    // normalization is always applied for the public version, used in
    // user-written render functions.
    vm.$createElement = function (a, b, c, d) {
      return createElement(vm, a, b, c, d, true);
    };

    // $attrs & $listeners are exposed for easier HOC creation.
    // they need to be reactive so that HOCs using them are always updated
    var parentData = parentVnode && parentVnode.data;

    /* istanbul ignore else */
    {
      defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
      defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);
    }
  }

  function renderMixin(Vue) {
    // install runtime convenience helpers
    installRenderHelpers(Vue.prototype);

    Vue.prototype.$nextTick = function (fn) {
      return nextTick(fn, this);
    };

    Vue.prototype._render = function () {
      var vm = this;
      var ref = vm.$options;
      var render = ref.render;
      var _parentVnode = ref._parentVnode;

      // reset _rendered flag on slots for duplicate slot check
      

      if (_parentVnode) {
        vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject;
      }

      // set parent vnode. this allows render functions to have access
      // to the data on the placeholder node.
      vm.$vnode = _parentVnode;
      // render self
      var vnode;
      try {
        vnode = render.call(vm._renderProxy, vm.$createElement);
      } catch (e) {
        handleError(e, vm, "render");
        // return error render result,
        // or previous vnode to prevent render error causing blank component
        /* istanbul ignore else */
        {
          vnode = vm._vnode;
        }
      }
      // return empty vnode in case the render function errored out
      if (!(vnode instanceof VNode)) {
        vnode = createEmptyVNode();
      }
      // set parent
      vnode.parent = _parentVnode;
      return vnode;
    };
  }

  /*  */

  var uid$3 = 0;

  function initMixin(Vue) {
    Vue.prototype._init = function (options) {
      var vm = this;
      // a uid
      vm._uid = uid$3++;

      // a flag to avoid this being observed
      vm._isVue = true;
      // merge options
      if (options && options._isComponent) {
        // optimize internal component instantiation
        // since dynamic options merging is pretty slow, and none of the
        // internal component options needs special treatment.
        initInternalComponent(vm, options);
      } else {
        vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
      }
      /* istanbul ignore else */
      {
        vm._renderProxy = vm;
      }
      // expose real self
      vm._self = vm;
      initLifecycle(vm);
      initEvents(vm);
      initRender(vm);
      callHook(vm, 'beforeCreate');
      initInjections(vm); // resolve injections before data/props
      initState(vm);
      initProvide(vm); // resolve provide after data/props
      callHook(vm, 'created');

      if (vm.$options.el) {
        vm.$mount(vm.$options.el);
      }
    };
  }

  function initInternalComponent(vm, options) {
    var opts = vm.$options = Object.create(vm.constructor.options);
    // doing this because it's faster than dynamic enumeration.
    var parentVnode = options._parentVnode;
    opts.parent = options.parent;
    opts._parentVnode = parentVnode;
    opts._parentElm = options._parentElm;
    opts._refElm = options._refElm;

    var vnodeComponentOptions = parentVnode.componentOptions;
    opts.propsData = vnodeComponentOptions.propsData;
    opts._parentListeners = vnodeComponentOptions.listeners;
    opts._renderChildren = vnodeComponentOptions.children;
    opts._componentTag = vnodeComponentOptions.tag;

    if (options.render) {
      opts.render = options.render;
      opts.staticRenderFns = options.staticRenderFns;
    }
  }

  function resolveConstructorOptions(Ctor) {
    var options = Ctor.options;
    if (Ctor.super) {
      var superOptions = resolveConstructorOptions(Ctor.super);
      var cachedSuperOptions = Ctor.superOptions;
      if (superOptions !== cachedSuperOptions) {
        // super option changed,
        // need to resolve new options.
        Ctor.superOptions = superOptions;
        // check if there are any late-modified/attached options (#4976)
        var modifiedOptions = resolveModifiedOptions(Ctor);
        // update base extend options
        if (modifiedOptions) {
          extend(Ctor.extendOptions, modifiedOptions);
        }
        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
        if (options.name) {
          options.components[options.name] = Ctor;
        }
      }
    }
    return options;
  }

  function resolveModifiedOptions(Ctor) {
    var modified;
    var latest = Ctor.options;
    var extended = Ctor.extendOptions;
    var sealed = Ctor.sealedOptions;
    for (var key in latest) {
      if (latest[key] !== sealed[key]) {
        if (!modified) {
          modified = {};
        }
        modified[key] = dedupe(latest[key], extended[key], sealed[key]);
      }
    }
    return modified;
  }

  function dedupe(latest, extended, sealed) {
    // compare latest and sealed to ensure lifecycle hooks won't be duplicated
    // between merges
    if (Array.isArray(latest)) {
      var res = [];
      sealed = Array.isArray(sealed) ? sealed : [sealed];
      extended = Array.isArray(extended) ? extended : [extended];
      for (var i = 0; i < latest.length; i++) {
        // push original options and not sealed options to exclude duplicated options
        if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
          res.push(latest[i]);
        }
      }
      return res;
    } else {
      return latest;
    }
  }

  function Vue(options) {
    this._init(options);
  }

  initMixin(Vue);
  stateMixin(Vue);
  eventsMixin(Vue);
  lifecycleMixin(Vue);
  renderMixin(Vue);

  /*  */

  function initUse(Vue) {
    Vue.use = function (plugin) {
      var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
      if (installedPlugins.indexOf(plugin) > -1) {
        return this;
      }

      // additional parameters
      var args = toArray$1(arguments, 1);
      args.unshift(this);
      if (typeof plugin.install === 'function') {
        plugin.install.apply(plugin, args);
      } else if (typeof plugin === 'function') {
        plugin.apply(null, args);
      }
      installedPlugins.push(plugin);
      return this;
    };
  }

  /*  */

  function initMixin$1(Vue) {
    Vue.mixin = function (mixin) {
      this.options = mergeOptions(this.options, mixin);
      return this;
    };
  }

  /*  */

  function initExtend(Vue) {
    /**
     * Each instance constructor, including Vue, has a unique
     * cid. This enables us to create wrapped "child
     * constructors" for prototypal inheritance and cache them.
     */
    Vue.cid = 0;
    var cid = 1;

    /**
     * Class inheritance
     */
    Vue.extend = function (extendOptions) {
      extendOptions = extendOptions || {};
      var Super = this;
      var SuperId = Super.cid;
      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
      if (cachedCtors[SuperId]) {
        return cachedCtors[SuperId];
      }

      var name = extendOptions.name || Super.options.name;

      var Sub = function VueComponent(options) {
        this._init(options);
      };
      Sub.prototype = Object.create(Super.prototype);
      Sub.prototype.constructor = Sub;
      Sub.cid = cid++;
      Sub.options = mergeOptions(Super.options, extendOptions);
      Sub['super'] = Super;

      // For props and computed properties, we define the proxy getters on
      // the Vue instances at extension time, on the extended prototype. This
      // avoids Object.defineProperty calls for each instance created.
      if (Sub.options.props) {
        initProps$1(Sub);
      }
      if (Sub.options.computed) {
        initComputed$1(Sub);
      }

      // allow further extension/mixin/plugin usage
      Sub.extend = Super.extend;
      Sub.mixin = Super.mixin;
      Sub.use = Super.use;

      // create asset registers, so extended classes
      // can have their private assets too.
      ASSET_TYPES.forEach(function (type) {
        Sub[type] = Super[type];
      });
      // enable recursive self-lookup
      if (name) {
        Sub.options.components[name] = Sub;
      }

      // keep a reference to the super options at extension time.
      // later at instantiation we can check if Super's options have
      // been updated.
      Sub.superOptions = Super.options;
      Sub.extendOptions = extendOptions;
      Sub.sealedOptions = extend({}, Sub.options);

      // cache constructor
      cachedCtors[SuperId] = Sub;
      return Sub;
    };
  }

  function initProps$1(Comp) {
    var props = Comp.options.props;
    for (var key in props) {
      proxy(Comp.prototype, "_props", key);
    }
  }

  function initComputed$1(Comp) {
    var computed = Comp.options.computed;
    for (var key in computed) {
      defineComputed(Comp.prototype, key, computed[key]);
    }
  }

  /*  */

  function initAssetRegisters(Vue) {
    /**
     * Create asset registration methods.
     */
    ASSET_TYPES.forEach(function (type) {
      Vue[type] = function (id, definition) {
        if (!definition) {
          return this.options[type + 's'][id];
        } else {
          if (type === 'component' && isPlainObject(definition)) {
            definition.name = definition.name || id;
            definition = this.options._base.extend(definition);
          }
          if (type === 'directive' && typeof definition === 'function') {
            definition = { bind: definition, update: definition };
          }
          this.options[type + 's'][id] = definition;
          return definition;
        }
      };
    });
  }

  /*  */

  function getComponentName(opts) {
    return opts && (opts.Ctor.options.name || opts.tag);
  }

  function matches(pattern, name) {
    if (Array.isArray(pattern)) {
      return pattern.indexOf(name) > -1;
    } else if (typeof pattern === 'string') {
      return pattern.split(',').indexOf(name) > -1;
    } else if (isRegExp(pattern)) {
      return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
  }

  function pruneCache(keepAliveInstance, filter) {
    var cache = keepAliveInstance.cache;
    var keys = keepAliveInstance.keys;
    var _vnode = keepAliveInstance._vnode;
    for (var key in cache) {
      var cachedNode = cache[key];
      if (cachedNode) {
        var name = getComponentName(cachedNode.componentOptions);
        if (name && !filter(name)) {
          pruneCacheEntry(cache, key, keys, _vnode);
        }
      }
    }
  }

  function pruneCacheEntry(cache, key, keys, current) {
    var cached$$1 = cache[key];
    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
      cached$$1.componentInstance.$destroy();
    }
    cache[key] = null;
    remove(keys, key);
  }

  var patternTypes = [String, RegExp, Array];

  var KeepAlive = {
    name: 'keep-alive',
    abstract: true,

    props: {
      include: patternTypes,
      exclude: patternTypes,
      max: [String, Number]
    },

    created: function created() {
      this.cache = Object.create(null);
      this.keys = [];
    },

    destroyed: function destroyed() {
      var this$1 = this;

      for (var key in this$1.cache) {
        pruneCacheEntry(this$1.cache, key, this$1.keys);
      }
    },

    mounted: function mounted() {
      var this$1 = this;

      this.$watch('include', function (val) {
        pruneCache(this$1, function (name) {
          return matches(val, name);
        });
      });
      this.$watch('exclude', function (val) {
        pruneCache(this$1, function (name) {
          return !matches(val, name);
        });
      });
    },

    render: function render() {
      var slot = this.$slots.default;
      var vnode = getFirstComponentChild(slot);
      var componentOptions = vnode && vnode.componentOptions;
      if (componentOptions) {
        // check pattern
        var name = getComponentName(componentOptions);
        var ref = this;
        var include = ref.include;
        var exclude = ref.exclude;
        if (
        // not included
        include && (!name || !matches(include, name)) ||
        // excluded
        exclude && name && matches(exclude, name)) {
          return vnode;
        }

        var ref$1 = this;
        var cache = ref$1.cache;
        var keys = ref$1.keys;
        var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
        if (cache[key]) {
          vnode.componentInstance = cache[key].componentInstance;
          // make current key freshest
          remove(keys, key);
          keys.push(key);
        } else {
          cache[key] = vnode;
          keys.push(key);
          // prune oldest entry
          if (this.max && keys.length > parseInt(this.max)) {
            pruneCacheEntry(cache, keys[0], keys, this._vnode);
          }
        }

        vnode.data.keepAlive = true;
      }
      return vnode || slot && slot[0];
    }
  };

  var builtInComponents = {
    KeepAlive: KeepAlive

    /*  */

  };function initGlobalAPI(Vue) {
    // config
    var configDef = {};
    configDef.get = function () {
      return config;
    };
    Object.defineProperty(Vue, 'config', configDef);

    // exposed util methods.
    // NOTE: these are not considered part of the public API - avoid relying on
    // them unless you are aware of the risk.
    Vue.util = {
      warn: warn,
      extend: extend,
      mergeOptions: mergeOptions,
      defineReactive: defineReactive
    };

    Vue.set = set$1;
    Vue.delete = del;
    Vue.nextTick = nextTick;

    Vue.options = Object.create(null);
    ASSET_TYPES.forEach(function (type) {
      Vue.options[type + 's'] = Object.create(null);
    });

    // this is used to identify the "base" constructor to extend all plain-object
    // components with in Weex's multi-instance scenarios.
    Vue.options._base = Vue;

    extend(Vue.options.components, builtInComponents);

    initUse(Vue);
    initMixin$1(Vue);
    initExtend(Vue);
    initAssetRegisters(Vue);
  }

  initGlobalAPI(Vue);

  Object.defineProperty(Vue.prototype, '$isServer', {
    get: isServerRendering
  });

  Object.defineProperty(Vue.prototype, '$ssrContext', {
    get: function get$$1() {
      /* istanbul ignore next */
      return this.$vnode && this.$vnode.ssrContext;
    }
  });

  // expose FunctionalRenderContext for ssr runtime helper installation
  Object.defineProperty(Vue, 'FunctionalRenderContext', {
    value: FunctionalRenderContext
  });

  Vue.version = '2.5.16';

  /*  */

  // these are reserved for web because they are directly compiled away
  // during template compilation
  var isReservedAttr = makeMap('style,class');

  // attributes that should be using props for binding
  var acceptValue = makeMap('input,textarea,option,select,progress');
  var mustUseProp = function mustUseProp(tag, type, attr) {
    return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
  };

  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

  var xlinkNS = 'http://www.w3.org/1999/xlink';

  var isXlink = function isXlink(name) {
    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
  };

  var getXlinkProp = function getXlinkProp(name) {
    return isXlink(name) ? name.slice(6, name.length) : '';
  };

  var isFalsyAttrValue = function isFalsyAttrValue(val) {
    return val == null || val === false;
  };

  /*  */

  function genClassForVnode(vnode) {
    var data = vnode.data;
    var parentNode = vnode;
    var childNode = vnode;
    while (isDef(childNode.componentInstance)) {
      childNode = childNode.componentInstance._vnode;
      if (childNode && childNode.data) {
        data = mergeClassData(childNode.data, data);
      }
    }
    while (isDef(parentNode = parentNode.parent)) {
      if (parentNode && parentNode.data) {
        data = mergeClassData(data, parentNode.data);
      }
    }
    return renderClass(data.staticClass, data.class);
  }

  function mergeClassData(child, parent) {
    return {
      staticClass: concat(child.staticClass, parent.staticClass),
      class: isDef(child.class) ? [child.class, parent.class] : parent.class
    };
  }

  function renderClass(staticClass, dynamicClass) {
    if (isDef(staticClass) || isDef(dynamicClass)) {
      return concat(staticClass, stringifyClass(dynamicClass));
    }
    /* istanbul ignore next */
    return '';
  }

  function concat(a, b) {
    return a ? b ? a + ' ' + b : a : b || '';
  }

  function stringifyClass(value) {
    if (Array.isArray(value)) {
      return stringifyArray(value);
    }
    if (isObject(value)) {
      return stringifyObject(value);
    }
    if (typeof value === 'string') {
      return value;
    }
    /* istanbul ignore next */
    return '';
  }

  function stringifyArray(value) {
    var res = '';
    var stringified;
    for (var i = 0, l = value.length; i < l; i++) {
      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
        if (res) {
          res += ' ';
        }
        res += stringified;
      }
    }
    return res;
  }

  function stringifyObject(value) {
    var res = '';
    for (var key in value) {
      if (value[key]) {
        if (res) {
          res += ' ';
        }
        res += key;
      }
    }
    return res;
  }

  /*  */

  var namespaceMap = {
    svg: 'http://www.w3.org/2000/svg',
    math: 'http://www.w3.org/1998/Math/MathML'
  };

  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');

  // this map is intentionally selective, only covering SVG elements that may
  // contain child elements.
  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

  var isPreTag = function isPreTag(tag) {
    return tag === 'pre';
  };

  var isReservedTag = function isReservedTag(tag) {
    return isHTMLTag(tag) || isSVG(tag);
  };

  function getTagNamespace(tag) {
    if (isSVG(tag)) {
      return 'svg';
    }
    // basic support for MathML
    // note it doesn't support other MathML elements being component roots
    if (tag === 'math') {
      return 'math';
    }
  }

  var unknownElementCache = Object.create(null);
  function isUnknownElement(tag) {
    /* istanbul ignore if */
    if (!inBrowser) {
      return true;
    }
    if (isReservedTag(tag)) {
      return false;
    }
    tag = tag.toLowerCase();
    /* istanbul ignore if */
    if (unknownElementCache[tag] != null) {
      return unknownElementCache[tag];
    }
    var el = document.createElement(tag);
    if (tag.indexOf('-') > -1) {
      // http://stackoverflow.com/a/28210364/1070244
      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
    } else {
      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
    }
  }

  var isTextInputType = makeMap('text,number,password,search,email,tel,url');

  /*  */

  /**
   * Query an element selector if it's not an element already.
   */
  function query(el) {
    if (typeof el === 'string') {
      var selected = document.querySelector(el);
      if (!selected) {
        return document.createElement('div');
      }
      return selected;
    } else {
      return el;
    }
  }

  /*  */

  function createElement$1(tagName, vnode) {
    var elm = document.createElement(tagName);
    if (tagName !== 'select') {
      return elm;
    }
    // false or null will remove the attribute but undefined will not
    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
      elm.setAttribute('multiple', 'multiple');
    }
    return elm;
  }

  function createElementNS(namespace, tagName) {
    return document.createElementNS(namespaceMap[namespace], tagName);
  }

  function createTextNode(text) {
    return document.createTextNode(text);
  }

  function createComment(text) {
    return document.createComment(text);
  }

  function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
  }

  function removeChild(node, child) {
    node.removeChild(child);
  }

  function appendChild(node, child) {
    node.appendChild(child);
  }

  function parentNode(node) {
    return node.parentNode;
  }

  function nextSibling(node) {
    return node.nextSibling;
  }

  function tagName(node) {
    return node.tagName;
  }

  function setTextContent(node, text) {
    node.textContent = text;
  }

  function setStyleScope(node, scopeId) {
    node.setAttribute(scopeId, '');
  }

  var nodeOps = Object.freeze({
    createElement: createElement$1,
    createElementNS: createElementNS,
    createTextNode: createTextNode,
    createComment: createComment,
    insertBefore: insertBefore,
    removeChild: removeChild,
    appendChild: appendChild,
    parentNode: parentNode,
    nextSibling: nextSibling,
    tagName: tagName,
    setTextContent: setTextContent,
    setStyleScope: setStyleScope
  });

  /*  */

  var ref = {
    create: function create(_, vnode) {
      registerRef(vnode);
    },
    update: function update(oldVnode, vnode) {
      if (oldVnode.data.ref !== vnode.data.ref) {
        registerRef(oldVnode, true);
        registerRef(vnode);
      }
    },
    destroy: function destroy(vnode) {
      registerRef(vnode, true);
    }
  };

  function registerRef(vnode, isRemoval) {
    var key = vnode.data.ref;
    if (!isDef(key)) {
      return;
    }

    var vm = vnode.context;
    var ref = vnode.componentInstance || vnode.elm;
    var refs = vm.$refs;
    if (isRemoval) {
      if (Array.isArray(refs[key])) {
        remove(refs[key], ref);
      } else if (refs[key] === ref) {
        refs[key] = undefined;
      }
    } else {
      if (vnode.data.refInFor) {
        if (!Array.isArray(refs[key])) {
          refs[key] = [ref];
        } else if (refs[key].indexOf(ref) < 0) {
          // $flow-disable-line
          refs[key].push(ref);
        }
      } else {
        refs[key] = ref;
      }
    }
  }

  /**
   * Virtual DOM patching algorithm based on Snabbdom by
   * Simon Friis Vindum (@paldepind)
   * Licensed under the MIT License
   * https://github.com/paldepind/snabbdom/blob/master/LICENSE
   *
   * modified by Evan You (@yyx990803)
   *
   * Not type-checking this because this file is perf-critical and the cost
   * of making flow understand it is not worth it.
   */

  var emptyNode = new VNode('', {}, []);

  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

  function sameVnode(a, b) {
    return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
  }

  function sameInputType(a, b) {
    if (a.tag !== 'input') {
      return true;
    }
    var i;
    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
  }

  function createKeyToOldIdx(children, beginIdx, endIdx) {
    var i, key;
    var map = {};
    for (i = beginIdx; i <= endIdx; ++i) {
      key = children[i].key;
      if (isDef(key)) {
        map[key] = i;
      }
    }
    return map;
  }

  function createPatchFunction(backend) {
    var i, j;
    var cbs = {};

    var modules = backend.modules;
    var nodeOps = backend.nodeOps;

    for (i = 0; i < hooks.length; ++i) {
      cbs[hooks[i]] = [];
      for (j = 0; j < modules.length; ++j) {
        if (isDef(modules[j][hooks[i]])) {
          cbs[hooks[i]].push(modules[j][hooks[i]]);
        }
      }
    }

    function emptyNodeAt(elm) {
      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
    }

    function createRmCb(childElm, listeners) {
      function remove() {
        if (--remove.listeners === 0) {
          removeNode(childElm);
        }
      }
      remove.listeners = listeners;
      return remove;
    }

    function removeNode(el) {
      var parent = nodeOps.parentNode(el);
      // element may have already been removed due to v-html / v-text
      if (isDef(parent)) {
        nodeOps.removeChild(parent, el);
      }
    }

    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
      if (isDef(vnode.elm) && isDef(ownerArray)) {
        // This vnode was used in a previous render!
        // now it's used as a new node, overwriting its elm would cause
        // potential patch errors down the road when it's used as an insertion
        // reference node. Instead, we clone the node on-demand before creating
        // associated DOM element for it.
        vnode = ownerArray[index] = cloneVNode(vnode);
      }

      vnode.isRootInsert = !nested; // for transition enter check
      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
        return;
      }

      var data = vnode.data;
      var children = vnode.children;
      var tag = vnode.tag;
      if (isDef(tag)) {

        vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
        setScope(vnode);

        /* istanbul ignore if */
        {
          createChildren(vnode, children, insertedVnodeQueue);
          if (isDef(data)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
          }
          insert(parentElm, vnode.elm, refElm);
        }
      } else if (isTrue(vnode.isComment)) {
        vnode.elm = nodeOps.createComment(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      } else {
        vnode.elm = nodeOps.createTextNode(vnode.text);
        insert(parentElm, vnode.elm, refElm);
      }
    }

    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
      var i = vnode.data;
      if (isDef(i)) {
        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
        if (isDef(i = i.hook) && isDef(i = i.init)) {
          i(vnode, false /* hydrating */, parentElm, refElm);
        }
        // after calling the init hook, if the vnode is a child component
        // it should've created a child instance and mounted it. the child
        // component also has set the placeholder vnode's elm.
        // in that case we can just return the element and be done.
        if (isDef(vnode.componentInstance)) {
          initComponent(vnode, insertedVnodeQueue);
          if (isTrue(isReactivated)) {
            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
          }
          return true;
        }
      }
    }

    function initComponent(vnode, insertedVnodeQueue) {
      if (isDef(vnode.data.pendingInsert)) {
        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
        vnode.data.pendingInsert = null;
      }
      vnode.elm = vnode.componentInstance.$el;
      if (isPatchable(vnode)) {
        invokeCreateHooks(vnode, insertedVnodeQueue);
        setScope(vnode);
      } else {
        // empty component root.
        // skip all element-related modules except for ref (#3455)
        registerRef(vnode);
        // make sure to invoke the insert hook
        insertedVnodeQueue.push(vnode);
      }
    }

    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
      var i;
      // hack for #4339: a reactivated component with inner transition
      // does not trigger because the inner node's created hooks are not called
      // again. It's not ideal to involve module-specific logic in here but
      // there doesn't seem to be a better way to do it.
      var innerNode = vnode;
      while (innerNode.componentInstance) {
        innerNode = innerNode.componentInstance._vnode;
        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
          for (i = 0; i < cbs.activate.length; ++i) {
            cbs.activate[i](emptyNode, innerNode);
          }
          insertedVnodeQueue.push(innerNode);
          break;
        }
      }
      // unlike a newly created component,
      // a reactivated keep-alive component doesn't insert itself
      insert(parentElm, vnode.elm, refElm);
    }

    function insert(parent, elm, ref$$1) {
      if (isDef(parent)) {
        if (isDef(ref$$1)) {
          if (ref$$1.parentNode === parent) {
            nodeOps.insertBefore(parent, elm, ref$$1);
          }
        } else {
          nodeOps.appendChild(parent, elm);
        }
      }
    }

    function createChildren(vnode, children, insertedVnodeQueue) {
      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; ++i) {
          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
        }
      } else if (isPrimitive(vnode.text)) {
        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
      }
    }

    function isPatchable(vnode) {
      while (vnode.componentInstance) {
        vnode = vnode.componentInstance._vnode;
      }
      return isDef(vnode.tag);
    }

    function invokeCreateHooks(vnode, insertedVnodeQueue) {
      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
        cbs.create[i$1](emptyNode, vnode);
      }
      i = vnode.data.hook; // Reuse variable
      if (isDef(i)) {
        if (isDef(i.create)) {
          i.create(emptyNode, vnode);
        }
        if (isDef(i.insert)) {
          insertedVnodeQueue.push(vnode);
        }
      }
    }

    // set scope id attribute for scoped CSS.
    // this is implemented as a special case to avoid the overhead
    // of going through the normal attribute patching process.
    function setScope(vnode) {
      var i;
      if (isDef(i = vnode.fnScopeId)) {
        nodeOps.setStyleScope(vnode.elm, i);
      } else {
        var ancestor = vnode;
        while (ancestor) {
          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
            nodeOps.setStyleScope(vnode.elm, i);
          }
          ancestor = ancestor.parent;
        }
      }
      // for slot content they should also get the scopeId from the host instance.
      if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
        nodeOps.setStyleScope(vnode.elm, i);
      }
    }

    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
      for (; startIdx <= endIdx; ++startIdx) {
        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
      }
    }

    function invokeDestroyHook(vnode) {
      var i, j;
      var data = vnode.data;
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.destroy)) {
          i(vnode);
        }
        for (i = 0; i < cbs.destroy.length; ++i) {
          cbs.destroy[i](vnode);
        }
      }
      if (isDef(i = vnode.children)) {
        for (j = 0; j < vnode.children.length; ++j) {
          invokeDestroyHook(vnode.children[j]);
        }
      }
    }

    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
      for (; startIdx <= endIdx; ++startIdx) {
        var ch = vnodes[startIdx];
        if (isDef(ch)) {
          if (isDef(ch.tag)) {
            removeAndInvokeRemoveHook(ch);
            invokeDestroyHook(ch);
          } else {
            // Text node
            removeNode(ch.elm);
          }
        }
      }
    }

    function removeAndInvokeRemoveHook(vnode, rm) {
      if (isDef(rm) || isDef(vnode.data)) {
        var i;
        var listeners = cbs.remove.length + 1;
        if (isDef(rm)) {
          // we have a recursively passed down rm callback
          // increase the listeners count
          rm.listeners += listeners;
        } else {
          // directly removing
          rm = createRmCb(vnode.elm, listeners);
        }
        // recursively invoke hooks on child component root node
        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
          removeAndInvokeRemoveHook(i, rm);
        }
        for (i = 0; i < cbs.remove.length; ++i) {
          cbs.remove[i](vnode, rm);
        }
        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
          i(vnode, rm);
        } else {
          rm();
        }
      } else {
        removeNode(vnode.elm);
      }
    }

    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
      var oldStartIdx = 0;
      var newStartIdx = 0;
      var oldEndIdx = oldCh.length - 1;
      var oldStartVnode = oldCh[0];
      var oldEndVnode = oldCh[oldEndIdx];
      var newEndIdx = newCh.length - 1;
      var newStartVnode = newCh[0];
      var newEndVnode = newCh[newEndIdx];
      var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

      // removeOnly is a special flag used only by <transition-group>
      // to ensure removed elements stay in correct relative positions
      // during leaving transitions
      var canMove = !removeOnly;

      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (isUndef(oldStartVnode)) {
          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
        } else if (isUndef(oldEndVnode)) {
          oldEndVnode = oldCh[--oldEndIdx];
        } else if (sameVnode(oldStartVnode, newStartVnode)) {
          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
          oldStartVnode = oldCh[++oldStartIdx];
          newStartVnode = newCh[++newStartIdx];
        } else if (sameVnode(oldEndVnode, newEndVnode)) {
          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
          oldEndVnode = oldCh[--oldEndIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldStartVnode, newEndVnode)) {
          // Vnode moved right
          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
          oldStartVnode = oldCh[++oldStartIdx];
          newEndVnode = newCh[--newEndIdx];
        } else if (sameVnode(oldEndVnode, newStartVnode)) {
          // Vnode moved left
          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
          oldEndVnode = oldCh[--oldEndIdx];
          newStartVnode = newCh[++newStartIdx];
        } else {
          if (isUndef(oldKeyToIdx)) {
            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
          }
          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
          if (isUndef(idxInOld)) {
            // New element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          } else {
            vnodeToMove = oldCh[idxInOld];
            if (sameVnode(vnodeToMove, newStartVnode)) {
              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
              oldCh[idxInOld] = undefined;
              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
            } else {
              // same key but different element. treat as new element
              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
            }
          }
          newStartVnode = newCh[++newStartIdx];
        }
      }
      if (oldStartIdx > oldEndIdx) {
        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
      } else if (newStartIdx > newEndIdx) {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      }
    }

    function findIdxInOld(node, oldCh, start, end) {
      for (var i = start; i < end; i++) {
        var c = oldCh[i];
        if (isDef(c) && sameVnode(node, c)) {
          return i;
        }
      }
    }

    function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
      if (oldVnode === vnode) {
        return;
      }

      var elm = vnode.elm = oldVnode.elm;

      if (isTrue(oldVnode.isAsyncPlaceholder)) {
        if (isDef(vnode.asyncFactory.resolved)) {
          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
        } else {
          vnode.isAsyncPlaceholder = true;
        }
        return;
      }

      // reuse element for static trees.
      // note we only do this if the vnode is cloned -
      // if the new node is not cloned it means the render functions have been
      // reset by the hot-reload-api and we need to do a proper re-render.
      if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
        vnode.componentInstance = oldVnode.componentInstance;
        return;
      }

      var i;
      var data = vnode.data;
      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
        i(oldVnode, vnode);
      }

      var oldCh = oldVnode.children;
      var ch = vnode.children;
      if (isDef(data) && isPatchable(vnode)) {
        for (i = 0; i < cbs.update.length; ++i) {
          cbs.update[i](oldVnode, vnode);
        }
        if (isDef(i = data.hook) && isDef(i = i.update)) {
          i(oldVnode, vnode);
        }
      }
      if (isUndef(vnode.text)) {
        if (isDef(oldCh) && isDef(ch)) {
          if (oldCh !== ch) {
            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
          }
        } else if (isDef(ch)) {
          if (isDef(oldVnode.text)) {
            nodeOps.setTextContent(elm, '');
          }
          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
        } else if (isDef(oldCh)) {
          removeVnodes(elm, oldCh, 0, oldCh.length - 1);
        } else if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
      } else if (oldVnode.text !== vnode.text) {
        nodeOps.setTextContent(elm, vnode.text);
      }
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
          i(oldVnode, vnode);
        }
      }
    }

    function invokeInsertHook(vnode, queue, initial) {
      // delay insert hooks for component root nodes, invoke them after the
      // element is really inserted
      if (isTrue(initial) && isDef(vnode.parent)) {
        vnode.parent.data.pendingInsert = queue;
      } else {
        for (var i = 0; i < queue.length; ++i) {
          queue[i].data.hook.insert(queue[i]);
        }
      }
    }
    // list of modules that can skip create hook during hydration because they
    // are already rendered on the client or has no need for initialization
    // Note: style is excluded because it relies on initial clone for future
    // deep updates (#7063).
    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

    // Note: this is a browser-only function so we can assume elms are DOM nodes.
    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
      var i;
      var tag = vnode.tag;
      var data = vnode.data;
      var children = vnode.children;
      inVPre = inVPre || data && data.pre;
      vnode.elm = elm;

      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
        vnode.isAsyncPlaceholder = true;
        return true;
      }
      if (isDef(data)) {
        if (isDef(i = data.hook) && isDef(i = i.init)) {
          i(vnode, true /* hydrating */);
        }
        if (isDef(i = vnode.componentInstance)) {
          // child component. it should have hydrated its own tree.
          initComponent(vnode, insertedVnodeQueue);
          return true;
        }
      }
      if (isDef(tag)) {
        if (isDef(children)) {
          // empty element, allow client to pick up and populate children
          if (!elm.hasChildNodes()) {
            createChildren(vnode, children, insertedVnodeQueue);
          } else {
            // v-html and domProps: innerHTML
            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
              if (i !== elm.innerHTML) {
                return false;
              }
            } else {
              // iterate and compare children lists
              var childrenMatch = true;
              var childNode = elm.firstChild;
              for (var i$1 = 0; i$1 < children.length; i$1++) {
                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                  childrenMatch = false;
                  break;
                }
                childNode = childNode.nextSibling;
              }
              // if childNode is not null, it means the actual childNodes list is
              // longer than the virtual children list.
              if (!childrenMatch || childNode) {
                return false;
              }
            }
          }
        }
        if (isDef(data)) {
          var fullInvoke = false;
          for (var key in data) {
            if (!isRenderedModule(key)) {
              fullInvoke = true;
              invokeCreateHooks(vnode, insertedVnodeQueue);
              break;
            }
          }
          if (!fullInvoke && data['class']) {
            // ensure collecting deps for deep class bindings for future updates
            traverse(data['class']);
          }
        }
      } else if (elm.data !== vnode.text) {
        elm.data = vnode.text;
      }
      return true;
    }

    return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
      if (isUndef(vnode)) {
        if (isDef(oldVnode)) {
          invokeDestroyHook(oldVnode);
        }
        return;
      }

      var isInitialPatch = false;
      var insertedVnodeQueue = [];

      if (isUndef(oldVnode)) {
        // empty mount (likely as component), create new root element
        isInitialPatch = true;
        createElm(vnode, insertedVnodeQueue, parentElm, refElm);
      } else {
        var isRealElement = isDef(oldVnode.nodeType);
        if (!isRealElement && sameVnode(oldVnode, vnode)) {
          // patch existing root node
          patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
        } else {
          if (isRealElement) {
            // mounting to a real element
            // check if this is server-rendered content and if we can perform
            // a successful hydration.
            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
              oldVnode.removeAttribute(SSR_ATTR);
              hydrating = true;
            }
            if (isTrue(hydrating)) {
              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                invokeInsertHook(vnode, insertedVnodeQueue, true);
                return oldVnode;
              } else {}
            }
            // either not server-rendered, or hydration failed.
            // create an empty node and replace it
            oldVnode = emptyNodeAt(oldVnode);
          }

          // replacing existing element
          var oldElm = oldVnode.elm;
          var parentElm$1 = nodeOps.parentNode(oldElm);

          // create new node
          createElm(vnode, insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));

          // update parent placeholder node element, recursively
          if (isDef(vnode.parent)) {
            var ancestor = vnode.parent;
            var patchable = isPatchable(vnode);
            while (ancestor) {
              for (var i = 0; i < cbs.destroy.length; ++i) {
                cbs.destroy[i](ancestor);
              }
              ancestor.elm = vnode.elm;
              if (patchable) {
                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                  cbs.create[i$1](emptyNode, ancestor);
                }
                // #6513
                // invoke insert hooks that may have been merged by create hooks.
                // e.g. for directives that uses the "inserted" hook.
                var insert = ancestor.data.hook.insert;
                if (insert.merged) {
                  // start at index 1 to avoid re-invoking component mounted hook
                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                    insert.fns[i$2]();
                  }
                }
              } else {
                registerRef(ancestor);
              }
              ancestor = ancestor.parent;
            }
          }

          // destroy old node
          if (isDef(parentElm$1)) {
            removeVnodes(parentElm$1, [oldVnode], 0, 0);
          } else if (isDef(oldVnode.tag)) {
            invokeDestroyHook(oldVnode);
          }
        }
      }

      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
      return vnode.elm;
    };
  }

  /*  */

  var directives = {
    create: updateDirectives,
    update: updateDirectives,
    destroy: function unbindDirectives(vnode) {
      updateDirectives(vnode, emptyNode);
    }
  };

  function updateDirectives(oldVnode, vnode) {
    if (oldVnode.data.directives || vnode.data.directives) {
      _update(oldVnode, vnode);
    }
  }

  function _update(oldVnode, vnode) {
    var isCreate = oldVnode === emptyNode;
    var isDestroy = vnode === emptyNode;
    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

    var dirsWithInsert = [];
    var dirsWithPostpatch = [];

    var key, oldDir, dir;
    for (key in newDirs) {
      oldDir = oldDirs[key];
      dir = newDirs[key];
      if (!oldDir) {
        // new directive, bind
        callHook$1(dir, 'bind', vnode, oldVnode);
        if (dir.def && dir.def.inserted) {
          dirsWithInsert.push(dir);
        }
      } else {
        // existing directive, update
        dir.oldValue = oldDir.value;
        callHook$1(dir, 'update', vnode, oldVnode);
        if (dir.def && dir.def.componentUpdated) {
          dirsWithPostpatch.push(dir);
        }
      }
    }

    if (dirsWithInsert.length) {
      var callInsert = function callInsert() {
        for (var i = 0; i < dirsWithInsert.length; i++) {
          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
        }
      };
      if (isCreate) {
        mergeVNodeHook(vnode, 'insert', callInsert);
      } else {
        callInsert();
      }
    }

    if (dirsWithPostpatch.length) {
      mergeVNodeHook(vnode, 'postpatch', function () {
        for (var i = 0; i < dirsWithPostpatch.length; i++) {
          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
        }
      });
    }

    if (!isCreate) {
      for (key in oldDirs) {
        if (!newDirs[key]) {
          // no longer present, unbind
          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
        }
      }
    }
  }

  var emptyModifiers = Object.create(null);

  function normalizeDirectives$1(dirs, vm) {
    var res = Object.create(null);
    if (!dirs) {
      // $flow-disable-line
      return res;
    }
    var i, dir;
    for (i = 0; i < dirs.length; i++) {
      dir = dirs[i];
      if (!dir.modifiers) {
        // $flow-disable-line
        dir.modifiers = emptyModifiers;
      }
      res[getRawDirName(dir)] = dir;
      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
    }
    // $flow-disable-line
    return res;
  }

  function getRawDirName(dir) {
    return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
  }

  function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
    var fn = dir.def && dir.def[hook];
    if (fn) {
      try {
        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
      } catch (e) {
        handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
      }
    }
  }

  var baseModules = [ref, directives];

  /*  */

  function updateAttrs(oldVnode, vnode) {
    var opts = vnode.componentOptions;
    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
      return;
    }
    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
      return;
    }
    var key, cur, old;
    var elm = vnode.elm;
    var oldAttrs = oldVnode.data.attrs || {};
    var attrs = vnode.data.attrs || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(attrs.__ob__)) {
      attrs = vnode.data.attrs = extend({}, attrs);
    }

    for (key in attrs) {
      cur = attrs[key];
      old = oldAttrs[key];
      if (old !== cur) {
        setAttr(elm, key, cur);
      }
    }
    // #4391: in IE9, setting type can reset value for input[type=radio]
    // #6666: IE/Edge forces progress value down to 1 before setting a max
    /* istanbul ignore if */
    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
      setAttr(elm, 'value', attrs.value);
    }
    for (key in oldAttrs) {
      if (isUndef(attrs[key])) {
        if (isXlink(key)) {
          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
        } else if (!isEnumeratedAttr(key)) {
          elm.removeAttribute(key);
        }
      }
    }
  }

  function setAttr(el, key, value) {
    if (el.tagName.indexOf('-') > -1) {
      baseSetAttr(el, key, value);
    } else if (isBooleanAttr(key)) {
      // set attribute for blank value
      // e.g. <option disabled>Select one</option>
      if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
      } else {
        // technically allowfullscreen is a boolean attribute for <iframe>,
        // but Flash expects a value of "true" when used on <embed> tag
        value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
        el.setAttribute(key, value);
      }
    } else if (isEnumeratedAttr(key)) {
      el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
    } else if (isXlink(key)) {
      if (isFalsyAttrValue(value)) {
        el.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      baseSetAttr(el, key, value);
    }
  }

  function baseSetAttr(el, key, value) {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // #7138: IE10 & 11 fires input event when setting placeholder on
      // <textarea>... block the first input event and remove the blocker
      // immediately.
      /* istanbul ignore if */
      if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && !el.__ieph) {
        var blocker = function blocker(e) {
          e.stopImmediatePropagation();
          el.removeEventListener('input', blocker);
        };
        el.addEventListener('input', blocker);
        // $flow-disable-line
        el.__ieph = true; /* IE placeholder patched */
      }
      el.setAttribute(key, value);
    }
  }

  var attrs = {
    create: updateAttrs,
    update: updateAttrs

    /*  */

  };function updateClass(oldVnode, vnode) {
    var el = vnode.elm;
    var data = vnode.data;
    var oldData = oldVnode.data;
    if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
      return;
    }

    var cls = genClassForVnode(vnode);

    // handle transition classes
    var transitionClass = el._transitionClasses;
    if (isDef(transitionClass)) {
      cls = concat(cls, stringifyClass(transitionClass));
    }

    // set the class
    if (cls !== el._prevClass) {
      el.setAttribute('class', cls);
      el._prevClass = cls;
    }
  }

  var klass = {
    create: updateClass,
    update: updateClass

    /*  */

  };var validDivisionCharRE = /[\w).+\-_$\]]/;

  function parseFilters(exp) {
    var inSingle = false;
    var inDouble = false;
    var inTemplateString = false;
    var inRegex = false;
    var curly = 0;
    var square = 0;
    var paren = 0;
    var lastFilterIndex = 0;
    var c, prev, i, expression, filters;

    for (i = 0; i < exp.length; i++) {
      prev = c;
      c = exp.charCodeAt(i);
      if (inSingle) {
        if (c === 0x27 && prev !== 0x5C) {
          inSingle = false;
        }
      } else if (inDouble) {
        if (c === 0x22 && prev !== 0x5C) {
          inDouble = false;
        }
      } else if (inTemplateString) {
        if (c === 0x60 && prev !== 0x5C) {
          inTemplateString = false;
        }
      } else if (inRegex) {
        if (c === 0x2f && prev !== 0x5C) {
          inRegex = false;
        }
      } else if (c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
        if (expression === undefined) {
          // first filter, end of expression
          lastFilterIndex = i + 1;
          expression = exp.slice(0, i).trim();
        } else {
          pushFilter();
        }
      } else {
        switch (c) {
          case 0x22:
            inDouble = true;break; // "
          case 0x27:
            inSingle = true;break; // '
          case 0x60:
            inTemplateString = true;break; // `
          case 0x28:
            paren++;break; // (
          case 0x29:
            paren--;break; // )
          case 0x5B:
            square++;break; // [
          case 0x5D:
            square--;break; // ]
          case 0x7B:
            curly++;break; // {
          case 0x7D:
            curly--;break; // }
        }
        if (c === 0x2f) {
          // /
          var j = i - 1;
          var p = void 0;
          // find first non-whitespace prev char
          for (; j >= 0; j--) {
            p = exp.charAt(j);
            if (p !== ' ') {
              break;
            }
          }
          if (!p || !validDivisionCharRE.test(p)) {
            inRegex = true;
          }
        }
      }
    }

    if (expression === undefined) {
      expression = exp.slice(0, i).trim();
    } else if (lastFilterIndex !== 0) {
      pushFilter();
    }

    function pushFilter() {
      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
      lastFilterIndex = i + 1;
    }

    if (filters) {
      for (i = 0; i < filters.length; i++) {
        expression = wrapFilter(expression, filters[i]);
      }
    }

    return expression;
  }

  function wrapFilter(exp, filter) {
    var i = filter.indexOf('(');
    if (i < 0) {
      // _f: resolveFilter
      return "_f(\"" + filter + "\")(" + exp + ")";
    } else {
      var name = filter.slice(0, i);
      var args = filter.slice(i + 1);
      return "_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args);
    }
  }

  /*  */

  function baseWarn(msg) {
    console.error("[Vue compiler]: " + msg);
  }

  function pluckModuleFunction(modules, key) {
    return modules ? modules.map(function (m) {
      return m[key];
    }).filter(function (_) {
      return _;
    }) : [];
  }

  function addProp(el, name, value) {
    (el.props || (el.props = [])).push({ name: name, value: value });
    el.plain = false;
  }

  function addAttr(el, name, value) {
    (el.attrs || (el.attrs = [])).push({ name: name, value: value });
    el.plain = false;
  }

  // add a raw attr (use this in preTransforms)
  function addRawAttr(el, name, value) {
    el.attrsMap[name] = value;
    el.attrsList.push({ name: name, value: value });
  }

  function addDirective(el, name, rawName, value, arg, modifiers) {
    (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
    el.plain = false;
  }

  function addHandler(el, name, value, modifiers, important, warn) {
    modifiers = modifiers || emptyObject;

    // check capture modifier
    if (modifiers.capture) {
      delete modifiers.capture;
      name = '!' + name; // mark the event as captured
    }
    if (modifiers.once) {
      delete modifiers.once;
      name = '~' + name; // mark the event as once
    }
    /* istanbul ignore if */
    if (modifiers.passive) {
      delete modifiers.passive;
      name = '&' + name; // mark the event as passive
    }

    // normalize click.right and click.middle since they don't actually fire
    // this is technically browser-specific, but at least for now browsers are
    // the only target envs that have right/middle clicks.
    if (name === 'click') {
      if (modifiers.right) {
        name = 'contextmenu';
        delete modifiers.right;
      } else if (modifiers.middle) {
        name = 'mouseup';
      }
    }

    var events;
    if (modifiers.native) {
      delete modifiers.native;
      events = el.nativeEvents || (el.nativeEvents = {});
    } else {
      events = el.events || (el.events = {});
    }

    var newHandler = {
      value: value.trim()
    };
    if (modifiers !== emptyObject) {
      newHandler.modifiers = modifiers;
    }

    var handlers = events[name];
    /* istanbul ignore if */
    if (Array.isArray(handlers)) {
      important ? handlers.unshift(newHandler) : handlers.push(newHandler);
    } else if (handlers) {
      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
    } else {
      events[name] = newHandler;
    }

    el.plain = false;
  }

  function getBindingAttr(el, name, getStatic) {
    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
    if (dynamicValue != null) {
      return parseFilters(dynamicValue);
    } else if (getStatic !== false) {
      var staticValue = getAndRemoveAttr(el, name);
      if (staticValue != null) {
        return JSON.stringify(staticValue);
      }
    }
  }

  // note: this only removes the attr from the Array (attrsList) so that it
  // doesn't get processed by processAttrs.
  // By default it does NOT remove it from the map (attrsMap) because the map is
  // needed during codegen.
  function getAndRemoveAttr(el, name, removeFromMap) {
    var val;
    if ((val = el.attrsMap[name]) != null) {
      var list = el.attrsList;
      for (var i = 0, l = list.length; i < l; i++) {
        if (list[i].name === name) {
          list.splice(i, 1);
          break;
        }
      }
    }
    if (removeFromMap) {
      delete el.attrsMap[name];
    }
    return val;
  }

  /*  */

  /**
   * Cross-platform code generation for component v-model
   */
  function genComponentModel(el, value, modifiers) {
    var ref = modifiers || {};
    var number = ref.number;
    var trim = ref.trim;

    var baseValueExpression = '$$v';
    var valueExpression = baseValueExpression;
    if (trim) {
      valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
    }
    if (number) {
      valueExpression = "_n(" + valueExpression + ")";
    }
    var assignment = genAssignmentCode(value, valueExpression);

    el.model = {
      value: "(" + value + ")",
      expression: "\"" + value + "\"",
      callback: "function (" + baseValueExpression + ") {" + assignment + "}"
    };
  }

  /**
   * Cross-platform codegen helper for generating v-model value assignment code.
   */
  function genAssignmentCode(value, assignment) {
    var res = parseModel(value);
    if (res.key === null) {
      return value + "=" + assignment;
    } else {
      return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
    }
  }

  /**
   * Parse a v-model expression into a base path and a final key segment.
   * Handles both dot-path and possible square brackets.
   *
   * Possible cases:
   *
   * - test
   * - test[key]
   * - test[test1[key]]
   * - test["a"][key]
   * - xxx.test[a[a].test1[key]]
   * - test.xxx.a["asa"][test1[key]]
   *
   */

  var len;
  var str;
  var chr;
  var index$1;
  var expressionPos;
  var expressionEndPos;

  function parseModel(val) {
    // Fix https://github.com/vuejs/vue/pull/7730
    // allow v-model="obj.val " (trailing whitespace)
    val = val.trim();
    len = val.length;

    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
      index$1 = val.lastIndexOf('.');
      if (index$1 > -1) {
        return {
          exp: val.slice(0, index$1),
          key: '"' + val.slice(index$1 + 1) + '"'
        };
      } else {
        return {
          exp: val,
          key: null
        };
      }
    }

    str = val;
    index$1 = expressionPos = expressionEndPos = 0;

    while (!eof()) {
      chr = next();
      /* istanbul ignore if */
      if (isStringStart(chr)) {
        parseString(chr);
      } else if (chr === 0x5B) {
        parseBracket(chr);
      }
    }

    return {
      exp: val.slice(0, expressionPos),
      key: val.slice(expressionPos + 1, expressionEndPos)
    };
  }

  function next() {
    return str.charCodeAt(++index$1);
  }

  function eof() {
    return index$1 >= len;
  }

  function isStringStart(chr) {
    return chr === 0x22 || chr === 0x27;
  }

  function parseBracket(chr) {
    var inBracket = 1;
    expressionPos = index$1;
    while (!eof()) {
      chr = next();
      if (isStringStart(chr)) {
        parseString(chr);
        continue;
      }
      if (chr === 0x5B) {
        inBracket++;
      }
      if (chr === 0x5D) {
        inBracket--;
      }
      if (inBracket === 0) {
        expressionEndPos = index$1;
        break;
      }
    }
  }

  function parseString(chr) {
    var stringQuote = chr;
    while (!eof()) {
      chr = next();
      if (chr === stringQuote) {
        break;
      }
    }
  }

  // in some cases, the event used has to be determined at runtime
  // so we used some reserved tokens during compile.
  var RANGE_TOKEN = '__r';
  var CHECKBOX_RADIO_TOKEN = '__c';

  function model(el, dir, _warn) {
    var value = dir.value;
    var modifiers = dir.modifiers;
    var tag = el.tag;
    var type = el.attrsMap.type;

    if (el.component) {
      genComponentModel(el, value, modifiers);
      // component v-model doesn't need extra runtime
      return false;
    } else if (tag === 'select') {
      genSelect(el, value, modifiers);
    } else if (tag === 'input' && type === 'checkbox') {
      genCheckboxModel(el, value, modifiers);
    } else if (tag === 'input' && type === 'radio') {
      genRadioModel(el, value, modifiers);
    } else if (tag === 'input' || tag === 'textarea') {
      genDefaultModel(el, value, modifiers);
    } else if (!config.isReservedTag(tag)) {
      genComponentModel(el, value, modifiers);
      // component v-model doesn't need extra runtime
      return false;
    } else {}

    // ensure runtime directive metadata
    return true;
  }

  function genCheckboxModel(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
    addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
    addHandler(el, 'change', "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + genAssignmentCode(value, '$$a.concat([$$v])') + ")}" + "else{$$i>-1&&(" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + ")}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
  }

  function genRadioModel(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var valueBinding = getBindingAttr(el, 'value') || 'null';
    valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
    addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
  }

  function genSelect(el, value, modifiers) {
    var number = modifiers && modifiers.number;
    var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";

    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
    var code = "var $$selectedVal = " + selectedVal + ";";
    code = code + " " + genAssignmentCode(value, assignment);
    addHandler(el, 'change', code, null, true);
  }

  function genDefaultModel(el, value, modifiers) {
    var type = el.attrsMap.type;

    // warn if v-bind:value conflicts with v-model
    // except for inputs with v-bind:type
    

    var ref = modifiers || {};
    var lazy = ref.lazy;
    var number = ref.number;
    var trim = ref.trim;
    var needCompositionGuard = !lazy && type !== 'range';
    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';

    var valueExpression = '$event.target.value';
    if (trim) {
      valueExpression = "$event.target.value.trim()";
    }
    if (number) {
      valueExpression = "_n(" + valueExpression + ")";
    }

    var code = genAssignmentCode(value, valueExpression);
    if (needCompositionGuard) {
      code = "if($event.target.composing)return;" + code;
    }

    addProp(el, 'value', "(" + value + ")");
    addHandler(el, event, code, null, true);
    if (trim || number) {
      addHandler(el, 'blur', '$forceUpdate()');
    }
  }

  /*  */

  // normalize v-model event tokens that can only be determined at runtime.
  // it's important to place the event as the first in the array because
  // the whole point is ensuring the v-model callback gets called before
  // user-attached handlers.
  function normalizeEvents(on) {
    /* istanbul ignore if */
    if (isDef(on[RANGE_TOKEN])) {
      // IE input[type=range] only supports `change` event
      var event = isIE ? 'change' : 'input';
      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
      delete on[RANGE_TOKEN];
    }
    // This was originally intended to fix #4521 but no longer necessary
    // after 2.5. Keeping it for backwards compat with generated code from < 2.4
    /* istanbul ignore if */
    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
      delete on[CHECKBOX_RADIO_TOKEN];
    }
  }

  var target$1;

  function createOnceHandler(handler, event, capture) {
    var _target = target$1; // save current target element in closure
    return function onceHandler() {
      var res = handler.apply(null, arguments);
      if (res !== null) {
        remove$2(event, onceHandler, capture, _target);
      }
    };
  }

  function add$1(event, handler, once$$1, capture, passive) {
    handler = withMacroTask(handler);
    if (once$$1) {
      handler = createOnceHandler(handler, event, capture);
    }
    target$1.addEventListener(event, handler, supportsPassive ? { capture: capture, passive: passive } : capture);
  }

  function remove$2(event, handler, capture, _target) {
    (_target || target$1).removeEventListener(event, handler._withTask || handler, capture);
  }

  function updateDOMListeners(oldVnode, vnode) {
    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
      return;
    }
    var on = vnode.data.on || {};
    var oldOn = oldVnode.data.on || {};
    target$1 = vnode.elm;
    normalizeEvents(on);
    updateListeners(on, oldOn, add$1, remove$2, vnode.context);
    target$1 = undefined;
  }

  var events = {
    create: updateDOMListeners,
    update: updateDOMListeners

    /*  */

  };function updateDOMProps(oldVnode, vnode) {
    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
      return;
    }
    var key, cur;
    var elm = vnode.elm;
    var oldProps = oldVnode.data.domProps || {};
    var props = vnode.data.domProps || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(props.__ob__)) {
      props = vnode.data.domProps = extend({}, props);
    }

    for (key in oldProps) {
      if (isUndef(props[key])) {
        elm[key] = '';
      }
    }
    for (key in props) {
      cur = props[key];
      // ignore children if the node has textContent or innerHTML,
      // as these will throw away existing DOM nodes and cause removal errors
      // on subsequent patches (#3360)
      if (key === 'textContent' || key === 'innerHTML') {
        if (vnode.children) {
          vnode.children.length = 0;
        }
        if (cur === oldProps[key]) {
          continue;
        }
        // #6601 work around Chrome version <= 55 bug where single textNode
        // replaced by innerHTML/textContent retains its parentNode property
        if (elm.childNodes.length === 1) {
          elm.removeChild(elm.childNodes[0]);
        }
      }

      if (key === 'value') {
        // store value as _value as well since
        // non-string values will be stringified
        elm._value = cur;
        // avoid resetting cursor position when value is the same
        var strCur = isUndef(cur) ? '' : String(cur);
        if (shouldUpdateValue(elm, strCur)) {
          elm.value = strCur;
        }
      } else {
        elm[key] = cur;
      }
    }
  }

  // check platforms/web/util/attrs.js acceptValue


  function shouldUpdateValue(elm, checkVal) {
    return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));
  }

  function isNotInFocusAndDirty(elm, checkVal) {
    // return true when textbox (.number and .trim) loses focus and its value is
    // not equal to the updated value
    var notInFocus = true;
    // #6157
    // work around IE bug when accessing document.activeElement in an iframe
    try {
      notInFocus = document.activeElement !== elm;
    } catch (e) {}
    return notInFocus && elm.value !== checkVal;
  }

  function isDirtyWithModifiers(elm, newVal) {
    var value = elm.value;
    var modifiers = elm._vModifiers; // injected by v-model runtime
    if (isDef(modifiers)) {
      if (modifiers.lazy) {
        // inputs with lazy should only be updated when not in focus
        return false;
      }
      if (modifiers.number) {
        return toNumber(value) !== toNumber(newVal);
      }
      if (modifiers.trim) {
        return value.trim() !== newVal.trim();
      }
    }
    return value !== newVal;
  }

  var domProps = {
    create: updateDOMProps,
    update: updateDOMProps

    /*  */

  };var parseStyleText = cached(function (cssText) {
    var res = {};
    var listDelimiter = /;(?![^(]*\))/g;
    var propertyDelimiter = /:(.+)/;
    cssText.split(listDelimiter).forEach(function (item) {
      if (item) {
        var tmp = item.split(propertyDelimiter);
        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return res;
  });

  // merge static and dynamic style data on the same vnode
  function normalizeStyleData(data) {
    var style = normalizeStyleBinding(data.style);
    // static style is pre-processed into an object during compilation
    // and is always a fresh object, so it's safe to merge into it
    return data.staticStyle ? extend(data.staticStyle, style) : style;
  }

  // normalize possible array / string values into Object
  function normalizeStyleBinding(bindingStyle) {
    if (Array.isArray(bindingStyle)) {
      return toObject(bindingStyle);
    }
    if (typeof bindingStyle === 'string') {
      return parseStyleText(bindingStyle);
    }
    return bindingStyle;
  }

  /**
   * parent component style should be after child's
   * so that parent component's style could override it
   */
  function getStyle(vnode, checkChild) {
    var res = {};
    var styleData;

    if (checkChild) {
      var childNode = vnode;
      while (childNode.componentInstance) {
        childNode = childNode.componentInstance._vnode;
        if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {
          extend(res, styleData);
        }
      }
    }

    if (styleData = normalizeStyleData(vnode.data)) {
      extend(res, styleData);
    }

    var parentNode = vnode;
    while (parentNode = parentNode.parent) {
      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
        extend(res, styleData);
      }
    }
    return res;
  }

  /*  */

  var cssVarRE = /^--/;
  var importantRE = /\s*!important$/;
  var setProp = function setProp(el, name, val) {
    /* istanbul ignore if */
    if (cssVarRE.test(name)) {
      el.style.setProperty(name, val);
    } else if (importantRE.test(val)) {
      el.style.setProperty(name, val.replace(importantRE, ''), 'important');
    } else {
      var normalizedName = normalize(name);
      if (Array.isArray(val)) {
        // Support values array created by autoprefixer, e.g.
        // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
        // Set them one by one, and the browser will only set those it can recognize
        for (var i = 0, len = val.length; i < len; i++) {
          el.style[normalizedName] = val[i];
        }
      } else {
        el.style[normalizedName] = val;
      }
    }
  };

  var vendorNames = ['Webkit', 'Moz', 'ms'];

  var emptyStyle;
  var normalize = cached(function (prop) {
    emptyStyle = emptyStyle || document.createElement('div').style;
    prop = camelize(prop);
    if (prop !== 'filter' && prop in emptyStyle) {
      return prop;
    }
    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
    for (var i = 0; i < vendorNames.length; i++) {
      var name = vendorNames[i] + capName;
      if (name in emptyStyle) {
        return name;
      }
    }
  });

  function updateStyle(oldVnode, vnode) {
    var data = vnode.data;
    var oldData = oldVnode.data;

    if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
      return;
    }

    var cur, name;
    var el = vnode.elm;
    var oldStaticStyle = oldData.staticStyle;
    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

    // if static style exists, stylebinding already merged into it when doing normalizeStyleData
    var oldStyle = oldStaticStyle || oldStyleBinding;

    var style = normalizeStyleBinding(vnode.data.style) || {};

    // store normalized style under a different key for next diff
    // make sure to clone it if it's reactive, since the user likely wants
    // to mutate it.
    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;

    var newStyle = getStyle(vnode, true);

    for (name in oldStyle) {
      if (isUndef(newStyle[name])) {
        setProp(el, name, '');
      }
    }
    for (name in newStyle) {
      cur = newStyle[name];
      if (cur !== oldStyle[name]) {
        // ie9 setting to null has no effect, must use empty string
        setProp(el, name, cur == null ? '' : cur);
      }
    }
  }

  var style = {
    create: updateStyle,
    update: updateStyle

    /*  */

    /**
     * Add class with compatibility for SVG since classList is not supported on
     * SVG elements in IE
     */
  };function addClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return;
    }

    /* istanbul ignore else */
    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(/\s+/).forEach(function (c) {
          return el.classList.add(c);
        });
      } else {
        el.classList.add(cls);
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      if (cur.indexOf(' ' + cls + ' ') < 0) {
        el.setAttribute('class', (cur + cls).trim());
      }
    }
  }

  /**
   * Remove class with compatibility for SVG since classList is not supported on
   * SVG elements in IE
   */
  function removeClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
      return;
    }

    /* istanbul ignore else */
    if (el.classList) {
      if (cls.indexOf(' ') > -1) {
        cls.split(/\s+/).forEach(function (c) {
          return el.classList.remove(c);
        });
      } else {
        el.classList.remove(cls);
      }
      if (!el.classList.length) {
        el.removeAttribute('class');
      }
    } else {
      var cur = " " + (el.getAttribute('class') || '') + " ";
      var tar = ' ' + cls + ' ';
      while (cur.indexOf(tar) >= 0) {
        cur = cur.replace(tar, ' ');
      }
      cur = cur.trim();
      if (cur) {
        el.setAttribute('class', cur);
      } else {
        el.removeAttribute('class');
      }
    }
  }

  /*  */

  function resolveTransition(def) {
    if (!def) {
      return;
    }
    /* istanbul ignore else */
    if ((typeof def === 'undefined' ? 'undefined' : _typeof(def)) === 'object') {
      var res = {};
      if (def.css !== false) {
        extend(res, autoCssTransition(def.name || 'v'));
      }
      extend(res, def);
      return res;
    } else if (typeof def === 'string') {
      return autoCssTransition(def);
    }
  }

  var autoCssTransition = cached(function (name) {
    return {
      enterClass: name + "-enter",
      enterToClass: name + "-enter-to",
      enterActiveClass: name + "-enter-active",
      leaveClass: name + "-leave",
      leaveToClass: name + "-leave-to",
      leaveActiveClass: name + "-leave-active"
    };
  });

  var hasTransition = inBrowser && !isIE9;
  var TRANSITION = 'transition';
  var ANIMATION = 'animation';

  // Transition property/event sniffing
  var transitionProp = 'transition';
  var transitionEndEvent = 'transitionend';
  var animationProp = 'animation';
  var animationEndEvent = 'animationend';
  if (hasTransition) {
    /* istanbul ignore if */
    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
      transitionProp = 'WebkitTransition';
      transitionEndEvent = 'webkitTransitionEnd';
    }
    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
      animationProp = 'WebkitAnimation';
      animationEndEvent = 'webkitAnimationEnd';
    }
  }

  // binding to window is necessary to make hot reload work in IE in strict mode
  var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : /* istanbul ignore next */function (fn) {
    return fn();
  };

  function nextFrame(fn) {
    raf(function () {
      raf(fn);
    });
  }

  function addTransitionClass(el, cls) {
    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
    if (transitionClasses.indexOf(cls) < 0) {
      transitionClasses.push(cls);
      addClass(el, cls);
    }
  }

  function removeTransitionClass(el, cls) {
    if (el._transitionClasses) {
      remove(el._transitionClasses, cls);
    }
    removeClass(el, cls);
  }

  function whenTransitionEnds(el, expectedType, cb) {
    var ref = getTransitionInfo(el, expectedType);
    var type = ref.type;
    var timeout = ref.timeout;
    var propCount = ref.propCount;
    if (!type) {
      return cb();
    }
    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
    var ended = 0;
    var end = function end() {
      el.removeEventListener(event, onEnd);
      cb();
    };
    var onEnd = function onEnd(e) {
      if (e.target === el) {
        if (++ended >= propCount) {
          end();
        }
      }
    };
    setTimeout(function () {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(event, onEnd);
  }

  var transformRE = /\b(transform|all)(,|$)/;

  function getTransitionInfo(el, expectedType) {
    var styles = window.getComputedStyle(el);
    var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
    var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    var animationDelays = styles[animationProp + 'Delay'].split(', ');
    var animationDurations = styles[animationProp + 'Duration'].split(', ');
    var animationTimeout = getTimeout(animationDelays, animationDurations);

    var type;
    var timeout = 0;
    var propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
    return {
      type: type,
      timeout: timeout,
      propCount: propCount,
      hasTransform: hasTransform
    };
  }

  function getTimeout(delays, durations) {
    /* istanbul ignore next */
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }

    return Math.max.apply(null, durations.map(function (d, i) {
      return toMs(d) + toMs(delays[i]);
    }));
  }

  function toMs(s) {
    return Number(s.slice(0, -1)) * 1000;
  }

  /*  */

  function enter(vnode, toggleDisplay) {
    var el = vnode.elm;

    // call leave callback now
    if (isDef(el._leaveCb)) {
      el._leaveCb.cancelled = true;
      el._leaveCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data)) {
      return;
    }

    /* istanbul ignore if */
    if (isDef(el._enterCb) || el.nodeType !== 1) {
      return;
    }

    var css = data.css;
    var type = data.type;
    var enterClass = data.enterClass;
    var enterToClass = data.enterToClass;
    var enterActiveClass = data.enterActiveClass;
    var appearClass = data.appearClass;
    var appearToClass = data.appearToClass;
    var appearActiveClass = data.appearActiveClass;
    var beforeEnter = data.beforeEnter;
    var enter = data.enter;
    var afterEnter = data.afterEnter;
    var enterCancelled = data.enterCancelled;
    var beforeAppear = data.beforeAppear;
    var appear = data.appear;
    var afterAppear = data.afterAppear;
    var appearCancelled = data.appearCancelled;
    var duration = data.duration;

    // activeInstance will always be the <transition> component managing this
    // transition. One edge case to check is when the <transition> is placed
    // as the root node of a child component. In that case we need to check
    // <transition>'s parent for appear check.
    var context = activeInstance;
    var transitionNode = activeInstance.$vnode;
    while (transitionNode && transitionNode.parent) {
      transitionNode = transitionNode.parent;
      context = transitionNode.context;
    }

    var isAppear = !context._isMounted || !vnode.isRootInsert;

    if (isAppear && !appear && appear !== '') {
      return;
    }

    var startClass = isAppear && appearClass ? appearClass : enterClass;
    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
    var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(enterHook);

    var cb = el._enterCb = once(function () {
      if (expectsCSS) {
        removeTransitionClass(el, toClass);
        removeTransitionClass(el, activeClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, startClass);
        }
        enterCancelledHook && enterCancelledHook(el);
      } else {
        afterEnterHook && afterEnterHook(el);
      }
      el._enterCb = null;
    });

    if (!vnode.data.show) {
      // remove pending leave element on enter by injecting an insert hook
      mergeVNodeHook(vnode, 'insert', function () {
        var parent = el.parentNode;
        var pendingNode = parent && parent._pending && parent._pending[vnode.key];
        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
          pendingNode.elm._leaveCb();
        }
        enterHook && enterHook(el, cb);
      });
    }

    // start enter transition
    beforeEnterHook && beforeEnterHook(el);
    if (expectsCSS) {
      addTransitionClass(el, startClass);
      addTransitionClass(el, activeClass);
      nextFrame(function () {
        removeTransitionClass(el, startClass);
        if (!cb.cancelled) {
          addTransitionClass(el, toClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitEnterDuration)) {
              setTimeout(cb, explicitEnterDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }

    if (vnode.data.show) {
      toggleDisplay && toggleDisplay();
      enterHook && enterHook(el, cb);
    }

    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }

  function leave(vnode, rm) {
    var el = vnode.elm;

    // call enter callback now
    if (isDef(el._enterCb)) {
      el._enterCb.cancelled = true;
      el._enterCb();
    }

    var data = resolveTransition(vnode.data.transition);
    if (isUndef(data) || el.nodeType !== 1) {
      return rm();
    }

    /* istanbul ignore if */
    if (isDef(el._leaveCb)) {
      return;
    }

    var css = data.css;
    var type = data.type;
    var leaveClass = data.leaveClass;
    var leaveToClass = data.leaveToClass;
    var leaveActiveClass = data.leaveActiveClass;
    var beforeLeave = data.beforeLeave;
    var leave = data.leave;
    var afterLeave = data.afterLeave;
    var leaveCancelled = data.leaveCancelled;
    var delayLeave = data.delayLeave;
    var duration = data.duration;

    var expectsCSS = css !== false && !isIE9;
    var userWantsControl = getHookArgumentsLength(leave);

    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

    var cb = el._leaveCb = once(function () {
      if (el.parentNode && el.parentNode._pending) {
        el.parentNode._pending[vnode.key] = null;
      }
      if (expectsCSS) {
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
      }
      if (cb.cancelled) {
        if (expectsCSS) {
          removeTransitionClass(el, leaveClass);
        }
        leaveCancelled && leaveCancelled(el);
      } else {
        rm();
        afterLeave && afterLeave(el);
      }
      el._leaveCb = null;
    });

    if (delayLeave) {
      delayLeave(performLeave);
    } else {
      performLeave();
    }

    function performLeave() {
      // the delayed leave may have already been cancelled
      if (cb.cancelled) {
        return;
      }
      // record leaving element
      if (!vnode.data.show) {
        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
      }
      beforeLeave && beforeLeave(el);
      if (expectsCSS) {
        addTransitionClass(el, leaveClass);
        addTransitionClass(el, leaveActiveClass);
        nextFrame(function () {
          removeTransitionClass(el, leaveClass);
          if (!cb.cancelled) {
            addTransitionClass(el, leaveToClass);
            if (!userWantsControl) {
              if (isValidDuration(explicitLeaveDuration)) {
                setTimeout(cb, explicitLeaveDuration);
              } else {
                whenTransitionEnds(el, type, cb);
              }
            }
          }
        });
      }
      leave && leave(el, cb);
      if (!expectsCSS && !userWantsControl) {
        cb();
      }
    }
  }

  function isValidDuration(val) {
    return typeof val === 'number' && !isNaN(val);
  }

  /**
   * Normalize a transition hook's argument length. The hook may be:
   * - a merged hook (invoker) with the original in .fns
   * - a wrapped component method (check ._length)
   * - a plain function (.length)
   */
  function getHookArgumentsLength(fn) {
    if (isUndef(fn)) {
      return false;
    }
    var invokerFns = fn.fns;
    if (isDef(invokerFns)) {
      // invoker
      return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
    } else {
      return (fn._length || fn.length) > 1;
    }
  }

  function _enter(_, vnode) {
    if (vnode.data.show !== true) {
      enter(vnode);
    }
  }

  var transition = inBrowser ? {
    create: _enter,
    activate: _enter,
    remove: function remove$$1(vnode, rm) {
      /* istanbul ignore else */
      if (vnode.data.show !== true) {
        leave(vnode, rm);
      } else {
        rm();
      }
    }
  } : {};

  var platformModules = [attrs, klass, events, domProps, style, transition];

  /*  */

  // the directive module should be applied last, after all
  // built-in modules have been applied.
  var modules = platformModules.concat(baseModules);

  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

  /**
   * Not type checking this file because flow doesn't like attaching
   * properties to Elements.
   */

  /* istanbul ignore if */
  if (isIE9) {
    // http://www.matts411.com/post/internet-explorer-9-oninput/
    document.addEventListener('selectionchange', function () {
      var el = document.activeElement;
      if (el && el.vmodel) {
        trigger(el, 'input');
      }
    });
  }

  var directive = {
    inserted: function inserted(el, binding, vnode, oldVnode) {
      if (vnode.tag === 'select') {
        // #6903
        if (oldVnode.elm && !oldVnode.elm._vOptions) {
          mergeVNodeHook(vnode, 'postpatch', function () {
            directive.componentUpdated(el, binding, vnode);
          });
        } else {
          setSelected(el, binding, vnode.context);
        }
        el._vOptions = [].map.call(el.options, getValue);
      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
        el._vModifiers = binding.modifiers;
        if (!binding.modifiers.lazy) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
          // Safari < 10.2 & UIWebView doesn't fire compositionend when
          // switching focus before confirming composition choice
          // this also fixes the issue where some browsers e.g. iOS Chrome
          // fires "change" instead of "input" on autocomplete.
          el.addEventListener('change', onCompositionEnd);
          /* istanbul ignore if */
          if (isIE9) {
            el.vmodel = true;
          }
        }
      }
    },

    componentUpdated: function componentUpdated(el, binding, vnode) {
      if (vnode.tag === 'select') {
        setSelected(el, binding, vnode.context);
        // in case the options rendered by v-for have changed,
        // it's possible that the value is out-of-sync with the rendered options.
        // detect such cases and filter out values that no longer has a matching
        // option in the DOM.
        var prevOptions = el._vOptions;
        var curOptions = el._vOptions = [].map.call(el.options, getValue);
        if (curOptions.some(function (o, i) {
          return !looseEqual(o, prevOptions[i]);
        })) {
          // trigger change event if
          // no matching option found for at least one value
          var needReset = el.multiple ? binding.value.some(function (v) {
            return hasNoMatchingOption(v, curOptions);
          }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
          if (needReset) {
            trigger(el, 'change');
          }
        }
      }
    }
  };

  function setSelected(el, binding, vm) {
    actuallySetSelected(el, binding, vm);
    /* istanbul ignore if */
    if (isIE || isEdge) {
      setTimeout(function () {
        actuallySetSelected(el, binding, vm);
      }, 0);
    }
  }

  function actuallySetSelected(el, binding, vm) {
    var value = binding.value;
    var isMultiple = el.multiple;
    if (isMultiple && !Array.isArray(value)) {
      return;
    }
    var selected, option;
    for (var i = 0, l = el.options.length; i < l; i++) {
      option = el.options[i];
      if (isMultiple) {
        selected = looseIndexOf(value, getValue(option)) > -1;
        if (option.selected !== selected) {
          option.selected = selected;
        }
      } else {
        if (looseEqual(getValue(option), value)) {
          if (el.selectedIndex !== i) {
            el.selectedIndex = i;
          }
          return;
        }
      }
    }
    if (!isMultiple) {
      el.selectedIndex = -1;
    }
  }

  function hasNoMatchingOption(value, options) {
    return options.every(function (o) {
      return !looseEqual(o, value);
    });
  }

  function getValue(option) {
    return '_value' in option ? option._value : option.value;
  }

  function onCompositionStart(e) {
    e.target.composing = true;
  }

  function onCompositionEnd(e) {
    // prevent triggering an input event for no reason
    if (!e.target.composing) {
      return;
    }
    e.target.composing = false;
    trigger(e.target, 'input');
  }

  function trigger(el, type) {
    var e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
  }

  /*  */

  // recursively search for possible transition defined inside the component root
  function locateNode(vnode) {
    return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
  }

  var show = {
    bind: function bind(el, ref, vnode) {
      var value = ref.value;

      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
      if (value && transition$$1) {
        vnode.data.show = true;
        enter(vnode, function () {
          el.style.display = originalDisplay;
        });
      } else {
        el.style.display = value ? originalDisplay : 'none';
      }
    },

    update: function update(el, ref, vnode) {
      var value = ref.value;
      var oldValue = ref.oldValue;

      /* istanbul ignore if */
      if (!value === !oldValue) {
        return;
      }
      vnode = locateNode(vnode);
      var transition$$1 = vnode.data && vnode.data.transition;
      if (transition$$1) {
        vnode.data.show = true;
        if (value) {
          enter(vnode, function () {
            el.style.display = el.__vOriginalDisplay;
          });
        } else {
          leave(vnode, function () {
            el.style.display = 'none';
          });
        }
      } else {
        el.style.display = value ? el.__vOriginalDisplay : 'none';
      }
    },

    unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
      if (!isDestroy) {
        el.style.display = el.__vOriginalDisplay;
      }
    }
  };

  var platformDirectives = {
    model: directive,
    show: show

    /*  */

    // Provides transition support for a single element/component.
    // supports transition mode (out-in / in-out)

  };var transitionProps = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [Number, String, Object]
  };

  // in case the child is also an abstract component, e.g. <keep-alive>
  // we want to recursively retrieve the real component to be rendered
  function getRealChild(vnode) {
    var compOptions = vnode && vnode.componentOptions;
    if (compOptions && compOptions.Ctor.options.abstract) {
      return getRealChild(getFirstComponentChild(compOptions.children));
    } else {
      return vnode;
    }
  }

  function extractTransitionData(comp) {
    var data = {};
    var options = comp.$options;
    // props
    for (var key in options.propsData) {
      data[key] = comp[key];
    }
    // events.
    // extract listeners and pass them directly to the transition methods
    var listeners = options._parentListeners;
    for (var key$1 in listeners) {
      data[camelize(key$1)] = listeners[key$1];
    }
    return data;
  }

  function placeholder(h, rawChild) {
    if (/\d-keep-alive$/.test(rawChild.tag)) {
      return h('keep-alive', {
        props: rawChild.componentOptions.propsData
      });
    }
  }

  function hasParentTransition(vnode) {
    while (vnode = vnode.parent) {
      if (vnode.data.transition) {
        return true;
      }
    }
  }

  function isSameChild(child, oldChild) {
    return oldChild.key === child.key && oldChild.tag === child.tag;
  }

  var Transition = {
    name: 'transition',
    props: transitionProps,
    abstract: true,

    render: function render(h) {
      var this$1 = this;

      var children = this.$slots.default;
      if (!children) {
        return;
      }

      // filter out text nodes (possible whitespaces)
      children = children.filter(function (c) {
        return c.tag || isAsyncPlaceholder(c);
      });
      /* istanbul ignore if */
      if (!children.length) {
        return;
      }

      var mode = this.mode;

      var rawChild = children[0];

      // if this is a component root node and the component's
      // parent container node also has transition, skip.
      if (hasParentTransition(this.$vnode)) {
        return rawChild;
      }

      // apply transition data to child
      // use getRealChild() to ignore abstract components e.g. keep-alive
      var child = getRealChild(rawChild);
      /* istanbul ignore if */
      if (!child) {
        return rawChild;
      }

      if (this._leaving) {
        return placeholder(h, rawChild);
      }

      // ensure a key that is unique to the vnode type and to this transition
      // component instance. This key will be used to remove pending leaving nodes
      // during entering.
      var id = "__transition-" + this._uid + "-";
      child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
      var oldRawChild = this._vnode;
      var oldChild = getRealChild(oldRawChild);

      // mark v-show
      // so that the transition module can hand over the control to the directive
      if (child.data.directives && child.data.directives.some(function (d) {
        return d.name === 'show';
      })) {
        child.data.show = true;
      }

      if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
        // replace old child transition data with fresh one
        // important for dynamic transitions!
        var oldData = oldChild.data.transition = extend({}, data);
        // handle transition mode
        if (mode === 'out-in') {
          // return placeholder node and queue update when leave finishes
          this._leaving = true;
          mergeVNodeHook(oldData, 'afterLeave', function () {
            this$1._leaving = false;
            this$1.$forceUpdate();
          });
          return placeholder(h, rawChild);
        } else if (mode === 'in-out') {
          if (isAsyncPlaceholder(child)) {
            return oldRawChild;
          }
          var delayedLeave;
          var performLeave = function performLeave() {
            delayedLeave();
          };
          mergeVNodeHook(data, 'afterEnter', performLeave);
          mergeVNodeHook(data, 'enterCancelled', performLeave);
          mergeVNodeHook(oldData, 'delayLeave', function (leave) {
            delayedLeave = leave;
          });
        }
      }

      return rawChild;
    }

    /*  */

    // Provides transition support for list items.
    // supports move transitions using the FLIP technique.

    // Because the vdom's children update algorithm is "unstable" - i.e.
    // it doesn't guarantee the relative positioning of removed elements,
    // we force transition-group to update its children into two passes:
    // in the first pass, we remove all nodes that need to be removed,
    // triggering their leaving transition; in the second pass, we insert/move
    // into the final desired state. This way in the second pass removed
    // nodes will remain where they should be.

  };var props = extend({
    tag: String,
    moveClass: String
  }, transitionProps);

  delete props.mode;

  var TransitionGroup = {
    props: props,

    render: function render(h) {
      var tag = this.tag || this.$vnode.data.tag || 'span';
      var map = Object.create(null);
      var prevChildren = this.prevChildren = this.children;
      var rawChildren = this.$slots.default || [];
      var children = this.children = [];
      var transitionData = extractTransitionData(this);

      for (var i = 0; i < rawChildren.length; i++) {
        var c = rawChildren[i];
        if (c.tag) {
          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
            children.push(c);
            map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
          } else {}
        }
      }

      if (prevChildren) {
        var kept = [];
        var removed = [];
        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
          var c$1 = prevChildren[i$1];
          c$1.data.transition = transitionData;
          c$1.data.pos = c$1.elm.getBoundingClientRect();
          if (map[c$1.key]) {
            kept.push(c$1);
          } else {
            removed.push(c$1);
          }
        }
        this.kept = h(tag, null, kept);
        this.removed = removed;
      }

      return h(tag, null, children);
    },

    beforeUpdate: function beforeUpdate() {
      // force removing pass
      this.__patch__(this._vnode, this.kept, false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
      );
      this._vnode = this.kept;
    },

    updated: function updated() {
      var children = this.prevChildren;
      var moveClass = this.moveClass || (this.name || 'v') + '-move';
      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
        return;
      }

      // we divide the work into three loops to avoid mixing DOM reads and writes
      // in each iteration - which helps prevent layout thrashing.
      children.forEach(callPendingCbs);
      children.forEach(recordPosition);
      children.forEach(applyTranslation);

      // force reflow to put everything in position
      // assign to this to avoid being removed in tree-shaking
      // $flow-disable-line
      this._reflow = document.body.offsetHeight;

      children.forEach(function (c) {
        if (c.data.moved) {
          var el = c.elm;
          var s = el.style;
          addTransitionClass(el, moveClass);
          s.transform = s.WebkitTransform = s.transitionDuration = '';
          el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
            if (!e || /transform$/.test(e.propertyName)) {
              el.removeEventListener(transitionEndEvent, cb);
              el._moveCb = null;
              removeTransitionClass(el, moveClass);
            }
          });
        }
      });
    },

    methods: {
      hasMove: function hasMove(el, moveClass) {
        /* istanbul ignore if */
        if (!hasTransition) {
          return false;
        }
        /* istanbul ignore if */
        if (this._hasMove) {
          return this._hasMove;
        }
        // Detect whether an element with the move class applied has
        // CSS transitions. Since the element may be inside an entering
        // transition at this very moment, we make a clone of it and remove
        // all other transition classes applied to ensure only the move class
        // is applied.
        var clone = el.cloneNode();
        if (el._transitionClasses) {
          el._transitionClasses.forEach(function (cls) {
            removeClass(clone, cls);
          });
        }
        addClass(clone, moveClass);
        clone.style.display = 'none';
        this.$el.appendChild(clone);
        var info = getTransitionInfo(clone);
        this.$el.removeChild(clone);
        return this._hasMove = info.hasTransform;
      }
    }
  };

  function callPendingCbs(c) {
    /* istanbul ignore if */
    if (c.elm._moveCb) {
      c.elm._moveCb();
    }
    /* istanbul ignore if */
    if (c.elm._enterCb) {
      c.elm._enterCb();
    }
  }

  function recordPosition(c) {
    c.data.newPos = c.elm.getBoundingClientRect();
  }

  function applyTranslation(c) {
    var oldPos = c.data.pos;
    var newPos = c.data.newPos;
    var dx = oldPos.left - newPos.left;
    var dy = oldPos.top - newPos.top;
    if (dx || dy) {
      c.data.moved = true;
      var s = c.elm.style;
      s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
      s.transitionDuration = '0s';
    }
  }

  var platformComponents = {
    Transition: Transition,
    TransitionGroup: TransitionGroup

    /*  */

    // install platform specific utils
  };Vue.config.mustUseProp = mustUseProp;
  Vue.config.isReservedTag = isReservedTag;
  Vue.config.isReservedAttr = isReservedAttr;
  Vue.config.getTagNamespace = getTagNamespace;
  Vue.config.isUnknownElement = isUnknownElement;

  // install platform runtime directives & components
  extend(Vue.options.directives, platformDirectives);
  extend(Vue.options.components, platformComponents);

  // install platform patch function
  Vue.prototype.__patch__ = inBrowser ? patch : noop;

  // public mount method
  Vue.prototype.$mount = function (el, hydrating) {
    el = el && inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating);
  };

  // devtools global hook
  /* istanbul ignore next */
  if (inBrowser) {
    setTimeout(function () {
      if (config.devtools) {
        if (devtools) {
          devtools.emit('init', Vue);
        } else {}
      }
    }, 0);
  }

  /*  */

  var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
  var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

  var buildRegex = cached(function (delimiters) {
    var open = delimiters[0].replace(regexEscapeRE, '\\$&');
    var close = delimiters[1].replace(regexEscapeRE, '\\$&');
    return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
  });

  function parseText(text, delimiters) {
    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
    if (!tagRE.test(text)) {
      return;
    }
    var tokens = [];
    var rawTokens = [];
    var lastIndex = tagRE.lastIndex = 0;
    var match, index, tokenValue;
    while (match = tagRE.exec(text)) {
      index = match.index;
      // push text token
      if (index > lastIndex) {
        rawTokens.push(tokenValue = text.slice(lastIndex, index));
        tokens.push(JSON.stringify(tokenValue));
      }
      // tag token
      var exp = parseFilters(match[1].trim());
      tokens.push("_s(" + exp + ")");
      rawTokens.push({ '@binding': exp });
      lastIndex = index + match[0].length;
    }
    if (lastIndex < text.length) {
      rawTokens.push(tokenValue = text.slice(lastIndex));
      tokens.push(JSON.stringify(tokenValue));
    }
    return {
      expression: tokens.join('+'),
      tokens: rawTokens
    };
  }

  /*  */

  function transformNode(el, options) {
    var warn = options.warn || baseWarn;
    var staticClass = getAndRemoveAttr(el, 'class');
    
    if (staticClass) {
      el.staticClass = JSON.stringify(staticClass);
    }
    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
    if (classBinding) {
      el.classBinding = classBinding;
    }
  }

  function genData(el) {
    var data = '';
    if (el.staticClass) {
      data += "staticClass:" + el.staticClass + ",";
    }
    if (el.classBinding) {
      data += "class:" + el.classBinding + ",";
    }
    return data;
  }

  var klass$1 = {
    staticKeys: ['staticClass'],
    transformNode: transformNode,
    genData: genData

    /*  */

  };function transformNode$1(el, options) {
    var warn = options.warn || baseWarn;
    var staticStyle = getAndRemoveAttr(el, 'style');
    if (staticStyle) {
      /* istanbul ignore if */
      
      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
    }

    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
    if (styleBinding) {
      el.styleBinding = styleBinding;
    }
  }

  function genData$1(el) {
    var data = '';
    if (el.staticStyle) {
      data += "staticStyle:" + el.staticStyle + ",";
    }
    if (el.styleBinding) {
      data += "style:(" + el.styleBinding + "),";
    }
    return data;
  }

  var style$1 = {
    staticKeys: ['staticStyle'],
    transformNode: transformNode$1,
    genData: genData$1

    /*  */

  };var decoder;

  var he = {
    decode: function decode(html) {
      decoder = decoder || document.createElement('div');
      decoder.innerHTML = html;
      return decoder.textContent;
    }

    /*  */

  };var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');

  // Elements that you can, intentionally, leave open
  // (and which close themselves)
  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');

  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');

  /**
   * Not type-checking this file because it's mostly vendor code.
   */

  /*!
   * HTML Parser By John Resig (ejohn.org)
   * Modified by Juriy "kangax" Zaytsev
   * Original code by Erik Arvidsson, Mozilla Public License
   * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
   */

  // Regular Expressions for parsing tags and attributes
  var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
  // could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
  // but for Vue templates we can enforce a simple charset
  var ncname = '[a-zA-Z_][\\w\\-\\.]*';
  var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
  var startTagOpen = new RegExp("^<" + qnameCapture);
  var startTagClose = /^\s*(\/?)>/;
  var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
  var doctype = /^<!DOCTYPE [^>]+>/i;
  // #7298: escape - to avoid being pased as HTML comment when inlined in page
  var comment = /^<!\--/;
  var conditionalComment = /^<!\[/;

  var IS_REGEX_CAPTURING_BROKEN = false;
  'x'.replace(/x(.)?/g, function (m, g) {
    IS_REGEX_CAPTURING_BROKEN = g === '';
  });

  // Special Elements (can contain anything)
  var isPlainTextElement = makeMap('script,style,textarea', true);
  var reCache = {};

  var decodingMap = {
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&amp;': '&',
    '&#10;': '\n',
    '&#9;': '\t'
  };
  var encodedAttr = /&(?:lt|gt|quot|amp);/g;
  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;

  // #5992
  var isIgnoreNewlineTag = makeMap('pre,textarea', true);
  var shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {
    return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
  };

  function decodeAttr(value, shouldDecodeNewlines) {
    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
    return value.replace(re, function (match) {
      return decodingMap[match];
    });
  }

  function parseHTML(html, options) {
    var stack = [];
    var expectHTML = options.expectHTML;
    var isUnaryTag$$1 = options.isUnaryTag || no;
    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
    var index = 0;
    var last, lastTag;
    while (html) {
      last = html;
      // Make sure we're not in a plaintext content element like script/style
      if (!lastTag || !isPlainTextElement(lastTag)) {
        var textEnd = html.indexOf('<');
        if (textEnd === 0) {
          // Comment:
          if (comment.test(html)) {
            var commentEnd = html.indexOf('-->');

            if (commentEnd >= 0) {
              if (options.shouldKeepComment) {
                options.comment(html.substring(4, commentEnd));
              }
              advance(commentEnd + 3);
              continue;
            }
          }

          // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
          if (conditionalComment.test(html)) {
            var conditionalEnd = html.indexOf(']>');

            if (conditionalEnd >= 0) {
              advance(conditionalEnd + 2);
              continue;
            }
          }

          // Doctype:
          var doctypeMatch = html.match(doctype);
          if (doctypeMatch) {
            advance(doctypeMatch[0].length);
            continue;
          }

          // End tag:
          var endTagMatch = html.match(endTag);
          if (endTagMatch) {
            var curIndex = index;
            advance(endTagMatch[0].length);
            parseEndTag(endTagMatch[1], curIndex, index);
            continue;
          }

          // Start tag:
          var startTagMatch = parseStartTag();
          if (startTagMatch) {
            handleStartTag(startTagMatch);
            if (shouldIgnoreFirstNewline(lastTag, html)) {
              advance(1);
            }
            continue;
          }
        }

        var text = void 0,
            rest = void 0,
            next = void 0;
        if (textEnd >= 0) {
          rest = html.slice(textEnd);
          while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
            // < in plain text, be forgiving and treat it as text
            next = rest.indexOf('<', 1);
            if (next < 0) {
              break;
            }
            textEnd += next;
            rest = html.slice(textEnd);
          }
          text = html.substring(0, textEnd);
          advance(textEnd);
        }

        if (textEnd < 0) {
          text = html;
          html = '';
        }

        if (options.chars && text) {
          options.chars(text);
        }
      } else {
        var endTagLength = 0;
        var stackedTag = lastTag.toLowerCase();
        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
          endTagLength = endTag.length;
          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
            text = text.replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
          }
          if (shouldIgnoreFirstNewline(stackedTag, text)) {
            text = text.slice(1);
          }
          if (options.chars) {
            options.chars(text);
          }
          return '';
        });
        index += html.length - rest$1.length;
        html = rest$1;
        parseEndTag(stackedTag, index - endTagLength, index);
      }

      if (html === last) {
        options.chars && options.chars(html);
        break;
      }
    }

    // Clean up any remaining tags
    parseEndTag();

    function advance(n) {
      index += n;
      html = html.substring(n);
    }

    function parseStartTag() {
      var start = html.match(startTagOpen);
      if (start) {
        var match = {
          tagName: start[1],
          attrs: [],
          start: index
        };
        advance(start[0].length);
        var end, attr;
        while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
          advance(attr[0].length);
          match.attrs.push(attr);
        }
        if (end) {
          match.unarySlash = end[1];
          advance(end[0].length);
          match.end = index;
          return match;
        }
      }
    }

    function handleStartTag(match) {
      var tagName = match.tagName;
      var unarySlash = match.unarySlash;

      if (expectHTML) {
        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
          parseEndTag(lastTag);
        }
        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
          parseEndTag(tagName);
        }
      }

      var unary = isUnaryTag$$1(tagName) || !!unarySlash;

      var l = match.attrs.length;
      var attrs = new Array(l);
      for (var i = 0; i < l; i++) {
        var args = match.attrs[i];
        // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
        if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
          if (args[3] === '') {
            delete args[3];
          }
          if (args[4] === '') {
            delete args[4];
          }
          if (args[5] === '') {
            delete args[5];
          }
        }
        var value = args[3] || args[4] || args[5] || '';
        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
        attrs[i] = {
          name: args[1],
          value: decodeAttr(value, shouldDecodeNewlines)
        };
      }

      if (!unary) {
        stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
        lastTag = tagName;
      }

      if (options.start) {
        options.start(tagName, attrs, unary, match.start, match.end);
      }
    }

    function parseEndTag(tagName, start, end) {
      var pos, lowerCasedTagName;
      if (start == null) {
        start = index;
      }
      if (end == null) {
        end = index;
      }

      if (tagName) {
        lowerCasedTagName = tagName.toLowerCase();
      }

      // Find the closest opened tag of the same type
      if (tagName) {
        for (pos = stack.length - 1; pos >= 0; pos--) {
          if (stack[pos].lowerCasedTag === lowerCasedTagName) {
            break;
          }
        }
      } else {
        // If no tag name is provided, clean shop
        pos = 0;
      }

      if (pos >= 0) {
        // Close all the open elements, up the stack
        for (var i = stack.length - 1; i >= pos; i--) {
          if (options.end) {
            options.end(stack[i].tag, start, end);
          }
        }

        // Remove the open elements from the stack
        stack.length = pos;
        lastTag = pos && stack[pos - 1].tag;
      } else if (lowerCasedTagName === 'br') {
        if (options.start) {
          options.start(tagName, [], true, start, end);
        }
      } else if (lowerCasedTagName === 'p') {
        if (options.start) {
          options.start(tagName, [], false, start, end);
        }
        if (options.end) {
          options.end(tagName, start, end);
        }
      }
    }
  }

  /*  */

  var onRE = /^@|^v-on:/;
  var dirRE = /^v-|^@|^:/;
  var forAliasRE = /([^]*?)\s+(?:in|of)\s+([^]*)/;
  var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
  var stripParensRE = /^\(|\)$/g;

  var argRE = /:(.*)$/;
  var bindRE = /^:|^v-bind:/;
  var modifierRE = /\.[^.]+/g;

  var decodeHTMLCached = cached(he.decode);

  // configurable state
  var warn$2;
  var delimiters;
  var transforms;
  var preTransforms;
  var postTransforms;
  var platformIsPreTag;
  var platformMustUseProp;
  var platformGetTagNamespace;

  function createASTElement(tag, attrs, parent) {
    return {
      type: 1,
      tag: tag,
      attrsList: attrs,
      attrsMap: makeAttrsMap(attrs),
      parent: parent,
      children: []
    };
  }

  /**
   * Convert HTML string to AST.
   */
  function parse(template, options) {
    warn$2 = options.warn || baseWarn;

    platformIsPreTag = options.isPreTag || no;
    platformMustUseProp = options.mustUseProp || no;
    platformGetTagNamespace = options.getTagNamespace || no;

    transforms = pluckModuleFunction(options.modules, 'transformNode');
    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

    delimiters = options.delimiters;

    var stack = [];
    var preserveWhitespace = options.preserveWhitespace !== false;
    var root;
    var currentParent;
    var inVPre = false;
    var inPre = false;

    function closeElement(element) {
      // check pre state
      if (element.pre) {
        inVPre = false;
      }
      if (platformIsPreTag(element.tag)) {
        inPre = false;
      }
      // apply post-transforms
      for (var i = 0; i < postTransforms.length; i++) {
        postTransforms[i](element, options);
      }
    }

    parseHTML(template, {
      warn: warn$2,
      expectHTML: options.expectHTML,
      isUnaryTag: options.isUnaryTag,
      canBeLeftOpenTag: options.canBeLeftOpenTag,
      shouldDecodeNewlines: options.shouldDecodeNewlines,
      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
      shouldKeepComment: options.comments,
      start: function start(tag, attrs, unary) {
        // check namespace.
        // inherit parent ns if there is one
        var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);

        // handle IE svg bug
        /* istanbul ignore if */
        if (isIE && ns === 'svg') {
          attrs = guardIESVGBug(attrs);
        }

        var element = createASTElement(tag, attrs, currentParent);
        if (ns) {
          element.ns = ns;
        }

        if (isForbiddenTag(element) && !isServerRendering()) {
          element.forbidden = true;
        }

        // apply pre-transforms
        for (var i = 0; i < preTransforms.length; i++) {
          element = preTransforms[i](element, options) || element;
        }

        if (!inVPre) {
          processPre(element);
          if (element.pre) {
            inVPre = true;
          }
        }
        if (platformIsPreTag(element.tag)) {
          inPre = true;
        }
        if (inVPre) {
          processRawAttrs(element);
        } else if (!element.processed) {
          // structural directives
          processFor(element);
          processIf(element);
          processOnce(element);
          // element-scope stuff
          processElement(element, options);
        }

        // tree management
        if (!root) {
          root = element;
        } else if (!stack.length) {
          // allow root elements with v-if, v-else-if and v-else
          if (root.if && (element.elseif || element.else)) {
            addIfCondition(root, {
              exp: element.elseif,
              block: element
            });
          } else {}
        }
        if (currentParent && !element.forbidden) {
          if (element.elseif || element.else) {
            processIfConditions(element, currentParent);
          } else if (element.slotScope) {
            // scoped slot
            currentParent.plain = false;
            var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
          } else {
            currentParent.children.push(element);
            element.parent = currentParent;
          }
        }
        if (!unary) {
          currentParent = element;
          stack.push(element);
        } else {
          closeElement(element);
        }
      },

      end: function end() {
        // remove trailing whitespace
        var element = stack[stack.length - 1];
        var lastNode = element.children[element.children.length - 1];
        if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
          element.children.pop();
        }
        // pop stack
        stack.length -= 1;
        currentParent = stack[stack.length - 1];
        closeElement(element);
      },

      chars: function chars(text) {
        if (!currentParent) {
          return;
        }
        // IE textarea placeholder bug
        /* istanbul ignore if */
        if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
          return;
        }
        var children = currentParent.children;
        text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
        // only preserve whitespace if its not right after a starting tag
        : preserveWhitespace && children.length ? ' ' : '';
        if (text) {
          var res;
          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
            children.push({
              type: 2,
              expression: res.expression,
              tokens: res.tokens,
              text: text
            });
          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
            children.push({
              type: 3,
              text: text
            });
          }
        }
      },
      comment: function comment(text) {
        currentParent.children.push({
          type: 3,
          text: text,
          isComment: true
        });
      }
    });
    return root;
  }

  function processPre(el) {
    if (getAndRemoveAttr(el, 'v-pre') != null) {
      el.pre = true;
    }
  }

  function processRawAttrs(el) {
    var l = el.attrsList.length;
    if (l) {
      var attrs = el.attrs = new Array(l);
      for (var i = 0; i < l; i++) {
        attrs[i] = {
          name: el.attrsList[i].name,
          value: JSON.stringify(el.attrsList[i].value)
        };
      }
    } else if (!el.pre) {
      // non root node in pre blocks with no attributes
      el.plain = true;
    }
  }

  function processElement(element, options) {
    processKey(element);

    // determine whether this is a plain element after
    // removing structural attributes
    element.plain = !element.key && !element.attrsList.length;

    processRef(element);
    processSlot(element);
    processComponent(element);
    for (var i = 0; i < transforms.length; i++) {
      element = transforms[i](element, options) || element;
    }
    processAttrs(element);
  }

  function processKey(el) {
    var exp = getBindingAttr(el, 'key');
    if (exp) {
      el.key = exp;
    }
  }

  function processRef(el) {
    var ref = getBindingAttr(el, 'ref');
    if (ref) {
      el.ref = ref;
      el.refInFor = checkInFor(el);
    }
  }

  function processFor(el) {
    var exp;
    if (exp = getAndRemoveAttr(el, 'v-for')) {
      var res = parseFor(exp);
      if (res) {
        extend(el, res);
      } else {}
    }
  }

  function parseFor(exp) {
    var inMatch = exp.match(forAliasRE);
    if (!inMatch) {
      return;
    }
    var res = {};
    res.for = inMatch[2].trim();
    var alias = inMatch[1].trim().replace(stripParensRE, '');
    var iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
      res.alias = alias.replace(forIteratorRE, '');
      res.iterator1 = iteratorMatch[1].trim();
      if (iteratorMatch[2]) {
        res.iterator2 = iteratorMatch[2].trim();
      }
    } else {
      res.alias = alias;
    }
    return res;
  }

  function processIf(el) {
    var exp = getAndRemoveAttr(el, 'v-if');
    if (exp) {
      el.if = exp;
      addIfCondition(el, {
        exp: exp,
        block: el
      });
    } else {
      if (getAndRemoveAttr(el, 'v-else') != null) {
        el.else = true;
      }
      var elseif = getAndRemoveAttr(el, 'v-else-if');
      if (elseif) {
        el.elseif = elseif;
      }
    }
  }

  function processIfConditions(el, parent) {
    var prev = findPrevElement(parent.children);
    if (prev && prev.if) {
      addIfCondition(prev, {
        exp: el.elseif,
        block: el
      });
    } else {}
  }

  function findPrevElement(children) {
    var i = children.length;
    while (i--) {
      if (children[i].type === 1) {
        return children[i];
      } else {
        children.pop();
      }
    }
  }

  function addIfCondition(el, condition) {
    if (!el.ifConditions) {
      el.ifConditions = [];
    }
    el.ifConditions.push(condition);
  }

  function processOnce(el) {
    var once$$1 = getAndRemoveAttr(el, 'v-once');
    if (once$$1 != null) {
      el.once = true;
    }
  }

  function processSlot(el) {
    if (el.tag === 'slot') {
      el.slotName = getBindingAttr(el, 'name');
    } else {
      var slotScope;
      if (el.tag === 'template') {
        slotScope = getAndRemoveAttr(el, 'scope');
        el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
      } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
        el.slotScope = slotScope;
      }
      var slotTarget = getBindingAttr(el, 'slot');
      if (slotTarget) {
        el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
        // preserve slot as an attribute for native shadow DOM compat
        // only for non-scoped slots.
        if (el.tag !== 'template' && !el.slotScope) {
          addAttr(el, 'slot', slotTarget);
        }
      }
    }
  }

  function processComponent(el) {
    var binding;
    if (binding = getBindingAttr(el, 'is')) {
      el.component = binding;
    }
    if (getAndRemoveAttr(el, 'inline-template') != null) {
      el.inlineTemplate = true;
    }
  }

  function processAttrs(el) {
    var list = el.attrsList;
    var i, l, name, rawName, value, modifiers, isProp;
    for (i = 0, l = list.length; i < l; i++) {
      name = rawName = list[i].name;
      value = list[i].value;
      if (dirRE.test(name)) {
        // mark element as dynamic
        el.hasBindings = true;
        // modifiers
        modifiers = parseModifiers(name);
        if (modifiers) {
          name = name.replace(modifierRE, '');
        }
        if (bindRE.test(name)) {
          // v-bind
          name = name.replace(bindRE, '');
          value = parseFilters(value);
          isProp = false;
          if (modifiers) {
            if (modifiers.prop) {
              isProp = true;
              name = camelize(name);
              if (name === 'innerHtml') {
                name = 'innerHTML';
              }
            }
            if (modifiers.camel) {
              name = camelize(name);
            }
            if (modifiers.sync) {
              addHandler(el, "update:" + camelize(name), genAssignmentCode(value, "$event"));
            }
          }
          if (isProp || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
            addProp(el, name, value);
          } else {
            addAttr(el, name, value);
          }
        } else if (onRE.test(name)) {
          // v-on
          name = name.replace(onRE, '');
          addHandler(el, name, value, modifiers, false, warn$2);
        } else {
          // normal directives
          name = name.replace(dirRE, '');
          // parse arg
          var argMatch = name.match(argRE);
          var arg = argMatch && argMatch[1];
          if (arg) {
            name = name.slice(0, -(arg.length + 1));
          }
          addDirective(el, name, rawName, value, arg, modifiers);
        }
      } else {
        // literal attribute
        
        addAttr(el, name, JSON.stringify(value));
        // #6887 firefox doesn't update muted state if set via attribute
        // even immediately after element creation
        if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, 'true');
        }
      }
    }
  }

  function checkInFor(el) {
    var parent = el;
    while (parent) {
      if (parent.for !== undefined) {
        return true;
      }
      parent = parent.parent;
    }
    return false;
  }

  function parseModifiers(name) {
    var match = name.match(modifierRE);
    if (match) {
      var ret = {};
      match.forEach(function (m) {
        ret[m.slice(1)] = true;
      });
      return ret;
    }
  }

  function makeAttrsMap(attrs) {
    var map = {};
    for (var i = 0, l = attrs.length; i < l; i++) {
      map[attrs[i].name] = attrs[i].value;
    }
    return map;
  }

  // for script (e.g. type="x/template") or style, do not decode content
  function isTextTag(el) {
    return el.tag === 'script' || el.tag === 'style';
  }

  function isForbiddenTag(el) {
    return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
  }

  var ieNSBug = /^xmlns:NS\d+/;
  var ieNSPrefix = /^NS\d+:/;

  /* istanbul ignore next */
  function guardIESVGBug(attrs) {
    var res = [];
    for (var i = 0; i < attrs.length; i++) {
      var attr = attrs[i];
      if (!ieNSBug.test(attr.name)) {
        attr.name = attr.name.replace(ieNSPrefix, '');
        res.push(attr);
      }
    }
    return res;
  }

  /*  */

  /**
   * Expand input[v-model] with dyanmic type bindings into v-if-else chains
   * Turn this:
   *   <input v-model="data[type]" :type="type">
   * into this:
   *   <input v-if="type === 'checkbox'" type="checkbox" v-model="data[type]">
   *   <input v-else-if="type === 'radio'" type="radio" v-model="data[type]">
   *   <input v-else :type="type" v-model="data[type]">
   */

  function preTransformNode(el, options) {
    if (el.tag === 'input') {
      var map = el.attrsMap;
      if (!map['v-model']) {
        return;
      }

      var typeBinding;
      if (map[':type'] || map['v-bind:type']) {
        typeBinding = getBindingAttr(el, 'type');
      }
      if (!map.type && !typeBinding && map['v-bind']) {
        typeBinding = "(" + map['v-bind'] + ").type";
      }

      if (typeBinding) {
        var ifCondition = getAndRemoveAttr(el, 'v-if', true);
        var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
        // 1. checkbox
        var branch0 = cloneASTElement(el);
        // process for on the main node
        processFor(branch0);
        addRawAttr(branch0, 'type', 'checkbox');
        processElement(branch0, options);
        branch0.processed = true; // prevent it from double-processed
        branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
        addIfCondition(branch0, {
          exp: branch0.if,
          block: branch0
        });
        // 2. add radio else-if condition
        var branch1 = cloneASTElement(el);
        getAndRemoveAttr(branch1, 'v-for', true);
        addRawAttr(branch1, 'type', 'radio');
        processElement(branch1, options);
        addIfCondition(branch0, {
          exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
          block: branch1
        });
        // 3. other
        var branch2 = cloneASTElement(el);
        getAndRemoveAttr(branch2, 'v-for', true);
        addRawAttr(branch2, ':type', typeBinding);
        processElement(branch2, options);
        addIfCondition(branch0, {
          exp: ifCondition,
          block: branch2
        });

        if (hasElse) {
          branch0.else = true;
        } else if (elseIfCondition) {
          branch0.elseif = elseIfCondition;
        }

        return branch0;
      }
    }
  }

  function cloneASTElement(el) {
    return createASTElement(el.tag, el.attrsList.slice(), el.parent);
  }

  var model$2 = {
    preTransformNode: preTransformNode
  };

  var modules$1 = [klass$1, style$1, model$2];

  /*  */

  function text(el, dir) {
    if (dir.value) {
      addProp(el, 'textContent', "_s(" + dir.value + ")");
    }
  }

  /*  */

  function html(el, dir) {
    if (dir.value) {
      addProp(el, 'innerHTML', "_s(" + dir.value + ")");
    }
  }

  var directives$1 = {
    model: model,
    text: text,
    html: html

    /*  */

  };var baseOptions = {
    expectHTML: true,
    modules: modules$1,
    directives: directives$1,
    isPreTag: isPreTag,
    isUnaryTag: isUnaryTag,
    mustUseProp: mustUseProp,
    canBeLeftOpenTag: canBeLeftOpenTag,
    isReservedTag: isReservedTag,
    getTagNamespace: getTagNamespace,
    staticKeys: genStaticKeys(modules$1)
  };

  /*  */

  var isStaticKey;
  var isPlatformReservedTag;

  var genStaticKeysCached = cached(genStaticKeys$1);

  /**
   * Goal of the optimizer: walk the generated template AST tree
   * and detect sub-trees that are purely static, i.e. parts of
   * the DOM that never needs to change.
   *
   * Once we detect these sub-trees, we can:
   *
   * 1. Hoist them into constants, so that we no longer need to
   *    create fresh nodes for them on each re-render;
   * 2. Completely skip them in the patching process.
   */
  function optimize(root, options) {
    if (!root) {
      return;
    }
    isStaticKey = genStaticKeysCached(options.staticKeys || '');
    isPlatformReservedTag = options.isReservedTag || no;
    // first pass: mark all non-static nodes.
    markStatic$1(root);
    // second pass: mark static roots.
    markStaticRoots(root, false);
  }

  function genStaticKeys$1(keys) {
    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));
  }

  function markStatic$1(node) {
    node.static = isStatic(node);
    if (node.type === 1) {
      // do not make component slot content static. this avoids
      // 1. components not able to mutate slot nodes
      // 2. static slot content fails for hot-reloading
      if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
        return;
      }
      for (var i = 0, l = node.children.length; i < l; i++) {
        var child = node.children[i];
        markStatic$1(child);
        if (!child.static) {
          node.static = false;
        }
      }
      if (node.ifConditions) {
        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
          var block = node.ifConditions[i$1].block;
          markStatic$1(block);
          if (!block.static) {
            node.static = false;
          }
        }
      }
    }
  }

  function markStaticRoots(node, isInFor) {
    if (node.type === 1) {
      if (node.static || node.once) {
        node.staticInFor = isInFor;
      }
      // For a node to qualify as a static root, it should have children that
      // are not just static text. Otherwise the cost of hoisting out will
      // outweigh the benefits and it's better off to just always render it fresh.
      if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
        node.staticRoot = true;
        return;
      } else {
        node.staticRoot = false;
      }
      if (node.children) {
        for (var i = 0, l = node.children.length; i < l; i++) {
          markStaticRoots(node.children[i], isInFor || !!node.for);
        }
      }
      if (node.ifConditions) {
        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
          markStaticRoots(node.ifConditions[i$1].block, isInFor);
        }
      }
    }
  }

  function isStatic(node) {
    if (node.type === 2) {
      // expression
      return false;
    }
    if (node.type === 3) {
      // text
      return true;
    }
    return !!(node.pre || !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
  }

  function isDirectChildOfTemplateFor(node) {
    while (node.parent) {
      node = node.parent;
      if (node.tag !== 'template') {
        return false;
      }
      if (node.for) {
        return true;
      }
    }
    return false;
  }

  /*  */

  var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
  var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;

  // KeyboardEvent.keyCode aliases
  var keyCodes = {
    esc: 27,
    tab: 9,
    enter: 13,
    space: 32,
    up: 38,
    left: 37,
    right: 39,
    down: 40,
    'delete': [8, 46]
  };

  // KeyboardEvent.key aliases
  var keyNames = {
    esc: 'Escape',
    tab: 'Tab',
    enter: 'Enter',
    space: ' ',
    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
    up: ['Up', 'ArrowUp'],
    left: ['Left', 'ArrowLeft'],
    right: ['Right', 'ArrowRight'],
    down: ['Down', 'ArrowDown'],
    'delete': ['Backspace', 'Delete']
  };

  // #4868: modifiers that prevent the execution of the listener
  // need to explicitly return null so that we can determine whether to remove
  // the listener for .once
  var genGuard = function genGuard(condition) {
    return "if(" + condition + ")return null;";
  };

  var modifierCode = {
    stop: '$event.stopPropagation();',
    prevent: '$event.preventDefault();',
    self: genGuard("$event.target !== $event.currentTarget"),
    ctrl: genGuard("!$event.ctrlKey"),
    shift: genGuard("!$event.shiftKey"),
    alt: genGuard("!$event.altKey"),
    meta: genGuard("!$event.metaKey"),
    left: genGuard("'button' in $event && $event.button !== 0"),
    middle: genGuard("'button' in $event && $event.button !== 1"),
    right: genGuard("'button' in $event && $event.button !== 2")
  };

  function genHandlers(events, isNative, warn) {
    var res = isNative ? 'nativeOn:{' : 'on:{';
    for (var name in events) {
      res += "\"" + name + "\":" + genHandler(name, events[name]) + ",";
    }
    return res.slice(0, -1) + '}';
  }

  function genHandler(name, handler) {
    if (!handler) {
      return 'function(){}';
    }

    if (Array.isArray(handler)) {
      return "[" + handler.map(function (handler) {
        return genHandler(name, handler);
      }).join(',') + "]";
    }

    var isMethodPath = simplePathRE.test(handler.value);
    var isFunctionExpression = fnExpRE.test(handler.value);

    if (!handler.modifiers) {
      if (isMethodPath || isFunctionExpression) {
        return handler.value;
      }
      /* istanbul ignore if */
      return "function($event){" + handler.value + "}"; // inline statement
    } else {
      var code = '';
      var genModifierCode = '';
      var keys = [];
      for (var key in handler.modifiers) {
        if (modifierCode[key]) {
          genModifierCode += modifierCode[key];
          // left/right
          if (keyCodes[key]) {
            keys.push(key);
          }
        } else if (key === 'exact') {
          var modifiers = handler.modifiers;
          genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
            return !modifiers[keyModifier];
          }).map(function (keyModifier) {
            return "$event." + keyModifier + "Key";
          }).join('||'));
        } else {
          keys.push(key);
        }
      }
      if (keys.length) {
        code += genKeyFilter(keys);
      }
      // Make sure modifiers like prevent and stop get executed after key filtering
      if (genModifierCode) {
        code += genModifierCode;
      }
      var handlerCode = isMethodPath ? "return " + handler.value + "($event)" : isFunctionExpression ? "return (" + handler.value + ")($event)" : handler.value;
      /* istanbul ignore if */
      return "function($event){" + code + handlerCode + "}";
    }
  }

  function genKeyFilter(keys) {
    return "if(!('button' in $event)&&" + keys.map(genFilterCode).join('&&') + ")return null;";
  }

  function genFilterCode(key) {
    var keyVal = parseInt(key, 10);
    if (keyVal) {
      return "$event.keyCode!==" + keyVal;
    }
    var keyCode = keyCodes[key];
    var keyName = keyNames[key];
    return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(keyCode) + "," + "$event.key," + "" + JSON.stringify(keyName) + ")";
  }

  /*  */

  function on(el, dir) {
    el.wrapListeners = function (code) {
      return "_g(" + code + "," + dir.value + ")";
    };
  }

  /*  */

  function bind$1(el, dir) {
    el.wrapData = function (code) {
      return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
    };
  }

  /*  */

  var baseDirectives = {
    on: on,
    bind: bind$1,
    cloak: noop

    /*  */

  };var CodegenState = function CodegenState(options) {
    this.options = options;
    this.warn = options.warn || baseWarn;
    this.transforms = pluckModuleFunction(options.modules, 'transformCode');
    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
    this.directives = extend(extend({}, baseDirectives), options.directives);
    var isReservedTag = options.isReservedTag || no;
    this.maybeComponent = function (el) {
      return !isReservedTag(el.tag);
    };
    this.onceId = 0;
    this.staticRenderFns = [];
  };

  function generate(ast, options) {
    var state = new CodegenState(options);
    var code = ast ? genElement(ast, state) : '_c("div")';
    return {
      render: "with(this){return " + code + "}",
      staticRenderFns: state.staticRenderFns
    };
  }

  function genElement(el, state) {
    if (el.staticRoot && !el.staticProcessed) {
      return genStatic(el, state);
    } else if (el.once && !el.onceProcessed) {
      return genOnce(el, state);
    } else if (el.for && !el.forProcessed) {
      return genFor(el, state);
    } else if (el.if && !el.ifProcessed) {
      return genIf(el, state);
    } else if (el.tag === 'template' && !el.slotTarget) {
      return genChildren(el, state) || 'void 0';
    } else if (el.tag === 'slot') {
      return genSlot(el, state);
    } else {
      // component or element
      var code;
      if (el.component) {
        code = genComponent(el.component, el, state);
      } else {
        var data = el.plain ? undefined : genData$2(el, state);

        var children = el.inlineTemplate ? null : genChildren(el, state, true);
        code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
      }
      // module transforms
      for (var i = 0; i < state.transforms.length; i++) {
        code = state.transforms[i](el, code);
      }
      return code;
    }
  }

  // hoist static sub-trees out
  function genStatic(el, state) {
    el.staticProcessed = true;
    state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
    return "_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")";
  }

  // v-once
  function genOnce(el, state) {
    el.onceProcessed = true;
    if (el.if && !el.ifProcessed) {
      return genIf(el, state);
    } else if (el.staticInFor) {
      var key = '';
      var parent = el.parent;
      while (parent) {
        if (parent.for) {
          key = parent.key;
          break;
        }
        parent = parent.parent;
      }
      if (!key) {
        return genElement(el, state);
      }
      return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
    } else {
      return genStatic(el, state);
    }
  }

  function genIf(el, state, altGen, altEmpty) {
    el.ifProcessed = true; // avoid recursion
    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
  }

  function genIfConditions(conditions, state, altGen, altEmpty) {
    if (!conditions.length) {
      return altEmpty || '_e()';
    }

    var condition = conditions.shift();
    if (condition.exp) {
      return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
    } else {
      return "" + genTernaryExp(condition.block);
    }

    // v-if with v-once should generate code like (a)?_m(0):_m(1)
    function genTernaryExp(el) {
      return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
    }
  }

  function genFor(el, state, altGen, altHelper) {
    var exp = el.for;
    var alias = el.alias;
    var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
    var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

    el.forProcessed = true; // avoid recursion
    return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
  }

  function genData$2(el, state) {
    var data = '{';

    // directives first.
    // directives may mutate the el's other properties before they are generated.
    var dirs = genDirectives(el, state);
    if (dirs) {
      data += dirs + ',';
    }

    // key
    if (el.key) {
      data += "key:" + el.key + ",";
    }
    // ref
    if (el.ref) {
      data += "ref:" + el.ref + ",";
    }
    if (el.refInFor) {
      data += "refInFor:true,";
    }
    // pre
    if (el.pre) {
      data += "pre:true,";
    }
    // record original tag name for components using "is" attribute
    if (el.component) {
      data += "tag:\"" + el.tag + "\",";
    }
    // module data generation functions
    for (var i = 0; i < state.dataGenFns.length; i++) {
      data += state.dataGenFns[i](el);
    }
    // attributes
    if (el.attrs) {
      data += "attrs:{" + genProps(el.attrs) + "},";
    }
    // DOM props
    if (el.props) {
      data += "domProps:{" + genProps(el.props) + "},";
    }
    // event handlers
    if (el.events) {
      data += genHandlers(el.events, false, state.warn) + ",";
    }
    if (el.nativeEvents) {
      data += genHandlers(el.nativeEvents, true, state.warn) + ",";
    }
    // slot target
    // only for non-scoped slots
    if (el.slotTarget && !el.slotScope) {
      data += "slot:" + el.slotTarget + ",";
    }
    // scoped slots
    if (el.scopedSlots) {
      data += genScopedSlots(el.scopedSlots, state) + ",";
    }
    // component v-model
    if (el.model) {
      data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
    }
    // inline-template
    if (el.inlineTemplate) {
      var inlineTemplate = genInlineTemplate(el, state);
      if (inlineTemplate) {
        data += inlineTemplate + ",";
      }
    }
    data = data.replace(/,$/, '') + '}';
    // v-bind data wrap
    if (el.wrapData) {
      data = el.wrapData(data);
    }
    // v-on data wrap
    if (el.wrapListeners) {
      data = el.wrapListeners(data);
    }
    return data;
  }

  function genDirectives(el, state) {
    var dirs = el.directives;
    if (!dirs) {
      return;
    }
    var res = 'directives:[';
    var hasRuntime = false;
    var i, l, dir, needRuntime;
    for (i = 0, l = dirs.length; i < l; i++) {
      dir = dirs[i];
      needRuntime = true;
      var gen = state.directives[dir.name];
      if (gen) {
        // compile-time directive that manipulates AST.
        // returns true if it also needs a runtime counterpart.
        needRuntime = !!gen(el, dir, state.warn);
      }
      if (needRuntime) {
        hasRuntime = true;
        res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:\"" + dir.arg + "\"" : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
      }
    }
    if (hasRuntime) {
      return res.slice(0, -1) + ']';
    }
  }

  function genInlineTemplate(el, state) {
    var ast = el.children[0];
    if (ast.type === 1) {
      var inlineRenderFns = generate(ast, state.options);
      return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
        return "function(){" + code + "}";
      }).join(',') + "]}";
    }
  }

  function genScopedSlots(slots, state) {
    return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
      return genScopedSlot(key, slots[key], state);
    }).join(',') + "])";
  }

  function genScopedSlot(key, el, state) {
    if (el.for && !el.forProcessed) {
      return genForScopedSlot(key, el, state);
    }
    var fn = "function(" + String(el.slotScope) + "){" + "return " + (el.tag === 'template' ? el.if ? el.if + "?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}";
    return "{key:" + key + ",fn:" + fn + "}";
  }

  function genForScopedSlot(key, el, state) {
    var exp = el.for;
    var alias = el.alias;
    var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
    var iterator2 = el.iterator2 ? "," + el.iterator2 : '';
    el.forProcessed = true; // avoid recursion
    return "_l((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + genScopedSlot(key, el, state) + '})';
  }

  function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
    var children = el.children;
    if (children.length) {
      var el$1 = children[0];
      // optimize single v-for
      if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
        return (altGenElement || genElement)(el$1, state);
      }
      var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
      var gen = altGenNode || genNode;
      return "[" + children.map(function (c) {
        return gen(c, state);
      }).join(',') + "]" + (normalizationType ? "," + normalizationType : '');
    }
  }

  // determine the normalization needed for the children array.
  // 0: no normalization needed
  // 1: simple normalization needed (possible 1-level deep nested array)
  // 2: full normalization needed
  function getNormalizationType(children, maybeComponent) {
    var res = 0;
    for (var i = 0; i < children.length; i++) {
      var el = children[i];
      if (el.type !== 1) {
        continue;
      }
      if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
        return needsNormalization(c.block);
      })) {
        res = 2;
        break;
      }
      if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
        return maybeComponent(c.block);
      })) {
        res = 1;
      }
    }
    return res;
  }

  function needsNormalization(el) {
    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
  }

  function genNode(node, state) {
    if (node.type === 1) {
      return genElement(node, state);
    }if (node.type === 3 && node.isComment) {
      return genComment(node);
    } else {
      return genText(node);
    }
  }

  function genText(text) {
    return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
  }

  function genComment(comment) {
    return "_e(" + JSON.stringify(comment.text) + ")";
  }

  function genSlot(el, state) {
    var slotName = el.slotName || '"default"';
    var children = genChildren(el, state);
    var res = "_t(" + slotName + (children ? "," + children : '');
    var attrs = el.attrs && "{" + el.attrs.map(function (a) {
      return camelize(a.name) + ":" + a.value;
    }).join(',') + "}";
    var bind$$1 = el.attrsMap['v-bind'];
    if ((attrs || bind$$1) && !children) {
      res += ",null";
    }
    if (attrs) {
      res += "," + attrs;
    }
    if (bind$$1) {
      res += (attrs ? '' : ',null') + "," + bind$$1;
    }
    return res + ')';
  }

  // componentName is el.component, take it as argument to shun flow's pessimistic refinement
  function genComponent(componentName, el, state) {
    var children = el.inlineTemplate ? null : genChildren(el, state, true);
    return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
  }

  function genProps(props) {
    var res = '';
    for (var i = 0; i < props.length; i++) {
      var prop = props[i];
      /* istanbul ignore if */
      {
        res += "\"" + prop.name + "\":" + transformSpecialNewlines(prop.value) + ",";
      }
    }
    return res.slice(0, -1);
  }

  // #3895, #4268
  function transformSpecialNewlines(text) {
    return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
  }

  /*  */

  // these keywords should not appear inside expressions, but operators like
  // typeof, instanceof and in are allowed
  var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');

  /*  */

  function createFunction(code, errors) {
    try {
      return new Function(code);
    } catch (err) {
      errors.push({ err: err, code: code });
      return noop;
    }
  }

  function createCompileToFunctionFn(compile) {
    var cache = Object.create(null);

    return function compileToFunctions(template, options, vm) {
      options = extend({}, options);
      var warn$$1 = options.warn || warn;
      delete options.warn;

      // check cache
      var key = options.delimiters ? String(options.delimiters) + template : template;
      if (cache[key]) {
        return cache[key];
      }

      // compile
      var compiled = compile(template, options);

      // turn code into functions
      var res = {};
      var fnGenErrors = [];
      res.render = createFunction(compiled.render, fnGenErrors);
      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
        return createFunction(code, fnGenErrors);
      });

      return cache[key] = res;
    };
  }

  /*  */

  function createCompilerCreator(baseCompile) {
    return function createCompiler(baseOptions) {
      function compile(template, options) {
        var finalOptions = Object.create(baseOptions);
        var errors = [];
        var tips = [];
        finalOptions.warn = function (msg, tip) {
          (tip ? tips : errors).push(msg);
        };

        if (options) {
          // merge custom modules
          if (options.modules) {
            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
          }
          // merge custom directives
          if (options.directives) {
            finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
          }
          // copy other options
          for (var key in options) {
            if (key !== 'modules' && key !== 'directives') {
              finalOptions[key] = options[key];
            }
          }
        }

        var compiled = baseCompile(template, finalOptions);
        compiled.errors = errors;
        compiled.tips = tips;
        return compiled;
      }

      return {
        compile: compile,
        compileToFunctions: createCompileToFunctionFn(compile)
      };
    };
  }

  /*  */

  // `createCompilerCreator` allows creating compilers that use alternative
  // parser/optimizer/codegen, e.g the SSR optimizing compiler.
  // Here we just export a default compiler using the default parts.
  var createCompiler = createCompilerCreator(function baseCompile(template, options) {
    var ast = parse(template.trim(), options);
    if (options.optimize !== false) {
      optimize(ast, options);
    }
    var code = generate(ast, options);
    return {
      ast: ast,
      render: code.render,
      staticRenderFns: code.staticRenderFns
    };
  });

  /*  */

  var ref$1 = createCompiler(baseOptions);
  var compileToFunctions = ref$1.compileToFunctions;

  /*  */

  // check whether current browser encodes a char inside attribute values
  var div;
  function getShouldDecode(href) {
    div = div || document.createElement('div');
    div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
    return div.innerHTML.indexOf('&#10;') > 0;
  }

  // #3663: IE encodes newlines inside attribute values while other browsers don't
  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
  // #6828: chrome encodes content in a[href]
  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

  /*  */

  var idToTemplate = cached(function (id) {
    var el = query(id);
    return el && el.innerHTML;
  });

  var mount = Vue.prototype.$mount;
  Vue.prototype.$mount = function (el, hydrating) {
    el = el && query(el);

    /* istanbul ignore if */
    if (el === document.body || el === document.documentElement) {
      return this;
    }

    var options = this.$options;
    // resolve template/el and convert to render function
    if (!options.render) {
      var template = options.template;
      if (template) {
        if (typeof template === 'string') {
          if (template.charAt(0) === '#') {
            template = idToTemplate(template);
          }
        } else if (template.nodeType) {
          template = template.innerHTML;
        } else {
          return this;
        }
      } else if (el) {
        template = getOuterHTML(el);
      }
      if (template) {

        var ref = compileToFunctions(template, {
          shouldDecodeNewlines: shouldDecodeNewlines,
          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments
        }, this);
        var render = ref.render;
        var staticRenderFns = ref.staticRenderFns;
        options.render = render;
        options.staticRenderFns = staticRenderFns;
      }
    }
    return mount.call(this, el, hydrating);
  };

  /**
   * Get outerHTML of elements, taking care
   * of SVG elements in IE as well.
   */
  function getOuterHTML(el) {
    if (el.outerHTML) {
      return el.outerHTML;
    } else {
      var container = document.createElement('div');
      container.appendChild(el.cloneNode(true));
      return container.innerHTML;
    }
  }

  Vue.compile = compileToFunctions;

  /**
   * The Accordion module
   * @class
   */

  var Accordion = function () {
    /**
     * @param {object} element The Accordion DOM element
     * @constructor
     */
    function Accordion(element) {
      classCallCheck(this, Accordion);

      /** @type {Object} The vue object */
      this._vue = {
        delimiters: ['v{', '}'],
        el: '#' + element.id,
        data: {
          active: Boolean(element.dataset.jsActive)
        },
        methods: {
          toggle: Accordion.toggle,
          ariaHidden: Accordion.ariaHidden
        }
      };
    }

    /**
     * Initializes the module
     */


    createClass(Accordion, [{
      key: 'init',
      value: function init() {
        this._vue = new Vue(this._vue);
      }
    }]);
    return Accordion;
  }();

  /**
   * The toggle method for the active class
   * @param  {object}  event The on click event object
   * @return {boolean}       The toggled active state
   */


  Accordion.toggle = function (event) {
    event.preventDefault();
    this.active = this.active ? false : true;
    return this.active;
  };

  /**
   * The aria hidden method based on wether the component is active or not
   * @param  {boolean} active Optionally to pass a boolean to the function
   * @return {string}         The aria-hidden attribute string based on active
   */
  Accordion.ariaHidden = function () {
    var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.active;

    return active ? 'false' : 'true';
  };

  /**
   * The dom selector for the module
   * @type {String}
   */
  Accordion.selector = '[data-js="accordion"]';

  /** import components here as they are written. */

  /**
   * The Main module
   * @class
   */

  var main = function () {
    function main() {
      classCallCheck(this, main);
    }

    createClass(main, [{
      key: 'module',

      /**
       * Placeholder module for style reference.
       * @param  {object} settings This could be some configuration options for the
       *                           component or module.
       * @param  {object} data     This could be a set of data that is needed for
       *                           the component or module to render.
       * @return {object}          The module
       */
      value: function module(settings, data) {
        return new Module(settings, data).init();
      }

      /**
       * [toggle description]
       * @return {[type]} [description]
       */

    }, {
      key: 'toggle',
      value: function toggle() {
        return new Toggle().init();
      }

      /**
       * [filter description]
       * @return {[type]} [description]
       */

    }, {
      key: 'filter',
      value: function filter() {
        return new Toggle({
          selector: '[data-js="filter"]',
          namespace: 'filter',
          inactiveClass: 'inactive'
        }).init();
      }

      /**
       * An API for the Accordion Component
       */

    }, {
      key: 'accordion',
      value: function accordion() {
        document.querySelectorAll(Accordion.selector).forEach(function (element) {
          var accordion = new Accordion(element);
          accordion.init();
        });
      }
      /** add APIs here as they are written */

    }]);
    return main;
  }();

  return main;

}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQWNjZXNzTnljLmpzIiwic291cmNlcyI6WyIuLi8uLi9zcmMvanMvbW9kdWxlcy9jb25zdGFudHMuanMiLCIuLi8uLi9zcmMvanMvbW9kdWxlcy9tb2R1bGUuanMiLCIuLi8uLi9zcmMvanMvbW9kdWxlcy90b2dnbGUuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qcyIsIi4uLy4uL3NyYy9jb21wb25lbnRzL2FjY29yZGlvbi9hY2NvcmRpb24uanMiLCIuLi8uLi9zcmMvanMvbWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IENvbnN0YW50cyA9IHtcbiAgU1RSSU5HOiAnc3RyaW5nJyxcbiAgTlVNQkVSOiAwLFxuICBGTE9BVDogMC4wMFxufTtcblxuZXhwb3J0IGRlZmF1bHQgQ29uc3RhbnRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQ29uc3RhbnRzIGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBUaGUgTW9kdWxlIHN0eWxlZ3VpZGVcbiAqIEBjbGFzc1xuICovXG5jbGFzcyBNb2R1bGUge1xuICAvKipcbiAgICogQHBhcmFtICB7b2JqZWN0fSBzZXR0aW5ncyBUaGlzIGNvdWxkIGJlIHNvbWUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgb3IgbW9kdWxlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGRhdGEgICAgIFRoaXMgY291bGQgYmUgYSBzZXQgb2YgZGF0YSB0aGF0IGlzIG5lZWRlZCBmb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY29tcG9uZW50IG9yIG1vZHVsZSB0byByZW5kZXIuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MsIGRhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIGNvbnNvbGUubG9nKCdIZWxsbyBXb3JsZCEnKTtcbiAgICB0aGlzLl9jb25zdGFudHMoQ29uc3RhbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGNvbnN0YW50cyB0byB0aGUgZGVidWdnZXJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbSAtIG91ciBjb25zdGFudHNcbiAgICovXG4gIF9jb25zdGFudHMocGFyYW0pIHtcbiAgICBjb25zb2xlLmRpcihwYXJhbSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTW9kdWxlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoZSBTaW1wbGUgVG9nZ2xlIGNsYXNzXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgVG9nZ2xlIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHMgU2V0dGluZ3MgZm9yIHRoaXMgVG9nZ2xlIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge29iamVjdH0gICBUaGUgVG9nZ2xlIGNsYXNzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzKSB7XG4gICAgcyA9ICghcykgPyB7fSA6IHM7XG5cbiAgICB0aGlzLl9zZXR0aW5ncyA9IHtcbiAgICAgIHNlbGVjdG9yOiAocy5zZWxlY3RvcikgPyBzLnNlbGVjdG9yIDogVG9nZ2xlLnNlbGVjdG9yLFxuICAgICAgbmFtZXNwYWNlOiAocy5uYW1lc3BhY2UpID8gcy5uYW1lc3BhY2UgOiBUb2dnbGUubmFtZXNwYWNlLFxuICAgICAgaW5hY3RpdmVDbGFzczogKHMuaW5hY3RpdmVDbGFzcykgPyBzLmluYWN0aXZlQ2xhc3MgOiBUb2dnbGUuaW5hY3RpdmVDbGFzcyxcbiAgICAgIGFjdGl2ZUNsYXNzOiAocy5hY3RpdmVDbGFzcykgPyBzLmFjdGl2ZUNsYXNzIDogVG9nZ2xlLmFjdGl2ZUNsYXNzLFxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbW9kdWxlXG4gICAqL1xuICBpbml0KCkge1xuICAgIGNvbnN0IGJvZHkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5Jyk7XG4gICAgYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgbGV0IG1ldGhvZCA9ICghZXZlbnQudGFyZ2V0Lm1hdGNoZXMpID8gJ21zTWF0Y2hlc1NlbGVjdG9yJyA6ICdtYXRjaGVzJztcblxuICAgICAgaWYgKCFldmVudC50YXJnZXRbbWV0aG9kXSh0aGlzLl9zZXR0aW5ncy5zZWxlY3RvcikpXG4gICAgICAgIHJldHVybjtcblxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdGhpcy5fdG9nZ2xlKGV2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGNvbnN0YW50cyB0byB0aGUgZGVidWdnZXJcbiAgICogQHBhcmFtICB7b2JqZWN0fSBldmVudCAgVGhlIG1haW4gY2xpY2sgZXZlbnRcbiAgICogQHJldHVybiB7Y2xhc3N9ICAgICAgICAgVGhlIFRvZ2dsZSBjbGFzc1xuICAgKi9cbiAgX3RvZ2dsZShldmVudCkge1xuICAgIGxldCBlbCA9IGV2ZW50LnRhcmdldDtcbiAgICBjb25zdCBzZWxlY3RvciA9IGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpID9cbiAgICAgIGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpIDogZWwuZGF0YXNldFtgJHt0aGlzLl9zZXR0aW5ncy5uYW1lc3BhY2V9VGFyZ2V0YF07XG4gICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG5cbiAgICAvKipcbiAgICAgKiBNYWluXG4gICAgICovXG4gICAgdGhpcy5fZWxlbWVudFRvZ2dsZShlbCwgdGFyZ2V0KTtcblxuICAgIC8qKlxuICAgICAqIExvY2F0aW9uXG4gICAgICogQ2hhbmdlIHRoZSB3aW5kb3cgbG9jYXRpb25cbiAgICAgKi9cbiAgICBpZiAoZWwuZGF0YXNldFtgJHt0aGlzLl9zZXR0aW5ncy5uYW1lc3BhY2V9TG9jYXRpb25gXSlcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gZWwuZGF0YXNldFtgJHt0aGlzLl9zZXR0aW5ncy5uYW1lc3BhY2V9TG9jYXRpb25gXTtcblxuICAgIC8qKlxuICAgICAqIFVuZG9cbiAgICAgKiBBZGQgdG9nZ2xpbmcgZXZlbnQgdG8gdGhlIGVsZW1lbnQgdGhhdCB1bmRvZXMgdGhlIHRvZ2dsZVxuICAgICAqL1xuICAgIGlmIChlbC5kYXRhc2V0W2Ake3RoaXMuX3NldHRpbmdzLm5hbWVzcGFjZX1VbmRvYF0pIHtcbiAgICAgIGNvbnN0IHVuZG8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICBlbC5kYXRhc2V0W2Ake3RoaXMuX3NldHRpbmdzLm5hbWVzcGFjZX1VbmRvYF1cbiAgICAgICk7XG4gICAgICB1bmRvLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRUb2dnbGUoZWwsIHRhcmdldCk7XG4gICAgICAgIHVuZG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBtYWluIHRvZ2dsaW5nIG1ldGhvZFxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGVsICAgICBUaGUgY3VycmVudCBlbGVtZW50IHRvIHRvZ2dsZSBhY3RpdmVcbiAgICogQHBhcmFtICB7b2JqZWN0fSB0YXJnZXQgVGhlIHRhcmdldCBlbGVtZW50IHRvIHRvZ2dsZSBhY3RpdmUvaGlkZGVuXG4gICAqIEByZXR1cm4ge2NsYXNzfSAgICAgICAgIFRoZSBUb2dnbGUgY2xhc3NcbiAgICovXG4gIF9lbGVtZW50VG9nZ2xlKGVsLCB0YXJnZXQpIHtcbiAgICBlbC5jbGFzc0xpc3QudG9nZ2xlKHRoaXMuX3NldHRpbmdzLmFjdGl2ZUNsYXNzKTtcbiAgICB0YXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLl9zZXR0aW5ncy5hY3RpdmVDbGFzcyk7XG4gICAgdGFyZ2V0LmNsYXNzTGlzdC50b2dnbGUodGhpcy5fc2V0dGluZ3MuaW5hY3RpdmVDbGFzcyk7XG4gICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLFxuICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLl9zZXR0aW5ncy5pbmFjdGl2ZUNsYXNzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuXG4vKiogQHR5cGUge1N0cmluZ30gVGhlIG1haW4gc2VsZWN0b3IgdG8gYWRkIHRoZSB0b2dnbGluZyBmdW5jdGlvbiB0byAqL1xuVG9nZ2xlLnNlbGVjdG9yID0gJ1tkYXRhLWpzPVwidG9nZ2xlXCJdJztcblxuLyoqIEB0eXBlIHtTdHJpbmd9IFRoZSBuYW1lc3BhY2UgZm9yIG91ciBkYXRhIGF0dHJpYnV0ZSBzZXR0aW5ncyAqL1xuVG9nZ2xlLm5hbWVzcGFjZSA9ICd0b2dnbGUnO1xuXG4vKiogQHR5cGUge1N0cmluZ30gVGhlIGhpZGUgY2xhc3MgKi9cblRvZ2dsZS5pbmFjdGl2ZUNsYXNzID0gJ2hpZGRlbic7XG5cbi8qKiBAdHlwZSB7U3RyaW5nfSBUaGUgYWN0aXZlIGNsYXNzICovXG5Ub2dnbGUuYWN0aXZlQ2xhc3MgPSAnYWN0aXZlJztcblxuXG5leHBvcnQgZGVmYXVsdCBUb2dnbGU7XG4iLCIvKiFcbiAqIFZ1ZS5qcyB2Mi41LjE2XG4gKiAoYykgMjAxNC0yMDE4IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gdGhlc2UgaGVscGVycyBwcm9kdWNlcyBiZXR0ZXIgdm0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZ1xuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJ1xuICApXG59XG5cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xufVxuXG4vKipcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUgZS5nLiBbb2JqZWN0IE9iamVjdF1cbiAqL1xudmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbmZ1bmN0aW9uIHRvUmF3VHlwZSAodmFsdWUpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0IChvYmopIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwICh2KSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXggKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICByZXR1cm4gbiA+PSAwICYmIE1hdGguZmxvb3IobikgPT09IG4gJiYgaXNGaW5pdGUodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbFxuICAgID8gJydcbiAgICA6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG4gICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgIDogU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KHZhbCk7XG4gIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cbn1cblxuLyoqXG4gKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcbiAqIGlzIGluIHRoYXQgbWFwLlxuICovXG5mdW5jdGlvbiBtYWtlTWFwIChcbiAgc3RyLFxuICBleHBlY3RzTG93ZXJDYXNlXG4pIHtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdHNMb3dlckNhc2VcbiAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICA6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWxdOyB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXG4gKi9cbnZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgYXR0cmlidXRlIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuICovXG52YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICBpZiAoYXJyLmxlbmd0aCkge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXR1cm4gYXJyLnNwbGljZShpbmRleCwgMSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FjaGVkIHZlcnNpb24gb2YgYSBwdXJlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgIHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuICAgIHJldHVybiBoaXQgfHwgKGNhY2hlW3N0cl0gPSBmbihzdHIpKVxuICB9KVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xudmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG59KTtcblxuLyoqXG4gKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuICovXG52YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcbn0pO1xuXG4vKipcbiAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG4gKi9cbnZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxufSk7XG5cbi8qKlxuICogU2ltcGxlIGJpbmQgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0Li4uIGUuZy5cbiAqIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5IHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlIHNpbmNlIG5hdGl2ZSBiaW5kIGlzXG4gKiBub3cgbW9yZSBwZXJmb3JtYW50IGluIG1vc3QgYnJvd3NlcnMsIGJ1dCByZW1vdmluZyBpdCB3b3VsZCBiZSBicmVha2luZyBmb3JcbiAqIGNvZGUgdGhhdCB3YXMgYWJsZSB0byBydW4gaW4gUGhhbnRvbUpTIDEueCwgc28gdGhpcyBtdXN0IGJlIGtlcHQgZm9yXG4gKiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gcG9seWZpbGxCaW5kIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cblxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbmZ1bmN0aW9uIG5hdGl2ZUJpbmQgKGZuLCBjdHgpIHtcbiAgcmV0dXJuIGZuLmJpbmQoY3R4KVxufVxuXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kXG4gID8gbmF0aXZlQmluZFxuICA6IHBvbHlmaWxsQmluZDtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LylcbiAqL1xuZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnLFxuICAnZXJyb3JDYXB0dXJlZCdcbl07XG5cbi8qICAqL1xuXG52YXIgY29uZmlnID0gKHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAqL1xuICBwcm9kdWN0aW9uVGlwOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAqL1xuICB3YXJuSGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn0pXG5cbi8qICAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBpbldlZXggPSB0eXBlb2YgV1hFbnZpcm9ubWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgISFXWEVudmlyb25tZW50LnBsYXRmb3JtO1xudmFyIHdlZXhQbGF0Zm9ybSA9IGluV2VleCAmJiBXWEVudmlyb25tZW50LnBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSAoVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMCkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbnZhciBpc0lPUyA9IChVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpKSB8fCAod2VleFBsYXRmb3JtID09PSAnaW9zJyk7XG52YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcblxuLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxudmFyIG5hdGl2ZVdhdGNoID0gKHt9KS53YXRjaDtcblxudmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuaWYgKGluQnJvd3Nlcikge1xuICB0cnkge1xuICAgIHZhciBvcHRzID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdHMsICdwYXNzaXZlJywgKHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbnZhciBfaXNTZXJ2ZXI7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmICFpbldlZXggJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChub29wKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuICAgIC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICB2YXIgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XG5cbiAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgfSBlbHNlIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyB0cmFjZSkpO1xuICAgIH1cbiAgfTtcblxuICB0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltWdWUgdGlwXTogXCIgKyBtc2cgKyAoXG4gICAgICAgIHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuICAgICAgKSk7XG4gICAgfVxuICB9O1xuXG4gIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgaWYgKHZtLiRyb290ID09PSB2bSkge1xuICAgICAgcmV0dXJuICc8Um9vdD4nXG4gICAgfVxuICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLmNpZCAhPSBudWxsXG4gICAgICA/IHZtLm9wdGlvbnNcbiAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgID8gdm0uJG9wdGlvbnMgfHwgdm0uY29uc3RydWN0b3Iub3B0aW9uc1xuICAgICAgICA6IHZtIHx8IHt9O1xuICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgICB2YXIgZmlsZSA9IG9wdGlvbnMuX19maWxlO1xuICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgIG5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgKG5hbWUgPyAoXCI8XCIgKyAoY2xhc3NpZnkobmFtZSkpICsgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXG4gICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuICAgIClcbiAgfTtcblxuICB2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuICAgIHZhciByZXMgPSAnJztcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cbiAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICBuID4+PSAxO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH07XG5cbiAgZ2VuZXJhdGVDb21wb25lbnRUcmFjZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgdmFyIHRyZWUgPSBbXTtcbiAgICAgIHZhciBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgd2hpbGUgKHZtKSB7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xuICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcbiAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHZtLCBpKSB7IHJldHVybiAoXCJcIiArIChpID09PSAwID8gJy0tLT4gJyA6IHJlcGVhdCgnICcsIDUgKyBpICogMikpICsgKEFycmF5LmlzQXJyYXkodm0pXG4gICAgICAgICAgICA/ICgoZm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSkpICsgXCIuLi4gKFwiICsgKHZtWzFdKSArIFwiIHJlY3Vyc2l2ZSBjYWxscylcIilcbiAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpKTsgfSlcbiAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCJcXG5cXG4oZm91bmQgaW4gXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIpXCIpXG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuXG52YXIgdWlkID0gMDtcblxuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKi9cbnZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICB0aGlzLmlkID0gdWlkKys7XG4gIHRoaXMuc3VicyA9IFtdO1xufTtcblxuRGVwLnByb3RvdHlwZS5hZGRTdWIgPSBmdW5jdGlvbiBhZGRTdWIgKHN1Yikge1xuICB0aGlzLnN1YnMucHVzaChzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiByZW1vdmVTdWIgKHN1Yikge1xuICByZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XG4gIHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBzdWJzW2ldLnVwZGF0ZSgpO1xuICB9XG59O1xuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cbkRlcC50YXJnZXQgPSBudWxsO1xudmFyIHRhcmdldFN0YWNrID0gW107XG5cbmZ1bmN0aW9uIHB1c2hUYXJnZXQgKF90YXJnZXQpIHtcbiAgaWYgKERlcC50YXJnZXQpIHsgdGFyZ2V0U3RhY2sucHVzaChEZXAudGFyZ2V0KTsgfVxuICBEZXAudGFyZ2V0ID0gX3RhcmdldDtcbn1cblxuZnVuY3Rpb24gcG9wVGFyZ2V0ICgpIHtcbiAgRGVwLnRhcmdldCA9IHRhcmdldFN0YWNrLnBvcCgpO1xufVxuXG4vKiAgKi9cblxudmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICB0ZXh0LFxuICBlbG0sXG4gIGNvbnRleHQsXG4gIGNvbXBvbmVudE9wdGlvbnMsXG4gIGFzeW5jRmFjdG9yeVxuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gdW5kZWZpbmVkO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLmZuQ29udGV4dCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICB0aGlzLmtleSA9IGRhdGEgJiYgZGF0YS5rZXk7XG4gIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG4gIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLnJhdyA9IGZhbHNlO1xuICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gIHRoaXMuaXNSb290SW5zZXJ0ID0gdHJ1ZTtcbiAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcbiAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICB0aGlzLmlzT25jZSA9IGZhbHNlO1xuICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcbiAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gIHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyID0gZmFsc2U7XG59O1xuXG52YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4vLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xucHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY29tcG9uZW50SW5zdGFuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG52YXIgY3JlYXRlRW1wdHlWTm9kZSA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gIGlmICggdGV4dCA9PT0gdm9pZCAwICkgdGV4dCA9ICcnO1xuXG4gIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gIG5vZGUudGV4dCA9IHRleHQ7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgIHZub2RlLnRhZyxcbiAgICB2bm9kZS5kYXRhLFxuICAgIHZub2RlLmNoaWxkcmVuLFxuICAgIHZub2RlLnRleHQsXG4gICAgdm5vZGUuZWxtLFxuICAgIHZub2RlLmNvbnRleHQsXG4gICAgdm5vZGUuY29tcG9uZW50T3B0aW9ucyxcbiAgICB2bm9kZS5hc3luY0ZhY3RvcnlcbiAgKTtcbiAgY2xvbmVkLm5zID0gdm5vZGUubnM7XG4gIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICBjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuICBjbG9uZWQuZm5Db250ZXh0ID0gdm5vZGUuZm5Db250ZXh0O1xuICBjbG9uZWQuZm5PcHRpb25zID0gdm5vZGUuZm5PcHRpb25zO1xuICBjbG9uZWQuZm5TY29wZUlkID0gdm5vZGUuZm5TY29wZUlkO1xuICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICByZXR1cm4gY2xvbmVkXG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XG5cbnZhciBtZXRob2RzVG9QYXRjaCA9IFtcbiAgJ3B1c2gnLFxuICAncG9wJyxcbiAgJ3NoaWZ0JyxcbiAgJ3Vuc2hpZnQnLFxuICAnc3BsaWNlJyxcbiAgJ3NvcnQnLFxuICAncmV2ZXJzZSdcbl07XG5cbi8qKlxuICogSW50ZXJjZXB0IG11dGF0aW5nIG1ldGhvZHMgYW5kIGVtaXQgZXZlbnRzXG4gKi9cbm1ldGhvZHNUb1BhdGNoLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEluIHNvbWUgY2FzZXMgd2UgbWF5IHdhbnQgdG8gZGlzYWJsZSBvYnNlcnZhdGlvbiBpbnNpZGUgYSBjb21wb25lbnQnc1xuICogdXBkYXRlIGNvbXB1dGF0aW9uLlxuICovXG52YXIgc2hvdWxkT2JzZXJ2ZSA9IHRydWU7XG5cbmZ1bmN0aW9uIHRvZ2dsZU9ic2VydmluZyAodmFsdWUpIHtcbiAgc2hvdWxkT2JzZXJ2ZSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGhlIHRhcmdldFxuICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG9cbiAgICAgID8gcHJvdG9BdWdtZW50XG4gICAgICA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUob2JqLCBrZXlzW2ldKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKi9cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUgKHZhbHVlLCBhc1Jvb3REYXRhKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb2I7XG4gIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgIG9iID0gdmFsdWUuX19vYl9fO1xuICB9IGVsc2UgaWYgKFxuICAgIHNob3VsZE9ic2VydmUgJiZcbiAgICAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSAmJlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcbiAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICF2YWx1ZS5faXNWdWVcbiAgKSB7XG4gICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICB9XG4gIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG4gICAgb2Iudm1Db3VudCsrO1xuICB9XG4gIHJldHVybiBvYlxufVxuXG4vKipcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lUmVhY3RpdmUgKFxuICBvYmosXG4gIGtleSxcbiAgdmFsLFxuICBjdXN0b21TZXR0ZXIsXG4gIHNoYWxsb3dcbikge1xuICB2YXIgZGVwID0gbmV3IERlcCgpO1xuXG4gIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICBpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XG4gIGlmICghZ2V0dGVyICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YWwgPSBvYmpba2V5XTtcbiAgfVxuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IGRlbGV0ZSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodG9WYWwpICYmIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcywgdGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogcGFyZW50VmFsXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VIb29rIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbFxuKSB7XG4gIHJldHVybiBjaGlsZFZhbFxuICAgID8gcGFyZW50VmFsXG4gICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgID8gY2hpbGRWYWxcbiAgICAgICAgOiBbY2hpbGRWYWxdXG4gICAgOiBwYXJlbnRWYWxcbn1cblxuTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgaWYgKGNoaWxkVmFsKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICByZXR1cm4gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG59XG5cbkFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG59KTtcblxuLyoqXG4gKiBXYXRjaGVycy5cbiAqXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgLy8gd29yayBhcm91bmQgRmlyZWZveCdzIE9iamVjdC5wcm90b3R5cGUud2F0Y2guLi5cbiAgaWYgKHBhcmVudFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgcGFyZW50VmFsID0gdW5kZWZpbmVkOyB9XG4gIGlmIChjaGlsZFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgY2hpbGRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0ge307XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGZvciAodmFyIGtleSQxIGluIGNoaWxkVmFsKSB7XG4gICAgdmFyIHBhcmVudCA9IHJldFtrZXkkMV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5JDFdO1xuICAgIGlmIChwYXJlbnQgJiYgIUFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgfVxuICAgIHJldFtrZXkkMV0gPSBwYXJlbnRcbiAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gIH1cbiAgcmV0dXJuIHJldFxufTtcblxuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuc3RyYXRzLm1ldGhvZHMgPVxuc3RyYXRzLmluamVjdCA9XG5zdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICBpZiAoY2hpbGRWYWwgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBpZiAoY2hpbGRWYWwpIHsgZXh0ZW5kKHJldCwgY2hpbGRWYWwpOyB9XG4gIHJldHVybiByZXRcbn07XG5zdHJhdHMucHJvdmlkZSA9IG1lcmdlRGF0YU9yRm47XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJlbnRWYWxcbiAgICA6IGNoaWxkVmFsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZSAobmFtZSkge1xuICBpZiAoIS9eW2EtekEtWl1bXFx3LV0qJC8udGVzdChuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgJ2NhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYW5kIHRoZSBoeXBoZW4sICcgK1xuICAgICAgJ2FuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIuJ1xuICAgICk7XG4gIH1cbiAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhuYW1lKSkge1xuICAgIHdhcm4oXG4gICAgICAnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcbiAgICAgICdpZDogJyArIG5hbWVcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucywgdm0pIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcInByb3BzXFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHByb3BzKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zLCB2bSkge1xuICB2YXIgaW5qZWN0ID0gb3B0aW9ucy5pbmplY3Q7XG4gIGlmICghaW5qZWN0KSB7IHJldHVybiB9XG4gIHZhciBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICB2YXIgdmFsID0gaW5qZWN0W2tleV07XG4gICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyBleHRlbmQoeyBmcm9tOiBrZXkgfSwgdmFsKVxuICAgICAgICA6IHsgZnJvbTogdmFsIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcImluamVjdFxcXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZShpbmplY3QpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuICB2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcbiAgaWYgKGRpcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xuICAgICAgdmFyIGRlZiA9IGRpcnNba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlIChuYW1lLCB2YWx1ZSwgdm0pIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiOiBleHBlY3RlZCBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUodmFsdWUpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9wdGlvbiBvYmplY3RzIGludG8gYSBuZXcgb25lLlxuICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VPcHRpb25zIChcbiAgcGFyZW50LFxuICBjaGlsZCxcbiAgdm1cbikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuICB9XG5cbiAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuICB2YXIgZXh0ZW5kc0Zyb20gPSBjaGlsZC5leHRlbmRzO1xuICBpZiAoZXh0ZW5kc0Zyb20pIHtcbiAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBleHRlbmRzRnJvbSwgdm0pO1xuICB9XG4gIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuICAgIH1cbiAgfVxuICB2YXIgb3B0aW9ucyA9IHt9O1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcbiAgICBtZXJnZUZpZWxkKGtleSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG4gICAgdmFyIHN0cmF0ID0gc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0O1xuICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgb3B0aW9ucyxcbiAgdHlwZSxcbiAgaWQsXG4gIHdhcm5NaXNzaW5nXG4pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG4gIC8vIGNoZWNrIGxvY2FsIHJlZ2lzdHJhdGlvbiB2YXJpYXRpb25zIGZpcnN0XG4gIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICB2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpIHsgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF0gfVxuICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG4gIC8vIGZhbGxiYWNrIHRvIHByb3RvdHlwZSBjaGFpblxuICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgd2FybihcbiAgICAgICdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuICBrZXksXG4gIHByb3BPcHRpb25zLFxuICBwcm9wc0RhdGEsXG4gIHZtXG4pIHtcbiAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gIHZhciB2YWx1ZSA9IHByb3BzRGF0YVtrZXldO1xuICAvLyBib29sZWFuIGNhc3RpbmdcbiAgdmFyIGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpIHtcbiAgICAgIC8vIG9ubHkgY2FzdCBlbXB0eSBzdHJpbmcgLyBzYW1lIG5hbWUgdG8gYm9vbGVhbiBpZlxuICAgICAgLy8gYm9vbGVhbiBoYXMgaGlnaGVyIHByaW9yaXR5XG4gICAgICB2YXIgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xuICAgICAgaWYgKHN0cmluZ0luZGV4IDwgMCB8fCBib29sZWFuSW5kZXggPCBzdHJpbmdJbmRleCkge1xuICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgIC8vIG1ha2Ugc3VyZSB0byBvYnNlcnZlIGl0LlxuICAgIHZhciBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgIG9ic2VydmUodmFsdWUpO1xuICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XG4gIH1cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAvLyBza2lwIHZhbGlkYXRpb24gZm9yIHdlZXggcmVjeWNsZS1saXN0IGNoaWxkIGNvbXBvbmVudCBwcm9wc1xuICAgICEoZmFsc2UgJiYgaXNPYmplY3QodmFsdWUpICYmICgnQGJpbmRpbmcnIGluIHZhbHVlKSlcbiAgKSB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzT2JqZWN0KGRlZikpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG4gIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICBpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHZtLl9wcm9wc1trZXldXG4gIH1cbiAgLy8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcbiAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICA/IGRlZi5jYWxsKHZtKVxuICAgIDogZGVmXG59XG5cbi8qKlxuICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRQcm9wIChcbiAgcHJvcCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIHZtLFxuICBhYnNlbnRcbikge1xuICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICB3YXJuKFxuICAgICAgJ01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgdmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcbiAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgaWYgKHR5cGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcbiAgICAgIHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcbiAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgIHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuICAgIH1cbiAgfVxuICBpZiAoIXZhbGlkKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiICtcbiAgICAgIFwiIEV4cGVjdGVkIFwiICsgKGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykpICtcbiAgICAgIFwiLCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gIGlmICh2YWxpZGF0b3IpIHtcbiAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcbiAgdmFyIHZhbGlkO1xuICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgdmFyIHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBmb3IgcHJpbWl0aXZlIHdyYXBwZXIgb2JqZWN0c1xuICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG4gICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcbiAgICB2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmFsaWQ6IHZhbGlkLFxuICAgIGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG4gIH1cbn1cblxuLyoqXG4gKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcbiAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcbiAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcbiAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xufVxuXG5mdW5jdGlvbiBpc1NhbWVUeXBlIChhLCBiKSB7XG4gIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpXG59XG5cbmZ1bmN0aW9uIGdldFR5cGVJbmRleCAodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICByZXR1cm4gaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzLCB0eXBlKSA/IDAgOiAtMVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlc1tpXSwgdHlwZSkpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKHZtKSB7XG4gICAgdmFyIGN1ciA9IHZtO1xuICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XG4gICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcbiAgICAgIGlmIChob29rcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjYXB0dXJlID0gaG9va3NbaV0uY2FsbChjdXIsIGVyciwgdm0sIGluZm8pID09PSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlKSB7IHJldHVybiB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZSwgY3VyLCAnZXJyb3JDYXB0dXJlZCBob29rJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBnbG9iYWxIYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nRXJyb3IoZSwgbnVsbCwgJ2NvbmZpZy5lcnJvckhhbmRsZXInKTtcbiAgICB9XG4gIH1cbiAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGxvZ0Vycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICgoaW5Ccm93c2VyIHx8IGluV2VleCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8qICAqL1xuLyogZ2xvYmFscyBNZXNzYWdlQ2hhbm5lbCAqL1xuXG52YXIgY2FsbGJhY2tzID0gW107XG52YXIgcGVuZGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29waWVzW2ldKCk7XG4gIH1cbn1cblxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBib3RoIG1pY3JvdGFza3MgYW5kIChtYWNybykgdGFza3MuXG4vLyBJbiA8IDIuNCB3ZSB1c2VkIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYnV0IHRoZXJlIGFyZSBzb21lIHNjZW5hcmlvcyB3aGVyZVxuLy8gbWljcm90YXNrcyBoYXZlIHRvbyBoaWdoIGEgcHJpb3JpdHkgYW5kIGZpcmUgaW4gYmV0d2VlbiBzdXBwb3NlZGx5XG4vLyBzZXF1ZW50aWFsIGV2ZW50cyAoZS5nLiAjNDUyMSwgIzY2OTApIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZVxuLy8gZXZlbnQgKCM2NTY2KS4gSG93ZXZlciwgdXNpbmcgKG1hY3JvKSB0YXNrcyBldmVyeXdoZXJlIGFsc28gaGFzIHN1YnRsZSBwcm9ibGVtc1xuLy8gd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50IChlLmcuICM2ODEzLCBvdXQtaW4gdHJhbnNpdGlvbnMpLlxuLy8gSGVyZSB3ZSB1c2UgbWljcm90YXNrIGJ5IGRlZmF1bHQsIGJ1dCBleHBvc2UgYSB3YXkgdG8gZm9yY2UgKG1hY3JvKSB0YXNrIHdoZW5cbi8vIG5lZWRlZCAoZS5nLiBpbiBldmVudCBoYW5kbGVycyBhdHRhY2hlZCBieSB2LW9uKS5cbnZhciBtaWNyb1RpbWVyRnVuYztcbnZhciBtYWNyb1RpbWVyRnVuYztcbnZhciB1c2VNYWNyb1Rhc2sgPSBmYWxzZTtcblxuLy8gRGV0ZXJtaW5lIChtYWNybykgdGFzayBkZWZlciBpbXBsZW1lbnRhdGlvbi5cbi8vIFRlY2huaWNhbGx5IHNldEltbWVkaWF0ZSBzaG91bGQgYmUgdGhlIGlkZWFsIGNob2ljZSwgYnV0IGl0J3Mgb25seSBhdmFpbGFibGVcbi8vIGluIElFLiBUaGUgb25seSBwb2x5ZmlsbCB0aGF0IGNvbnNpc3RlbnRseSBxdWV1ZXMgdGhlIGNhbGxiYWNrIGFmdGVyIGFsbCBET01cbi8vIGV2ZW50cyB0cmlnZ2VyZWQgaW4gdGhlIHNhbWUgbG9vcCBpcyBieSB1c2luZyBNZXNzYWdlQ2hhbm5lbC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gIGlzTmF0aXZlKE1lc3NhZ2VDaGFubmVsKSB8fFxuICAvLyBQaGFudG9tSlNcbiAgTWVzc2FnZUNoYW5uZWwudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTWVzc2FnZUNoYW5uZWxDb25zdHJ1Y3Rvcl0nXG4pKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIHZhciBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaENhbGxiYWNrcztcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcG9ydC5wb3N0TWVzc2FnZSgxKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQoZmx1c2hDYWxsYmFja3MsIDApO1xuICB9O1xufVxuXG4vLyBEZXRlcm1pbmUgbWljcm90YXNrIGRlZmVyIGltcGxlbWVudGF0aW9uLlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBtaWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIGZhbGxiYWNrIHRvIG1hY3JvXG4gIG1pY3JvVGltZXJGdW5jID0gbWFjcm9UaW1lckZ1bmM7XG59XG5cbi8qKlxuICogV3JhcCBhIGZ1bmN0aW9uIHNvIHRoYXQgaWYgYW55IGNvZGUgaW5zaWRlIHRyaWdnZXJzIHN0YXRlIGNoYW5nZSxcbiAqIHRoZSBjaGFuZ2VzIGFyZSBxdWV1ZWQgdXNpbmcgYSAobWFjcm8pIHRhc2sgaW5zdGVhZCBvZiBhIG1pY3JvdGFzay5cbiAqL1xuZnVuY3Rpb24gd2l0aE1hY3JvVGFzayAoZm4pIHtcbiAgcmV0dXJuIGZuLl93aXRoVGFzayB8fCAoZm4uX3dpdGhUYXNrID0gZnVuY3Rpb24gKCkge1xuICAgIHVzZU1hY3JvVGFzayA9IHRydWU7XG4gICAgdmFyIHJlcyA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgdXNlTWFjcm9UYXNrID0gZmFsc2U7XG4gICAgcmV0dXJuIHJlc1xuICB9KVxufVxuXG5mdW5jdGlvbiBuZXh0VGljayAoY2IsIGN0eCkge1xuICB2YXIgX3Jlc29sdmU7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9yZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZShjdHgpO1xuICAgIH1cbiAgfSk7XG4gIGlmICghcGVuZGluZykge1xuICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgIGlmICh1c2VNYWNyb1Rhc2spIHtcbiAgICAgIG1hY3JvVGltZXJGdW5jKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pY3JvVGltZXJGdW5jKCk7XG4gICAgfVxuICB9XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBtYXJrO1xudmFyIG1lYXN1cmU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwZXJmICYmXG4gICAgcGVyZi5tYXJrICYmXG4gICAgcGVyZi5tZWFzdXJlICYmXG4gICAgcGVyZi5jbGVhck1hcmtzICYmXG4gICAgcGVyZi5jbGVhck1lYXN1cmVzXG4gICkge1xuICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcbiAgICBtZWFzdXJlID0gZnVuY3Rpb24gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpIHtcbiAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKTtcbiAgICB9O1xuICB9XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgd2FybihcbiAgICAgIFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcbiAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgJ2VpdGhlciBpbiB0aGUgZGF0YSBvcHRpb24sIG9yIGZvciBjbGFzcy1iYXNlZCBjb21wb25lbnRzLCBieSAnICtcbiAgICAgICdpbml0aWFsaXppbmcgdGhlIHByb3BlcnR5LiAnICtcbiAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxuICAgICAgdGFyZ2V0XG4gICAgKTtcbiAgfTtcblxuICB2YXIgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJveHkpO1xuXG4gIGlmIChoYXNQcm94eSkge1xuICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICBjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgd2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc0hhbmRsZXIgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkXG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRIYW5kbGVyID0ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldFtrZXldXG4gICAgfVxuICB9O1xuXG4gIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgPyBnZXRIYW5kbGVyXG4gICAgICAgIDogaGFzSGFuZGxlcjtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gKiBnZXR0ZXJzLCBzbyB0aGF0IGV2ZXJ5IG5lc3RlZCBwcm9wZXJ0eSBpbnNpZGUgdGhlIG9iamVjdFxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2UgKHZhbCkge1xuICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG59XG5cbmZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG4gIHZhciBpLCBrZXlzO1xuICB2YXIgaXNBID0gQXJyYXkuaXNBcnJheSh2YWwpO1xuICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8IE9iamVjdC5pc0Zyb3plbih2YWwpIHx8IHZhbCBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZhbC5fX29iX18pIHtcbiAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgc2Vlbi5hZGQoZGVwSWQpO1xuICB9XG4gIGlmIChpc0EpIHtcbiAgICBpID0gdmFsLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG4gIH0gZWxzZSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gIG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgbmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIG9uY2U6IG9uY2UkJDEsXG4gICAgY2FwdHVyZTogY2FwdHVyZSxcbiAgICBwYXNzaXZlOiBwYXNzaXZlXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucykge1xuICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgdmFyIGNsb25lZCA9IGZucy5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2xvbmVkW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cyQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmV0dXJuIGhhbmRsZXIgcmV0dXJuIHZhbHVlIGZvciBzaW5nbGUgaGFuZGxlcnNcbiAgICAgIHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuICBpbnZva2VyLmZucyA9IGZucztcbiAgcmV0dXJuIGludm9rZXJcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgb24sXG4gIG9sZE9uLFxuICBhZGQsXG4gIHJlbW92ZSQkMSxcbiAgdm1cbikge1xuICB2YXIgbmFtZSwgZGVmLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGRlZiA9IGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1cik7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5vbmNlLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlLCBldmVudC5wYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICB9XG4gIH1cbiAgZm9yIChuYW1lIGluIG9sZE9uKSB7XG4gICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgcmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2spIHtcbiAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgfVxuICB2YXIgaW52b2tlcjtcbiAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgLy8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcbiAgICByZW1vdmUoaW52b2tlci5mbnMsIHdyYXBwZWRIb29rKTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG4gICAgLy8gbm8gZXhpc3RpbmcgaG9va1xuICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gIH0gZWxzZSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIHBsYWluIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgfVxuICB9XG5cbiAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG4gIGRhdGEsXG4gIEN0b3IsXG4gIHRhZ1xuKSB7XG4gIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcbiAgLy8gY29tcG9uZW50IGl0c2VsZi5cbiAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBhdHRycyA9IGRhdGEuYXR0cnM7XG4gIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gIGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiZcbiAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aXAoXG4gICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuICAgICAgICAgICAgXCIgXFxcIlwiICsga2V5ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgXCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcbiAgICAgICAgICAgIFwidGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyBhbHRLZXkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBjaGVja1Byb3AgKFxuICByZXMsXG4gIGhhc2gsXG4gIGtleSxcbiAgYWx0S2V5LFxuICBwcmVzZXJ2ZVxuKSB7XG4gIGlmIChpc0RlZihoYXNoKSkge1xuICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xuICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgIGRlbGV0ZSBoYXNoW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFthbHRLZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgfVxuICB9XG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxuLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4vLyB3aXRoIGhhbmQtd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zIC8gSlNYLiBJbiBzdWNoIGNhc2VzIGEgZnVsbCBub3JtYWxpemF0aW9uXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICByZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG4gICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICA/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG4gICAgICA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlIChub2RlKSB7XG4gIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4gKGNoaWxkcmVuLCBuZXN0ZWRJbmRleCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICBsYXN0SW5kZXggPSByZXMubGVuZ3RoIC0gMTtcbiAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgLy8gIG5lc3RlZFxuICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICBpZiAoYy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICBjLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKGMpKSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBTU1IgaHlkcmF0aW9uIGJlY2F1c2UgdGV4dCBub2RlcyBhcmVcbiAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgfSBlbHNlIGlmIChjICE9PSAnJykge1xuICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZmF1bHQga2V5IGZvciBuZXN0ZWQgYXJyYXkgY2hpbGRyZW4gKGxpa2VseSBnZW5lcmF0ZWQgYnkgdi1mb3IpXG4gICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgaXNEZWYoYy50YWcpICYmXG4gICAgICAgICAgaXNVbmRlZihjLmtleSkgJiZcbiAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICBjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcbiAgaWYgKFxuICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgIChoYXNTeW1ib2wgJiYgY29tcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbiAgKSB7XG4gICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgfVxuICByZXR1cm4gaXNPYmplY3QoY29tcClcbiAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgOiBjb21wXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICBmYWN0b3J5LFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgdmFyIG5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgZmFjdG9yeSxcbiAgYmFzZUN0b3IsXG4gIGNvbnRleHRcbikge1xuICBpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxuXG4gIGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG4gIH1cblxuICBpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcbiAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICBmYWN0b3J5LmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRleHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb250ZXh0c1tpXS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIC8vIGNhY2hlIHJlc29sdmVkXG4gICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgIC8vIGludm9rZSBjYWxsYmFja3Mgb25seSBpZiB0aGlzIGlzIG5vdCBhIHN5bmNocm9ub3VzIHJlc29sdmVcbiAgICAgIC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcbiAgICAgICAgKHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG4gICAgICApO1xuICAgICAgaWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciByZXMgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihyZXMuY29tcG9uZW50KSAmJiB0eXBlb2YgcmVzLmNvbXBvbmVudC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgIGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgICAgICAgICAgICAgICA/IChcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCIpXG4gICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCByZXMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzeW5jID0gZmFsc2U7XG4gICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdcbiAgICAgID8gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGlzQXN5bmNQbGFjZWhvbGRlciAobm9kZSkge1xuICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3Rvcnlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgKGlzRGVmKGMuY29tcG9uZW50T3B0aW9ucykgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpKSkge1xuICAgICAgICByZXR1cm4gY1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG4gIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcbiAgfVxufVxuXG52YXIgdGFyZ2V0O1xuXG5mdW5jdGlvbiBhZGQgKGV2ZW50LCBmbiwgb25jZSkge1xuICBpZiAob25jZSkge1xuICAgIHRhcmdldC4kb25jZShldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG4gIHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG4gIHZtLFxuICBsaXN0ZW5lcnMsXG4gIG9sZExpc3RlbmVyc1xuKSB7XG4gIHRhcmdldCA9IHZtO1xuICB1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIHZtKTtcbiAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gIHZhciBob29rUkUgPSAvXmhvb2s6LztcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgdm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBmdW5jdGlvbiBvbiAoKSB7XG4gICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICBmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb24uZm4gPSBmbjtcbiAgICB2bS4kb24oZXZlbnQsIG9uKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGFsbFxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gYXJyYXkgb2YgZXZlbnRzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzJDEuJG9mZihldmVudFtpXSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIHNwZWNpZmljIGV2ZW50XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmICghY2JzKSB7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKCFmbikge1xuICAgICAgdm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmIChmbikge1xuICAgICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgICAgdmFyIGNiO1xuICAgICAgdmFyIGkkMSA9IGNicy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaSQxLS0pIHtcbiAgICAgICAgY2IgPSBjYnNbaSQxXTtcbiAgICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgICBjYnMuc3BsaWNlKGkkMSwgMSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgdGlwKFxuICAgICAgICAgIFwiRXZlbnQgXFxcIlwiICsgbG93ZXJDYXNlRXZlbnQgKyBcIlxcXCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgXCIgK1xuICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcbiAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcbiAgICAgICAgICBcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcIiArXG4gICAgICAgICAgXCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZXZlbnQgaGFuZGxlciBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xufVxuXG4vKiAgKi9cblxuXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICB2YXIgc2xvdHMgPSB7fTtcbiAgaWYgKCFjaGlsZHJlbikge1xuICAgIHJldHVybiBzbG90c1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xuICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICB9XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICBkZWxldGUgc2xvdHNbbmFtZSQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXNcbikge1xuICByZXMgPSByZXMgfHwge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zW2ldKSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKGZuc1tpXSwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2Zuc1tpXS5rZXldID0gZm5zW2ldLmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgICAvLyBubyBuZWVkIGZvciB0aGUgcmVmIG5vZGVzIGFmdGVyIGluaXRpYWwgcGF0Y2hcbiAgICAgIC8vIHRoaXMgcHJldmVudHMga2VlcGluZyBhIGRldGFjaGVkIERPTSB0cmVlIGluIG1lbW9yeSAoIzU4NTEpXG4gICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCBudWxsLCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgdm0uJGF0dHJzID0gcGFyZW50Vm5vZGUuZGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdDtcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICB2YXIgcHJvcE9wdGlvbnMgPSB2bS4kb3B0aW9ucy5wcm9wczsgLy8gd3RmIGZsb3c/XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG5cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgbGlmZWN5Y2xlIGhvb2tzXG4gIHB1c2hUYXJnZXQoKTtcbiAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gIGlmIChoYW5kbGVycykge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBoYW5kbGVyc1tpXS5jYWxsKHZtKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgdm0uJGVtaXQoJ2hvb2s6JyArIGhvb2spO1xuICB9XG4gIHBvcFRhcmdldCgpO1xufVxuXG4vKiAgKi9cblxuXG52YXIgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxudmFyIHF1ZXVlID0gW107XG52YXIgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcbnZhciBoYXMgPSB7fTtcbnZhciBjaXJjdWxhciA9IHt9O1xudmFyIHdhaXRpbmcgPSBmYWxzZTtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuICBpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIGhhcyA9IHt9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNpcmN1bGFyID0ge307XG4gIH1cbiAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuICBmbHVzaGluZyA9IHRydWU7XG4gIHZhciB3YXRjaGVyLCBpZDtcblxuICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XG4gIC8vIDEuIENvbXBvbmVudHMgYXJlIHVwZGF0ZWQgZnJvbSBwYXJlbnQgdG8gY2hpbGQuIChiZWNhdXNlIHBhcmVudCBpcyBhbHdheXNcbiAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG4gIC8vICAgIHVzZXIgd2F0Y2hlcnMgYXJlIGNyZWF0ZWQgYmVmb3JlIHRoZSByZW5kZXIgd2F0Y2hlcilcbiAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuICBxdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG5cbiAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gIC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBxdWV1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIGlkID0gd2F0Y2hlci5pZDtcbiAgICBoYXNbaWRdID0gbnVsbDtcbiAgICB3YXRjaGVyLnJ1bigpO1xuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcbiAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgaWYgKGNpcmN1bGFyW2lkXSA+IE1BWF9VUERBVEVfQ09VTlQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXG4gICAgICAgICAgICB3YXRjaGVyLnVzZXJcbiAgICAgICAgICAgICAgPyAoXCJpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKVxuICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiXG4gICAgICAgICAgKSxcbiAgICAgICAgICB3YXRjaGVyLnZtXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8ga2VlcCBjb3BpZXMgb2YgcG9zdCBxdWV1ZXMgYmVmb3JlIHJlc2V0dGluZyBzdGF0ZVxuICB2YXIgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICB2YXIgdXBkYXRlZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcblxuICByZXNldFNjaGVkdWxlclN0YXRlKCk7XG5cbiAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXG4gIGNhbGxBY3RpdmF0ZWRIb29rcyhhY3RpdmF0ZWRRdWV1ZSk7XG4gIGNhbGxVcGRhdGVkSG9va3ModXBkYXRlZFF1ZXVlKTtcblxuICAvLyBkZXZ0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxVcGRhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIHZhciBpID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICB2YXIgdm0gPSB3YXRjaGVyLnZtO1xuICAgIGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gIC8vIHJlbHkgb24gY2hlY2tpbmcgd2hldGhlciBpdCdzIGluIGFuIGluYWN0aXZlIHRyZWUgKGUuZy4gcm91dGVyLXZpZXcpXG4gIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbn1cblxuZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICB9XG59XG5cbi8qKlxuICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xuICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gKi9cbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlciAod2F0Y2hlcikge1xuICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICBpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzW2lkXSA9IHRydWU7XG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgLy8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cbiAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgd2FpdGluZyA9IHRydWU7XG4gICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciB1aWQkMSA9IDA7XG5cbi8qKlxuICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuICogVGhpcyBpcyB1c2VkIGZvciBib3RoIHRoZSAkd2F0Y2goKSBhcGkgYW5kIGRpcmVjdGl2ZXMuXG4gKi9cbnZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG4gIHZtLFxuICBleHBPckZuLFxuICBjYixcbiAgb3B0aW9ucyxcbiAgaXNSZW5kZXJXYXRjaGVyXG4pIHtcbiAgdGhpcy52bSA9IHZtO1xuICBpZiAoaXNSZW5kZXJXYXRjaGVyKSB7XG4gICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xuICB9XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIGlmIChvcHRpb25zKSB7XG4gICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG4gICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kZWVwID0gdGhpcy51c2VyID0gdGhpcy5sYXp5ID0gdGhpcy5zeW5jID0gZmFsc2U7XG4gIH1cbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlkID0gKyt1aWQkMTsgLy8gdWlkIGZvciBiYXRjaGluZ1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gIHRoaXMuZGVwcyA9IFtdO1xuICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICA/IGV4cE9yRm4udG9TdHJpbmcoKVxuICAgIDogJyc7XG4gIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICBpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgdGhpcy5nZXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG4gICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHRoaXMuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHtcbiAgcHVzaFRhcmdldCh0aGlzKTtcbiAgdmFyIHZhbHVlO1xuICB2YXIgdm0gPSB0aGlzLnZtO1xuICB0cnkge1xuICAgIHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgLy8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG4gICAgaWYgKHRoaXMuZGVlcCkge1xuICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgIH1cbiAgICBwb3BUYXJnZXQoKTtcbiAgICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlXG59O1xuXG4vKipcbiAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG4gIHZhciBpZCA9IGRlcC5pZDtcbiAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgdGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcbiAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGRlcCA9IHRoaXMkMS5kZXBzW2ldO1xuICAgIGlmICghdGhpcyQxLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgZGVwLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgfVxuICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG4gIHRoaXMubmV3RGVwSWRzID0gdG1wO1xuICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICB0bXAgPSB0aGlzLmRlcHM7XG4gIHRoaXMuZGVwcyA9IHRoaXMubmV3RGVwcztcbiAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodGhpcy5sYXp5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgdGhpcy5ydW4oKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gIHRoaXMuZGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdGhpcyQxLmRlcHNbaV0uZGVwZW5kKCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG4gICAgLy8gaWYgdGhlIHZtIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzJDEuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyogICovXG5cbnZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBub29wLFxuICBzZXQ6IG5vb3Bcbn07XG5cbmZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG4gIH07XG4gIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcbiAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICBpZiAob3B0cy5tZXRob2RzKSB7IGluaXRNZXRob2RzKHZtLCBvcHRzLm1ldGhvZHMpOyB9XG4gIGlmIChvcHRzLmRhdGEpIHtcbiAgICBpbml0RGF0YSh2bSk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuICB9XG4gIGlmIChvcHRzLmNvbXB1dGVkKSB7IGluaXRDb21wdXRlZCh2bSwgb3B0cy5jb21wdXRlZCk7IH1cbiAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICB2YXIgcHJvcHMgPSB2bS5fcHJvcHMgPSB7fTtcbiAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW107XG4gIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gIGlmICghaXNSb290KSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgfVxuICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgIGtleXMucHVzaChrZXkpO1xuICAgIHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBkZWZpbmVSZWFjdGl2ZShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodm0uJHBhcmVudCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgIC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG4gICAgLy8gaW5zdGFudGlhdGlvbiBoZXJlLlxuICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgIHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcbiAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5KTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGRhdGEgZ2V0dGVyc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH0gZmluYWxseSB7XG4gICAgcG9wVGFyZ2V0KCk7XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NTUikge1xuICAgICAgLy8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cbiAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgdm0sXG4gICAgICAgIGdldHRlciB8fCBub29wLFxuICAgICAgICBub29wLFxuICAgICAgICBjb21wdXRlZFdhdGNoZXJPcHRpb25zXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcbiAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICBpZiAoIShrZXkgaW4gdm0pKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkIChcbiAgdGFyZ2V0LFxuICBrZXksXG4gIHVzZXJEZWZcbikge1xuICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHNob3VsZENhY2hlXG4gICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgIDogdXNlckRlZjtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gc2hvdWxkQ2FjaGUgJiYgdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogdXNlckRlZi5nZXRcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgID8gdXNlckRlZi5zZXRcbiAgICAgIDogbm9vcDtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAoXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgd2FzIGFzc2lnbmVkIHRvIGJ1dCBpdCBoYXMgbm8gc2V0dGVyLlwiKSxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuICAgIHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIHdhdGNoZXIuZGVwZW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgK1xuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGhhbmRsZXIsXG4gIG9wdGlvbnNcbikge1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICByZXR1cm4gdm0uJHdhdGNoKGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcHJvcHMnLCBwcm9wc0RlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoY2IpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpXG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuICB2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG4gIGlmIChwcm92aWRlKSB7XG4gICAgdm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcbiAgICAgID8gcHJvdmlkZS5jYWxsKHZtKVxuICAgICAgOiBwcm92aWRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcHJvdmlkZWQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgPyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpbmplY3QsIGtleSkuZW51bWVyYWJsZVxuICAgICAgfSlcbiAgICAgIDogT2JqZWN0LmtleXMoaW5qZWN0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICB2YXIgc291cmNlID0gdm07XG4gICAgICB3aGlsZSAoc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBpbmplY3Rba2V5XSkge1xuICAgICAgICAgIHZhciBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcbiAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRGVmKHJldCkpIHtcbiAgICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICB2YXIgbm9kZXM7XG4gIGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNPYmplY3QoYmluZE9iamVjdCkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgIH1cbiAgICBub2RlcyA9IHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2s7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3ROb2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdO1xuICAgIC8vIHdhcm4gZHVwbGljYXRlIHNsb3QgdXNhZ2VcbiAgICBpZiAoc2xvdE5vZGVzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzbG90Tm9kZXMuX3JlbmRlcmVkKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJEdXBsaWNhdGUgcHJlc2VuY2Ugb2Ygc2xvdCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGZvdW5kIGluIHRoZSBzYW1lIHJlbmRlciB0cmVlIFwiICtcbiAgICAgICAgICBcIi0gdGhpcyB3aWxsIGxpa2VseSBjYXVzZSByZW5kZXIgZXJyb3JzLlwiLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHNsb3ROb2Rlcy5fcmVuZGVyZWQgPSB0cnVlO1xuICAgIH1cbiAgICBub2RlcyA9IHNsb3ROb2RlcyB8fCBmYWxsYmFjaztcbiAgfVxuXG4gIHZhciB0YXJnZXQgPSBwcm9wcyAmJiBwcm9wcy5zbG90O1xuICBpZiAodGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJywgeyBzbG90OiB0YXJnZXQgfSwgbm9kZXMpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGVzXG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG4gIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGlzS2V5Tm90TWF0Y2ggKGV4cGVjdCwgYWN0dWFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdCkpIHtcbiAgICByZXR1cm4gZXhwZWN0LmluZGV4T2YoYWN0dWFsKSA9PT0gLTFcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZXhwZWN0ICE9PSBhY3R1YWxcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqIGV4cG9zZWQgYXMgVnVlLnByb3RvdHlwZS5fa1xuICogcGFzc2luZyBpbiBldmVudEtleU5hbWUgYXMgbGFzdCBhcmd1bWVudCBzZXBhcmF0ZWx5IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbktleUNvZGUsXG4gIGV2ZW50S2V5TmFtZSxcbiAgYnVpbHRJbktleU5hbWVcbikge1xuICB2YXIgbWFwcGVkS2V5Q29kZSA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5LZXlDb2RlO1xuICBpZiAoYnVpbHRJbktleU5hbWUgJiYgZXZlbnRLZXlOYW1lICYmICFjb25maWcua2V5Q29kZXNba2V5XSkge1xuICAgIHJldHVybiBpc0tleU5vdE1hdGNoKGJ1aWx0SW5LZXlOYW1lLCBldmVudEtleU5hbWUpXG4gIH0gZWxzZSBpZiAobWFwcGVkS2V5Q29kZSkge1xuICAgIHJldHVybiBpc0tleU5vdE1hdGNoKG1hcHBlZEtleUNvZGUsIGV2ZW50S2V5Q29kZSlcbiAgfSBlbHNlIGlmIChldmVudEtleU5hbWUpIHtcbiAgICByZXR1cm4gaHlwaGVuYXRlKGV2ZW50S2V5TmFtZSkgIT09IGtleVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyAoXG4gIGRhdGEsXG4gIHRhZyxcbiAgdmFsdWUsXG4gIGFzUHJvcCxcbiAgaXNTeW5jXG4pIHtcbiAgaWYgKHZhbHVlKSB7XG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xhc3MnIHx8XG4gICAgICAgICAga2V5ID09PSAnc3R5bGUnIHx8XG4gICAgICAgICAgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpXG4gICAgICAgICkge1xuICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShrZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgIG9uWyhcInVwZGF0ZTpcIiArIGtleSldID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gJGV2ZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgbG9vcCgga2V5ICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIHZhciBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XG4gIHZhciB0cmVlID0gY2FjaGVkW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiB0cmVlXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKFxuICAgIHRoaXMuX3JlbmRlclByb3h5LFxuICAgIG51bGwsXG4gICAgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xuICApO1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICByZXR1cm4gdHJlZVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UgKFxuICB0cmVlLFxuICBpbmRleCxcbiAga2V5XG4pIHtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICB0cmVlLFxuICBrZXksXG4gIGlzT25jZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3Ytb24gd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvbiA9IGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XG4gICAgICAgIHZhciBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgb25ba2V5XSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBvdXJzKSA6IG91cnM7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbnN0YWxsUmVuZGVySGVscGVycyAodGFyZ2V0KSB7XG4gIHRhcmdldC5fbyA9IG1hcmtPbmNlO1xuICB0YXJnZXQuX24gPSB0b051bWJlcjtcbiAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XG4gIHRhcmdldC5fbCA9IHJlbmRlckxpc3Q7XG4gIHRhcmdldC5fdCA9IHJlbmRlclNsb3Q7XG4gIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XG4gIHRhcmdldC5faSA9IGxvb3NlSW5kZXhPZjtcbiAgdGFyZ2V0Ll9tID0gcmVuZGVyU3RhdGljO1xuICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xuICB0YXJnZXQuX2sgPSBjaGVja0tleUNvZGVzO1xuICB0YXJnZXQuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgdGFyZ2V0Ll9lID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgdGFyZ2V0Ll91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gRnVuY3Rpb25hbFJlbmRlckNvbnRleHQgKFxuICBkYXRhLFxuICBwcm9wcyxcbiAgY2hpbGRyZW4sXG4gIHBhcmVudCxcbiAgQ3RvclxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gIC8vIGdldHMgYSB1bmlxdWUgY29udGV4dCAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0IG5hbWVkIHNsb3QgY2hlY2tcbiAgdmFyIGNvbnRleHRWbTtcbiAgaWYgKGhhc093bihwYXJlbnQsICdfdWlkJykpIHtcbiAgICBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgY29udGV4dFZtLl9vcmlnaW5hbCA9IHBhcmVudDtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY29udGV4dCB2bSBwYXNzZWQgaW4gaXMgYSBmdW5jdGlvbmFsIGNvbnRleHQgYXMgd2VsbC5cbiAgICAvLyBpbiB0aGlzIGNhc2Ugd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgYXJlIGFibGUgdG8gZ2V0IGEgaG9sZCB0byB0aGVcbiAgICAvLyByZWFsIGNvbnRleHQgaW5zdGFuY2UuXG4gICAgY29udGV4dFZtID0gcGFyZW50O1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHBhcmVudCA9IHBhcmVudC5fb3JpZ2luYWw7XG4gIH1cbiAgdmFyIGlzQ29tcGlsZWQgPSBpc1RydWUob3B0aW9ucy5fY29tcGlsZWQpO1xuICB2YXIgbmVlZE5vcm1hbGl6YXRpb24gPSAhaXNDb21waWxlZDtcblxuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMubGlzdGVuZXJzID0gZGF0YS5vbiB8fCBlbXB0eU9iamVjdDtcbiAgdGhpcy5pbmplY3Rpb25zID0gcmVzb2x2ZUluamVjdChvcHRpb25zLmluamVjdCwgcGFyZW50KTtcbiAgdGhpcy5zbG90cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgcGFyZW50KTsgfTtcblxuICAvLyBzdXBwb3J0IGZvciBjb21waWxlZCBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChpc0NvbXBpbGVkKSB7XG4gICAgLy8gZXhwb3NpbmcgJG9wdGlvbnMgZm9yIHJlbmRlclN0YXRpYygpXG4gICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgLy8gcHJlLXJlc29sdmUgc2xvdHMgZm9yIHJlbmRlclNsb3QoKVxuICAgIHRoaXMuJHNsb3RzID0gdGhpcy5zbG90cygpO1xuICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gZGF0YS5zY29wZWRTbG90cyB8fCBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XG4gICAgdGhpcy5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xuICAgICAgaWYgKHZub2RlICYmICFBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgfVxufVxuXG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0Vm0sXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG5cbiAgdmFyIHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0Vm0sXG4gICAgQ3RvclxuICApO1xuXG4gIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMpXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICB2YXIgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc1tpXSA9IGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGVzW2ldLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0ICh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zKSB7XG4gIC8vICM3ODE3IGNsb25lIG5vZGUgYmVmb3JlIHNldHRpbmcgZm5Db250ZXh0LCBvdGhlcndpc2UgaWYgdGhlIG5vZGUgaXMgcmV1c2VkXG4gIC8vIChlLmcuIGl0IHdhcyBmcm9tIGEgY2FjaGVkIG5vcm1hbCBzbG90KSB0aGUgZm5Db250ZXh0IGNhdXNlcyBuYW1lZCBzbG90c1xuICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cbiAgdmFyIGNsb25lID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgY2xvbmUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAgaWYgKGRhdGEuc2xvdCkge1xuICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICB9XG4gIHJldHVybiBjbG9uZVxufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuICB9XG59XG5cbi8qICAqL1xuXG5cblxuXG4vLyBSZWdpc3RlciB0aGUgY29tcG9uZW50IGhvb2sgdG8gd2VleCBuYXRpdmUgcmVuZGVyIGVuZ2luZS5cbi8vIFRoZSBob29rIHdpbGwgYmUgdHJpZ2dlcmVkIGJ5IG5hdGl2ZSwgbm90IGphdmFzY3JpcHQuXG5cblxuLy8gVXBkYXRlcyB0aGUgc3RhdGUgb2YgdGhlIGNvbXBvbmVudCB0byB3ZWV4IG5hdGl2ZSByZW5kZXIgZW5naW5lLlxuXG4vKiAgKi9cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL0hhbmtzMTAxMDAvd2VleC1uYXRpdmUtZGlyZWN0aXZlL3RyZWUvbWFzdGVyL2NvbXBvbmVudFxuXG4vLyBsaXN0ZW5pbmcgb24gbmF0aXZlIGNhbGxiYWNrXG5cbi8qICAqL1xuXG4vKiAgKi9cblxuLy8gaW5saW5lIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbnZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0IChcbiAgICB2bm9kZSxcbiAgICBoeWRyYXRpbmcsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbVxuICApIHtcbiAgICBpZiAoXG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmVcbiAgICApIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICB2bm9kZSxcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UsXG4gICAgICAgIHBhcmVudEVsbSxcbiAgICAgICAgcmVmRWxtXG4gICAgICApO1xuICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICB2YXIgYXN5bmNGYWN0b3J5O1xuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3RvciwgY29udGV4dCk7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXG4gICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihcbiAgICAgICAgYXN5bmNGYWN0b3J5LFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdGFnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcbiAgICBkYXRhID0ge307XG4gICAgaWYgKHNsb3QpIHtcbiAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5zdGFsbCBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIGluc3RhbGxDb21wb25lbnRIb29rcyhkYXRhKTtcblxuICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICB2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcbiAgdmFyIHZub2RlID0gbmV3IFZOb2RlKFxuICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXG4gICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9LFxuICAgIGFzeW5jRmFjdG9yeVxuICApO1xuXG4gIC8vIFdlZXggc3BlY2lmaWM6IGludm9rZSByZWN5Y2xlLWxpc3Qgb3B0aW1pemVkIEByZW5kZXIgZnVuY3Rpb24gZm9yXG4gIC8vIGV4dHJhY3RpbmcgY2VsbC1zbG90IHRlbXBsYXRlLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vSGFua3MxMDEwMC93ZWV4LW5hdGl2ZS1kaXJlY3RpdmUvdHJlZS9tYXN0ZXIvY29tcG9uZW50XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50LCAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbiAgcGFyZW50RWxtLFxuICByZWZFbG1cbikge1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBfcGFyZW50RWxtOiBwYXJlbnRFbG0gfHwgbnVsbCxcbiAgICBfcmVmRWxtOiByZWZFbG0gfHwgbnVsbFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gaW5zdGFsbENvbXBvbmVudEhvb2tzIChkYXRhKSB7XG4gIHZhciBob29rcyA9IGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgaG9va3Nba2V5XSA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgfVxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnOyhkYXRhLnByb3BzIHx8IChkYXRhLnByb3BzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIGlmIChpc0RlZihvbltldmVudF0pKSB7XG4gICAgb25bZXZlbnRdID0gW2RhdGEubW9kZWwuY2FsbGJhY2tdLmNvbmNhdChvbltldmVudF0pO1xuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZVxuKSB7XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIgKyAoSlNPTi5zdHJpbmdpZnkoZGF0YSkpICsgXCJcXG5cIiArXG4gICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgIGNvbnRleHRcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyBvYmplY3Qgc3ludGF4IGluIHYtYmluZFxuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5pcykpIHtcbiAgICB0YWcgPSBkYXRhLmlzO1xuICB9XG4gIGlmICghdGFnKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxuICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KVxuICApIHtcbiAgICB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgdXNpbmcgbm9uLXByaW1pdGl2ZSB2YWx1ZSBhcyBrZXksICcgK1xuICAgICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvLyBzdXBwb3J0IHNpbmdsZSBmdW5jdGlvbiBjaGlsZHJlbiBhcyBkZWZhdWx0IHNjb3BlZCBzbG90XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfVxuICB2YXIgdm5vZGUsIG5zO1xuICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgQ3RvcjtcbiAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuICAgICAgLy8gY2hlY2sgYXQgcnVudGltZSBiZWNhdXNlIGl0IG1heSBnZXQgYXNzaWduZWQgYSBuYW1lc3BhY2Ugd2hlbiBpdHNcbiAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG4gICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQodGFnLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbik7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgaWYgKGlzRGVmKG5zKSkgeyBhcHBseU5TKHZub2RlLCBucyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHsgcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSk7IH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlOUyAodm5vZGUsIG5zLCBmb3JjZSkge1xuICB2bm9kZS5ucyA9IG5zO1xuICBpZiAodm5vZGUudGFnID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3RcbiAgICBucyA9IHVuZGVmaW5lZDtcbiAgICBmb3JjZSA9IHRydWU7XG4gIH1cbiAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIChcbiAgICAgICAgaXNVbmRlZihjaGlsZC5ucykgfHwgKGlzVHJ1ZShmb3JjZSkgJiYgY2hpbGQudGFnICE9PSAnc3ZnJykpKSB7XG4gICAgICAgIGFwcGx5TlMoY2hpbGQsIG5zLCBmb3JjZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHJlZiAjNTMxOFxuLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSBwYXJlbnQgcmUtcmVuZGVyIHdoZW4gZGVlcCBiaW5kaW5ncyBsaWtlIDpzdHlsZSBhbmRcbi8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXG5mdW5jdGlvbiByZWdpc3RlckRlZXBCaW5kaW5ncyAoZGF0YSkge1xuICBpZiAoaXNPYmplY3QoZGF0YS5zdHlsZSkpIHtcbiAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcbiAgfVxuICBpZiAoaXNPYmplY3QoZGF0YS5jbGFzcykpIHtcbiAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcbiAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICB2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICB2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcbiAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcbiAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgdm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuICAvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cbiAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gIHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuXG4gIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgdmFyIHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckYXR0cnMnLCBwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgZnVuY3Rpb24gKCkge1xuICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgIH0sIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgLy8gaW5zdGFsbCBydW50aW1lIGNvbnZlbmllbmNlIGhlbHBlcnNcbiAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgLy8gcmVzZXQgX3JlbmRlcmVkIGZsYWcgb24gc2xvdHMgZm9yIGR1cGxpY2F0ZSBzbG90IGNoZWNrXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHZtLiRzbG90c1trZXldLl9yZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfcGFyZW50Vm5vZGUpIHtcbiAgICAgIHZtLiRzY29wZWRTbG90cyA9IF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IGVtcHR5T2JqZWN0O1xuICAgIH1cblxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh2bS4kb3B0aW9ucy5yZW5kZXJFcnJvcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyRXJyb3JcIik7XG4gICAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDMgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQzKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgdmFyIHBhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xuXG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBvcHRzLnByb3BzRGF0YSA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnM7XG4gIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMudGFnO1xuXG4gIGlmIChvcHRpb25zLnJlbmRlcikge1xuICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgb3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICBpZiAoQ3Rvci5zdXBlcikge1xuICAgIHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxuICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG4gICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcbiAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICBpZiAobW9kaWZpZWRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9uc1xufVxuXG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gIHZhciBtb2RpZmllZDtcbiAgdmFyIGxhdGVzdCA9IEN0b3Iub3B0aW9ucztcbiAgdmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xuICB2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgaWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG4gICAgICBtb2RpZmllZFtrZXldID0gZGVkdXBlKGxhdGVzdFtrZXldLCBleHRlbmRlZFtrZXldLCBzZWFsZWRba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RpZmllZFxufVxuXG5mdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgZXh0ZW5kZWQsIHNlYWxlZCkge1xuICAvLyBjb21wYXJlIGxhdGVzdCBhbmQgc2VhbGVkIHRvIGVuc3VyZSBsaWZlY3ljbGUgaG9va3Mgd29uJ3QgYmUgZHVwbGljYXRlZFxuICAvLyBiZXR3ZWVuIG1lcmdlc1xuICBpZiAoQXJyYXkuaXNBcnJheShsYXRlc3QpKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHNlYWxlZCA9IEFycmF5LmlzQXJyYXkoc2VhbGVkKSA/IHNlYWxlZCA6IFtzZWFsZWRdO1xuICAgIGV4dGVuZGVkID0gQXJyYXkuaXNBcnJheShleHRlbmRlZCkgPyBleHRlbmRlZCA6IFtleHRlbmRlZF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRlc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHB1c2ggb3JpZ2luYWwgb3B0aW9ucyBhbmQgbm90IHNlYWxlZCBvcHRpb25zIHRvIGV4Y2x1ZGUgZHVwbGljYXRlZCBvcHRpb25zXG4gICAgICBpZiAoZXh0ZW5kZWQuaW5kZXhPZihsYXRlc3RbaV0pID49IDAgfHwgc2VhbGVkLmluZGV4T2YobGF0ZXN0W2ldKSA8IDApIHtcbiAgICAgICAgcmVzLnB1c2gobGF0ZXN0W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsYXRlc3RcbiAgfVxufVxuXG5mdW5jdGlvbiBWdWUgKG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUpXG4gICkge1xuICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgfVxuICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuXG5pbml0TWl4aW4oVnVlKTtcbnN0YXRlTWl4aW4oVnVlKTtcbmV2ZW50c01peGluKFZ1ZSk7XG5saWZlY3ljbGVNaXhpbihWdWUpO1xucmVuZGVyTWl4aW4oVnVlKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSkge1xuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGUgPT09ICdjb21wb25lbnQnKSB7XG4gICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xuICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgdmFyIGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGNhY2hlZCQkMS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlW2tleV0gPSBudWxsO1xuICByZW1vdmUoa2V5cywga2V5KTtcbn1cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlLCBrZXksIHRoaXMkMS5rZXlzKTtcbiAgICB9XG4gIH0sXG5cbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLiR3YXRjaCgnaW5jbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICB9KTtcbiAgICB0aGlzLiR3YXRjaCgnZXhjbHVkZScsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgIHZhciBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xuICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICB2YXIgaW5jbHVkZSA9IHJlZi5pbmNsdWRlO1xuICAgICAgdmFyIGV4Y2x1ZGUgPSByZWYuZXhjbHVkZTtcbiAgICAgIGlmIChcbiAgICAgICAgLy8gbm90IGluY2x1ZGVkXG4gICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgIChleGNsdWRlICYmIG5hbWUgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdm5vZGVcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZiQxID0gdGhpcztcbiAgICAgIHZhciBjYWNoZSA9IHJlZiQxLmNhY2hlO1xuICAgICAgdmFyIGtleXMgPSByZWYkMS5rZXlzO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAvLyBtYWtlIGN1cnJlbnQga2V5IGZyZXNoZXN0XG4gICAgICAgIHJlbW92ZShrZXlzLCBrZXkpO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSB2bm9kZTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIC8vIHBydW5lIG9sZGVzdCBlbnRyeVxuICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcbiAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKVxuICB9XG59XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuICAvLyBjb25maWdcbiAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICBjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICB9XG59KTtcblxuLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnRnVuY3Rpb25hbFJlbmRlckNvbnRleHQnLCB7XG4gIHZhbHVlOiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dFxufSk7XG5cblZ1ZS52ZXJzaW9uID0gJzIuNS4xNic7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgIDogcGFyZW50LmNsYXNzXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2xhc3MgKFxuICBzdGF0aWNDbGFzcyxcbiAgZHluYW1pY0NsYXNzXG4pIHtcbiAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIHN0cmluZ2lmaWVkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlW2tleV0pIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5cbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG52YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbnZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgLy8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3RcbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gc2V0U3R5bGVTY29wZSAobm9kZSwgc2NvcGVJZCkge1xuICBub2RlLnNldEF0dHJpYnV0ZShzY29wZUlkLCAnJyk7XG59XG5cblxudmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuXHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG5cdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0dGFnTmFtZTogdGFnTmFtZSxcblx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRzZXRTdHlsZVNjb3BlOiBzZXRTdHlsZVNjb3BlXG59KTtcblxuLyogICovXG5cbnZhciByZWYgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFpc0RlZihrZXkpKSB7IHJldHVybiB9XG5cbiAgdmFyIHZtID0gdm5vZGUuY29udGV4dDtcbiAgdmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgaWYgKGlzUmVtb3ZhbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgfSBlbHNlIGlmIChyZWZzW2tleV0gPT09IHJlZikge1xuICAgICAgcmVmc1trZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgcmVmc1trZXldID0gW3JlZl07XG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICByZWZzW2tleV0ucHVzaChyZWYpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbnZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5mdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgcmV0dXJuIChcbiAgICBhLmtleSA9PT0gYi5rZXkgJiYgKFxuICAgICAgKFxuICAgICAgICBhLnRhZyA9PT0gYi50YWcgJiZcbiAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICAgICAgc2FtZUlucHV0VHlwZShhLCBiKVxuICAgICAgKSB8fCAoXG4gICAgICAgIGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiZcbiAgICAgICAgYS5hc3luY0ZhY3RvcnkgPT09IGIuYXN5bmNGYWN0b3J5ICYmXG4gICAgICAgIGlzVW5kZWYoYi5hc3luY0ZhY3RvcnkuZXJyb3IpXG4gICAgICApXG4gICAgKVxuICApXG59XG5cbmZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcbiAgaWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGk7XG4gIHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG4gIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgaXNUZXh0SW5wdXRUeXBlKHR5cGVBKSAmJiBpc1RleHRJbnB1dFR5cGUodHlwZUIpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwga2V5O1xuICB2YXIgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICB2YXIgaSwgajtcbiAgdmFyIGNicyA9IHt9O1xuXG4gIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcbiAgICBjYnNbaG9va3NbaV1dID0gW107XG4gICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgY2JzW2hvb2tzW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3NbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgcmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgIGZ1bmN0aW9uIHJlbW92ZSAoKSB7XG4gICAgICBpZiAoLS1yZW1vdmUubGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgIHJldHVybiByZW1vdmVcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG4gICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCQkMSAodm5vZGUsIGluVlByZSkge1xuICAgIHJldHVybiAoXG4gICAgICAhaW5WUHJlICYmXG4gICAgICAhdm5vZGUubnMgJiZcbiAgICAgICEoXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmXG4gICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShmdW5jdGlvbiAoaWdub3JlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzUmVnRXhwKGlnbm9yZSlcbiAgICAgICAgICAgID8gaWdub3JlLnRlc3Qodm5vZGUudGFnKVxuICAgICAgICAgICAgOiBpZ25vcmUgPT09IHZub2RlLnRhZ1xuICAgICAgICB9KVxuICAgICAgKSAmJlxuICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKVxuICAgIClcbiAgfVxuXG4gIHZhciBjcmVhdGluZ0VsbUluVlByZSA9IDA7XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxtIChcbiAgICB2bm9kZSxcbiAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgcGFyZW50RWxtLFxuICAgIHJlZkVsbSxcbiAgICBuZXN0ZWQsXG4gICAgb3duZXJBcnJheSxcbiAgICBpbmRleFxuICApIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZWxtKSAmJiBpc0RlZihvd25lckFycmF5KSkge1xuICAgICAgLy8gVGhpcyB2bm9kZSB3YXMgdXNlZCBpbiBhIHByZXZpb3VzIHJlbmRlciFcbiAgICAgIC8vIG5vdyBpdCdzIHVzZWQgYXMgYSBuZXcgbm9kZSwgb3ZlcndyaXRpbmcgaXRzIGVsbSB3b3VsZCBjYXVzZVxuICAgICAgLy8gcG90ZW50aWFsIHBhdGNoIGVycm9ycyBkb3duIHRoZSByb2FkIHdoZW4gaXQncyB1c2VkIGFzIGFuIGluc2VydGlvblxuICAgICAgLy8gcmVmZXJlbmNlIG5vZGUuIEluc3RlYWQsIHdlIGNsb25lIHRoZSBub2RlIG9uLWRlbWFuZCBiZWZvcmUgY3JlYXRpbmdcbiAgICAgIC8vIGFzc29jaWF0ZWQgRE9NIGVsZW1lbnQgZm9yIGl0LlxuICAgICAgdm5vZGUgPSBvd25lckFycmF5W2luZGV4XSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIH1cblxuICAgIHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG4gICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGNyZWF0aW5nRWxtSW5WUHJlKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChyZWYkJDEucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSwgY2hpbGRyZW4sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIGlmIChpc0RlZihpID0gdm5vZGUuZm5TY29wZUlkKSkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xuICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaSAhPT0gdm5vZGUuZm5Db250ZXh0ICYmXG4gICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcbiAgICApIHtcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIGZhbHNlLCB2bm9kZXMsIHN0YXJ0SWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpXG4gICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICA6IGZpbmRJZHhJbk9sZChuZXdTdGFydFZub2RlLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlVG9Nb3ZlID0gb2xkQ2hbaWR4SW5PbGRdO1xuICAgICAgICAgIGlmIChzYW1lVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBmYWxzZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICAgIHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcbiAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgfSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRHVwbGljYXRlS2V5cyAoY2hpbGRyZW4pIHtcbiAgICB2YXIgc2VlbktleXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdm5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXk7XG4gICAgICBpZiAoaXNEZWYoa2V5KSkge1xuICAgICAgICBpZiAoc2VlbktleXNba2V5XSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJ1wiICsga2V5ICsgXCInLiBUaGlzIG1heSBjYXVzZSBhbiB1cGRhdGUgZXJyb3IuXCIpLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VlbktleXNba2V5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQgKG5vZGUsIG9sZENoLCBzdGFydCwgZW5kKSB7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBjID0gb2xkQ2hbaV07XG4gICAgICBpZiAoaXNEZWYoYykgJiYgc2FtZVZub2RlKG5vZGUsIGMpKSB7IHJldHVybiBpIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICBpZiAoaXNUcnVlKG9sZFZub2RlLmlzQXN5bmNQbGFjZWhvbGRlcikpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgaXNUcnVlKG9sZFZub2RlLmlzU3RhdGljKSAmJlxuICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgIChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuICAgICkge1xuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucHJlcGF0Y2gpKSB7XG4gICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChvbGRDaCAhPT0gY2gpIHsgdXBkYXRlQ2hpbGRyZW4oZWxtLCBvbGRDaCwgY2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIGNoLCAwLCBjaC5sZW5ndGggLSAxLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkge1xuICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2xkVm5vZGUudGV4dCAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGh5ZHJhdGlvbkJhaWxlZCA9IGZhbHNlO1xuICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICAvLyBOb3RlOiBzdHlsZSBpcyBleGNsdWRlZCBiZWNhdXNlIGl0IHJlbGllcyBvbiBpbml0aWFsIGNsb25lIGZvciBmdXR1cmVcbiAgLy8gZGVlcCB1cGRhdGVzICgjNzA2MykuXG4gIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgLy8gTm90ZTogdGhpcyBpcyBhIGJyb3dzZXItb25seSBmdW5jdGlvbiBzbyB3ZSBjYW4gYXNzdW1lIGVsbXMgYXJlIERPTSBub2Rlcy5cbiAgZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpblZQcmUgPSBpblZQcmUgfHwgKGRhdGEgJiYgZGF0YS5wcmUpO1xuICAgIHZub2RlLmVsbSA9IGVsbTtcblxuICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XG4gICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gYXNzZXJ0IG5vZGUgbWF0Y2hcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSwgaW5WUHJlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChpc0RlZihjaGlsZHJlbikpIHtcbiAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2LWh0bWwgYW5kIGRvbVByb3BzOiBpbm5lckhUTUxcbiAgICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEpICYmIGlzRGVmKGkgPSBpLmRvbVByb3BzKSAmJiBpc0RlZihpID0gaS5pbm5lckhUTUwpKSB7XG4gICAgICAgICAgICBpZiAoaSAhPT0gZWxtLmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZXJ2ZXIgaW5uZXJIVE1MOiAnLCBpKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpdGVyYXRlIGFuZCBjb21wYXJlIGNoaWxkcmVuIGxpc3RzXG4gICAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgICAgLy8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cbiAgICAgICAgICAgIGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIHZhciBmdWxsSW52b2tlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBjb2xsZWN0aW5nIGRlcHMgZm9yIGRlZXAgY2xhc3MgYmluZGluZ3MgZm9yIGZ1dHVyZSB1cGRhdGVzXG4gICAgICAgICAgdHJhdmVyc2UoZGF0YVsnY2xhc3MnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHwgKFxuICAgICAgICAhaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5LCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcbiAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgIC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG4gICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICB2YXIgcGFyZW50RWxtJDEgPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcbiAgICAgICAgY3JlYXRlRWxtKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgICAgICAvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXG4gICAgICAgICAgb2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxuICAgICAgICAgIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICB2YXIgcGF0Y2hhYmxlID0gaXNQYXRjaGFibGUodm5vZGUpO1xuICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXShhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICBpZiAocGF0Y2hhYmxlKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyAjNjUxM1xuICAgICAgICAgICAgICAvLyBpbnZva2UgaW5zZXJ0IGhvb2tzIHRoYXQgbWF5IGhhdmUgYmVlbiBtZXJnZWQgYnkgY3JlYXRlIGhvb2tzLlxuICAgICAgICAgICAgICAvLyBlLmcuIGZvciBkaXJlY3RpdmVzIHRoYXQgdXNlcyB0aGUgXCJpbnNlcnRlZFwiIGhvb2suXG4gICAgICAgICAgICAgIHZhciBpbnNlcnQgPSBhbmNlc3Rvci5kYXRhLmhvb2suaW5zZXJ0O1xuICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lm1lcmdlZCkge1xuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGF0IGluZGV4IDEgdG8gYXZvaWQgcmUtaW52b2tpbmcgY29tcG9uZW50IG1vdW50ZWQgaG9va1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDE7IGkkMiA8IGluc2VydC5mbnMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0LmZuc1tpJDJdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWdpc3RlclJlZihhbmNlc3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXG4gICAgICAgIGlmIChpc0RlZihwYXJlbnRFbG0kMSkpIHtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtJDEsIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcbiAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICByZXR1cm4gdm5vZGUuZWxtXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBkaXJlY3RpdmVzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgZGVzdHJveTogZnVuY3Rpb24gdW5iaW5kRGlyZWN0aXZlcyAodm5vZGUpIHtcbiAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURpcmVjdGl2ZXMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgIF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGlzQ3JlYXRlID0gb2xkVm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG4gIHZhciBuZXdEaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG5cbiAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG4gIHZhciBrZXksIG9sZERpciwgZGlyO1xuICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgIGRpciA9IG5ld0RpcnNba2V5XTtcbiAgICBpZiAoIW9sZERpcikge1xuICAgICAgLy8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuICAgICAgY2FsbEhvb2skMShkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgY2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG4gICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxJbnNlcnQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgfVxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICB9XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG4gIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgaWYgKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbXG4gIHJlZixcbiAgZGlyZWN0aXZlc1xuXVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoZWwudGFnTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChpc0Jvb2xlYW5BdHRyKGtleSkpIHtcbiAgICAvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdGVjaG5pY2FsbHkgYWxsb3dmdWxsc2NyZWVuIGlzIGEgYm9vbGVhbiBhdHRyaWJ1dGUgZm9yIDxpZnJhbWU+LFxuICAgICAgLy8gYnV0IEZsYXNoIGV4cGVjdHMgYSB2YWx1ZSBvZiBcInRydWVcIiB3aGVuIHVzZWQgb24gPGVtYmVkPiB0YWdcbiAgICAgIHZhbHVlID0ga2V5ID09PSAnYWxsb3dmdWxsc2NyZWVuJyAmJiBlbC50YWdOYW1lID09PSAnRU1CRUQnXG4gICAgICAgID8gJ3RydWUnXG4gICAgICAgIDoga2V5O1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdmYWxzZScgOiAndHJ1ZScpO1xuICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2VTZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyAjNzEzODogSUUxMCAmIDExIGZpcmVzIGlucHV0IGV2ZW50IHdoZW4gc2V0dGluZyBwbGFjZWhvbGRlciBvblxuICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoXG4gICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgZWwudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyAmJlxuICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmICFlbC5fX2llcGhcbiAgICApIHtcbiAgICAgIHZhciBibG9ja2VyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgIH07XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICBlbC5fX2llcGggPSB0cnVlOyAvKiBJRSBwbGFjZWhvbGRlciBwYXRjaGVkICovXG4gICAgfVxuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgfVxufVxuXG52YXIgYXR0cnMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gIHVwZGF0ZTogdXBkYXRlQXR0cnNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKFxuICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICBpc1VuZGVmKGRhdGEuY2xhc3MpICYmIChcbiAgICAgIGlzVW5kZWYob2xkRGF0YSkgfHwgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5jbGFzcylcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuXG4gIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJhc2VXYXJuIChtc2cpIHtcbiAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbn1cblxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gIG1vZHVsZXMsXG4gIGtleVxuKSB7XG4gIHJldHVybiBtb2R1bGVzXG4gICAgPyBtb2R1bGVzLm1hcChmdW5jdGlvbiAobSkgeyByZXR1cm4gbVtrZXldOyB9KS5maWx0ZXIoZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH0pXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBhZGRQcm9wIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkQXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG4gIGVsLnBsYWluID0gZmFsc2U7XG59XG5cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIGVsLmF0dHJzTWFwW25hbWVdID0gdmFsdWU7XG4gIGVsLmF0dHJzTGlzdC5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuXG5mdW5jdGlvbiBhZGREaXJlY3RpdmUgKFxuICBlbCxcbiAgbmFtZSxcbiAgcmF3TmFtZSxcbiAgdmFsdWUsXG4gIGFyZyxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCByYXdOYW1lOiByYXdOYW1lLCB2YWx1ZTogdmFsdWUsIGFyZzogYXJnLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9KTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkSGFuZGxlciAoXG4gIGVsLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzLFxuICBpbXBvcnRhbnQsXG4gIHdhcm5cbikge1xuICBtb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgZW1wdHlPYmplY3Q7XG4gIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJlxuICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSAnIScgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxuICB9XG4gIGlmIChtb2RpZmllcnMub25jZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICBuYW1lID0gJ34nICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgb25jZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAobW9kaWZpZXJzLnBhc3NpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgbmFtZSA9ICcmJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIHBhc3NpdmVcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxuICAvLyB0aGlzIGlzIHRlY2huaWNhbGx5IGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBhdCBsZWFzdCBmb3Igbm93IGJyb3dzZXJzIGFyZVxuICAvLyB0aGUgb25seSB0YXJnZXQgZW52cyB0aGF0IGhhdmUgcmlnaHQvbWlkZGxlIGNsaWNrcy5cbiAgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICBpZiAobW9kaWZpZXJzLnJpZ2h0KSB7XG4gICAgICBuYW1lID0gJ2NvbnRleHRtZW51JztcbiAgICAgIGRlbGV0ZSBtb2RpZmllcnMucmlnaHQ7XG4gICAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgICBuYW1lID0gJ21vdXNldXAnO1xuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudHM7XG4gIGlmIChtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gIH1cblxuICB2YXIgbmV3SGFuZGxlciA9IHtcbiAgICB2YWx1ZTogdmFsdWUudHJpbSgpXG4gIH07XG4gIGlmIChtb2RpZmllcnMgIT09IGVtcHR5T2JqZWN0KSB7XG4gICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gIH1cblxuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cblxuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuLy8gbm90ZTogdGhpcyBvbmx5IHJlbW92ZXMgdGhlIGF0dHIgZnJvbSB0aGUgQXJyYXkgKGF0dHJzTGlzdCkgc28gdGhhdCBpdFxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuLy8gbmVlZGVkIGR1cmluZyBjb2RlZ2VuLlxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICByZW1vdmVGcm9tTWFwXG4pIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xuICB9XG4gIHJldHVybiB2YWxcbn1cblxuLyogICovXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5mdW5jdGlvbiBnZW5Db21wb25lbnRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG5cbiAgdmFyIGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID1cbiAgICAgIFwiKHR5cGVvZiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIiA9PT0gJ3N0cmluZydcIiArXG4gICAgICBcIj8gXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuICAgICAgXCI6IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICBlbC5tb2RlbCA9IHtcbiAgICB2YWx1ZTogKFwiKFwiICsgdmFsdWUgKyBcIilcIiksXG4gICAgZXhwcmVzc2lvbjogKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksXG4gICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICB9O1xufVxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gIHZhbHVlLFxuICBhc3NpZ25tZW50XG4pIHtcbiAgdmFyIHJlcyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICBpZiAocmVzLmtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIiRzZXQoXCIgKyAocmVzLmV4cCkgKyBcIiwgXCIgKyAocmVzLmtleSkgKyBcIiwgXCIgKyBhc3NpZ25tZW50ICsgXCIpXCIpXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICogSGFuZGxlcyBib3RoIGRvdC1wYXRoIGFuZCBwb3NzaWJsZSBzcXVhcmUgYnJhY2tldHMuXG4gKlxuICogUG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3Rba2V5XVxuICogLSB0ZXN0W3Rlc3QxW2tleV1dXG4gKiAtIHRlc3RbXCJhXCJdW2tleV1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2tleV1dXG4gKlxuICovXG5cbnZhciBsZW47XG52YXIgc3RyO1xudmFyIGNocjtcbnZhciBpbmRleCQxO1xudmFyIGV4cHJlc3Npb25Qb3M7XG52YXIgZXhwcmVzc2lvbkVuZFBvcztcblxuXG5cbmZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICAvLyBGaXggaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9wdWxsLzc3MzBcbiAgLy8gYWxsb3cgdi1tb2RlbD1cIm9iai52YWwgXCIgKHRyYWlsaW5nIHdoaXRlc3BhY2UpXG4gIHZhbCA9IHZhbC50cmltKCk7XG4gIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKHZhbC5pbmRleE9mKCdbJykgPCAwIHx8IHZhbC5sYXN0SW5kZXhPZignXScpIDwgbGVuIC0gMSkge1xuICAgIGluZGV4JDEgPSB2YWwubGFzdEluZGV4T2YoJy4nKTtcbiAgICBpZiAoaW5kZXgkMSA+IC0xKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbC5zbGljZSgwLCBpbmRleCQxKSxcbiAgICAgICAga2V5OiAnXCInICsgdmFsLnNsaWNlKGluZGV4JDEgKyAxKSArICdcIidcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwsXG4gICAgICAgIGtleTogbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0ciA9IHZhbDtcbiAgaW5kZXgkMSA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcblxuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcbiAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwOiB2YWwuc2xpY2UoMCwgZXhwcmVzc2lvblBvcyksXG4gICAga2V5OiB2YWwuc2xpY2UoZXhwcmVzc2lvblBvcyArIDEsIGV4cHJlc3Npb25FbmRQb3MpXG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dCAoKSB7XG4gIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG59XG5cbmZ1bmN0aW9uIGVvZiAoKSB7XG4gIHJldHVybiBpbmRleCQxID49IGxlblxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1N0YXJ0IChjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4Mjdcbn1cblxuZnVuY3Rpb24gcGFyc2VCcmFja2V0IChjaHIpIHtcbiAgdmFyIGluQnJhY2tldCA9IDE7XG4gIGV4cHJlc3Npb25Qb3MgPSBpbmRleCQxO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY2hyID09PSAweDVCKSB7IGluQnJhY2tldCsrOyB9XG4gICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiQxO1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuZnVuY3Rpb24gbW9kZWwgKFxuICBlbCxcbiAgZGlyLFxuICBfd2FyblxuKSB7XG4gIHdhcm4kMSA9IF93YXJuO1xuICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xuICB2YXIgdGFnID0gZWwudGFnO1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcbiAgICAvLyB2YWx1ZSB3aWxsIHRocm93IGFuIGVycm9yLlxuICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiIHR5cGU9XFxcImZpbGVcXFwiPjpcXG5cIiArXG4gICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMShcbiAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgXCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcbiAgICAgICdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcbiAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LidcbiAgICApO1xuICB9XG5cbiAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICB2YXIgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgIFwiQXJyYXkuaXNBcnJheShcIiArIHZhbHVlICsgXCIpXCIgK1xuICAgIFwiP19pKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKT4tMVwiICsgKFxuICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgID8gKFwiOihcIiArIHZhbHVlICsgXCIpXCIpXG4gICAgICAgIDogKFwiOl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIilcIilcbiAgICApXG4gICk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLFxuICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xuICAgICAgICBcIiQkYz0kJGVsLmNoZWNrZWQ/KFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKTooXCIgKyBmYWxzZVZhbHVlQmluZGluZyArIFwiKTtcIiArXG4gICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICBcInZhciAkJHY9XCIgKyAobnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmcpICsgXCIsXCIgK1xuICAgICAgICAgICckJGk9X2koJCRhLCQkdik7JyArXG4gICAgICBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5jb25jYXQoWyQkdl0pJykpICsgXCIpfVwiICtcbiAgICAgIFwiZWxzZXskJGk+LTEmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5zbGljZSgwLCQkaSkuY29uY2F0KCQkYS5zbGljZSgkJGkrMSkpJykpICsgXCIpfVwiICtcbiAgICBcIn1lbHNle1wiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRjJykpICsgXCJ9XCIsXG4gICAgbnVsbCwgdHJ1ZVxuICApO1xufVxuXG5mdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyAoXCJfbihcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSA6IHZhbHVlQmluZGluZztcbiAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCAoXCJfcShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5TZWxlY3QgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHNlbGVjdGVkVmFsID0gXCJBcnJheS5wcm90b3R5cGUuZmlsdGVyXCIgK1xuICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcbiAgICBcInJldHVybiBcIiArIChudW1iZXIgPyAnX24odmFsKScgOiAndmFsJykgKyBcIn0pXCI7XG5cbiAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgdmFyIGNvZGUgPSBcInZhciAkJHNlbGVjdGVkVmFsID0gXCIgKyBzZWxlY3RlZFZhbCArIFwiO1wiO1xuICBjb2RlID0gY29kZSArIFwiIFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBhc3NpZ25tZW50KSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAgLy8gd2FybiBpZiB2LWJpbmQ6dmFsdWUgY29uZmxpY3RzIHdpdGggdi1tb2RlbFxuICAvLyBleGNlcHQgZm9yIGlucHV0cyB3aXRoIHYtYmluZDp0eXBlXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIHZhbHVlJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gfHwgZWwuYXR0cnNNYXBbJzp2YWx1ZSddO1xuICAgIHZhciB0eXBlQmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xuICAgIGlmICh2YWx1ZSQxICYmICF0eXBlQmluZGluZykge1xuICAgICAgdmFyIGJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gPyAndi1iaW5kOnZhbHVlJyA6ICc6dmFsdWUnO1xuICAgICAgd2FybiQxKFxuICAgICAgICBiaW5kaW5nICsgXCI9XFxcIlwiICsgdmFsdWUkMSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCB2LW1vZGVsIG9uIHRoZSBzYW1lIGVsZW1lbnQgXCIgK1xuICAgICAgICAnYmVjYXVzZSB0aGUgbGF0dGVyIGFscmVhZHkgZXhwYW5kcyB0byBhIHZhbHVlIGJpbmRpbmcgaW50ZXJuYWxseSdcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIHZhciBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XG4gIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIgKGhhbmRsZXIsIGV2ZW50LCBjYXB0dXJlKSB7XG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICByZW1vdmUkMihldmVudCwgb25jZUhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGQkMSAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBvbmNlJCQxLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgaGFuZGxlciA9IHdpdGhNYWNyb1Rhc2soaGFuZGxlcik7XG4gIGlmIChvbmNlJCQxKSB7IGhhbmRsZXIgPSBjcmVhdGVPbmNlSGFuZGxlcihoYW5kbGVyLCBldmVudCwgY2FwdHVyZSk7IH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBldmVudCxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICBldmVudCxcbiAgICBoYW5kbGVyLl93aXRoVGFzayB8fCBoYW5kbGVyLFxuICAgIGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xuICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcbiAgICAgIC8vIHJlcGxhY2VkIGJ5IGlubmVySFRNTC90ZXh0Q29udGVudCByZXRhaW5zIGl0cyBwYXJlbnROb2RlIHByb3BlcnR5XG4gICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoZWxtLCBjaGVja1ZhbCkge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICBlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcbiAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgLy8gIzYxNTdcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgaWYgKG1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAvLyBpbnB1dHMgd2l0aCBsYXp5IHNob3VsZCBvbmx5IGJlIHVwZGF0ZWQgd2hlbiBub3QgaW4gZm9jdXNcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChcbiAgICAgICAgY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhICYmXG4gICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKVxuICAgICAgKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXG4gICAgICAvLyB7ZGlzcGxheTogW1wiLXdlYmtpdC1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcImZsZXhcIl19XG4gICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciBlbXB0eVN0eWxlO1xudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gZW1wdHlTdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIHZhciBjYXBOYW1lID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9yTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XG4gICAgICByZXR1cm4gbmFtZVxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxuICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjdXIsIG5hbWU7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcbiAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtlbHkgd2FudHNcbiAgLy8gdG8gbXV0YXRlIGl0LlxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXG4gICAgOiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmKSB7XG4gIGlmICghZGVmKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZik7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZilcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgICA6IHNldFRpbWVvdXRcbiAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH07XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgIHRyYW5zaXRpb25DbGFzc2VzLnB1c2goY2xzKTtcbiAgICBhZGRDbGFzcyhlbCwgY2xzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIHRvTXMgKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKSkgKiAxMDAwXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gIH1cblxuICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICB9XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgdmFyIGNiID0gZWwuX2VudGVyQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG4gICAgICApIHtcbiAgICAgICAgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKCk7XG4gICAgICB9XG4gICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xuICBpZiAoZXhwZWN0c0NTUykge1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgfVxuXG4gIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2VudGVyQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gcm0oKVxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XG4gIHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gIHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICB2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcbiAgdmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcbiAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gIHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cbiAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcbiAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICB2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNEZWYoZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgfVxuICAgICAgbGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICB9XG4gICAgZWwuX2xlYXZlQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgfSBlbHNlIHtcbiAgICBwZXJmb3JtTGVhdmUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG4gICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIChlbC5wYXJlbnROb2RlLl9wZW5kaW5nIHx8IChlbC5wYXJlbnROb2RlLl9wZW5kaW5nID0ge30pKVsodm5vZGUua2V5KV0gPSB2bm9kZTtcbiAgICB9XG4gICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG4gICAgICBcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuICAgIHdhcm4oXG4gICAgICBcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG4gICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG4gKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG4gIGlmIChpc1VuZGVmKGZuKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAvLyBpbnZva2VyXG4gICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG4gICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgID8gaW52b2tlckZuc1swXVxuICAgICAgICA6IGludm9rZXJGbnNcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG4gIH1cbn1cblxuZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgZW50ZXIodm5vZGUpO1xuICB9XG59XG5cbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuICBjcmVhdGU6IF9lbnRlcixcbiAgYWN0aXZhdGU6IF9lbnRlcixcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICB9XG4gIH1cbn0gOiB7fVxuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICBhdHRycyxcbiAga2xhc3MsXG4gIGV2ZW50cyxcbiAgZG9tUHJvcHMsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uXG5dXG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBkaXJlY3RpdmUgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAvLyAjNjkwM1xuICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xuICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIC8vIFNhZmFyaSA8IDEwLjIgJiBVSVdlYlZpZXcgZG9lc24ndCBmaXJlIGNvbXBvc2l0aW9uZW5kIHdoZW5cbiAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxuICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgIC8vIGZpcmVzIFwiY2hhbmdlXCIgaW5zdGVhZCBvZiBcImlucHV0XCIgb24gYXV0b2NvbXBsZXRlLlxuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pOyB9KSkge1xuICAgICAgICAvLyB0cmlnZ2VyIGNoYW5nZSBldmVudCBpZlxuICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxuICAgICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBjdXJPcHRpb25zKTsgfSlcbiAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY3R1YWxseVNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5ldmVyeShmdW5jdGlvbiAobykgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgdmFsdWUpOyB9KVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKSB7IHJldHVybiB9XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgc2hvdzogc2hvd1xufVxuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xuICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKTsgfSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnOyB9KSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvbGRDaGlsZCAmJlxuICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXG4gICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgIShvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZSAmJiBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KVxuICAgICkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXG4vLyBzdXBwb3J0cyBtb3ZlIHRyYW5zaXRpb25zIHVzaW5nIHRoZSBGTElQIHRlY2huaXF1ZS5cblxuLy8gQmVjYXVzZSB0aGUgdmRvbSdzIGNoaWxkcmVuIHVwZGF0ZSBhbGdvcml0aG0gaXMgXCJ1bnN0YWJsZVwiIC0gaS5lLlxuLy8gaXQgZG9lc24ndCBndWFyYW50ZWUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHJlbW92ZWQgZWxlbWVudHMsXG4vLyB3ZSBmb3JjZSB0cmFuc2l0aW9uLWdyb3VwIHRvIHVwZGF0ZSBpdHMgY2hpbGRyZW4gaW50byB0d28gcGFzc2VzOlxuLy8gaW4gdGhlIGZpcnN0IHBhc3MsIHdlIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQsXG4vLyB0cmlnZ2VyaW5nIHRoZWlyIGxlYXZpbmcgdHJhbnNpdGlvbjsgaW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBpbnNlcnQvbW92ZVxuLy8gaW50byB0aGUgZmluYWwgZGVzaXJlZCBzdGF0ZS4gVGhpcyB3YXkgaW4gdGhlIHNlY29uZCBwYXNzIHJlbW92ZWRcbi8vIG5vZGVzIHdpbGwgcmVtYWluIHdoZXJlIHRoZXkgc2hvdWxkIGJlLlxuXG52YXIgcHJvcHMgPSBleHRlbmQoe1xuICB0YWc6IFN0cmluZyxcbiAgbW92ZUNsYXNzOiBTdHJpbmdcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XG5cbmRlbGV0ZSBwcm9wcy5tb2RlO1xuXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICBwcm9wczogcHJvcHMsXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgIGlmIChjLnRhZykge1xuICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgbWFwW2Mua2V5XSA9IGNcbiAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgIHZhciBuYW1lID0gb3B0cyA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnIHx8ICcnKSA6IGMudGFnO1xuICAgICAgICAgIHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIGtlcHQgPSBbXTtcbiAgICAgIHZhciByZW1vdmVkID0gW107XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB2YXIgYyQxID0gcHJldkNoaWxkcmVuW2kkMV07XG4gICAgICAgIGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKG1hcFtjJDEua2V5XSkge1xuICAgICAgICAgIGtlcHQucHVzaChjJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZWQucHVzaChjJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgIH1cblxuICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pXG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUgKCkge1xuICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICB0aGlzLl9fcGF0Y2hfXyhcbiAgICAgIHRoaXMuX3Zub2RlLFxuICAgICAgdGhpcy5rZXB0LFxuICAgICAgZmFsc2UsIC8vIGh5ZHJhdGluZ1xuICAgICAgdHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG4gICAgKTtcbiAgICB0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkICgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICB2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgLy8gYXNzaWduIHRvIHRoaXMgdG8gYXZvaWQgYmVpbmcgcmVtb3ZlZCBpbiB0cmVlLXNoYWtpbmdcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgICAgIGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuICAgICAgfVxuICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgdmFyIGluZm8gPSBnZXRUcmFuc2l0aW9uSW5mbyhjbG9uZSk7XG4gICAgICB0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufVxuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZS5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZS5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuVnVlLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5WdWUucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChpbkJyb3dzZXIpIHtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgICAgaWYgKGRldnRvb2xzKSB7XG4gICAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmXG4gICAgICAgIGlzQ2hyb21lXG4gICAgICApIHtcbiAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgY29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG4gICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICApIHtcbiAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICAgIFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcbiAgICAgICAgXCJTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbFwiXG4gICAgICApO1xuICAgIH1cbiAgfSwgMCk7XG59XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cblxuXG5mdW5jdGlvbiBwYXJzZVRleHQgKFxuICB0ZXh0LFxuICBkZWxpbWl0ZXJzXG4pIHtcbiAgdmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG4gIGlmICghdGFnUkUudGVzdCh0ZXh0KSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0b2tlbnMgPSBbXTtcbiAgdmFyIHJhd1Rva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleCwgdG9rZW5WYWx1ZTtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKTtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICByYXdUb2tlbnMucHVzaCh7ICdAYmluZGluZyc6IGV4cCB9KTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICByYXdUb2tlbnMucHVzaCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgpKTtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBleHByZXNzaW9uOiB0b2tlbnMuam9pbignKycpLFxuICAgIHRva2VuczogcmF3VG9rZW5zXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGljQ2xhc3MpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiY2xhc3M9XFxcIlwiICsgc3RhdGljQ2xhc3MgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhOiBnZW5EYXRhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJzdHlsZT1cXFwiXCIgKyBzdGF0aWNTdHlsZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgc3R5bGU9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpzdHlsZT1cInZhbFwiPi4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcbiAgfVxuXG4gIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKHN0eWxlQmluZGluZykge1xuICAgIGVsLnN0eWxlQmluZGluZyA9IHN0eWxlQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhJDEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNTdHlsZSkge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNTdHlsZTpcIiArIChlbC5zdGF0aWNTdHlsZSkgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcInN0eWxlOihcIiArIChlbC5zdHlsZUJpbmRpbmcpICsgXCIpLFwiO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbnZhciBzdHlsZSQxID0ge1xuICBzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXG4gIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcbiAgZ2VuRGF0YTogZ2VuRGF0YSQxXG59XG5cbi8qICAqL1xuXG52YXIgZGVjb2RlcjtcblxudmFyIGhlID0ge1xuICBkZWNvZGU6IGZ1bmN0aW9uIGRlY29kZSAoaHRtbCkge1xuICAgIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vKiFcbiAqIEhUTUwgUGFyc2VyIEJ5IEpvaG4gUmVzaWcgKGVqb2huLm9yZylcbiAqIE1vZGlmaWVkIGJ5IEp1cml5IFwia2FuZ2F4XCIgWmF5dHNldlxuICogT3JpZ2luYWwgY29kZSBieSBFcmlrIEFydmlkc3NvbiwgTW96aWxsYSBQdWJsaWMgTGljZW5zZVxuICogaHR0cDovL2VyaWsuZWFlLm5ldC9zaW1wbGVodG1scGFyc2VyL3NpbXBsZWh0bWxwYXJzZXIuanNcbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/Lztcbi8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcbnZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcbnZhciBxbmFtZUNhcHR1cmUgPSBcIigoPzpcIiArIG5jbmFtZSArIFwiXFxcXDopP1wiICsgbmNuYW1lICsgXCIpXCI7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgoXCJePFwiICsgcW5hbWVDYXB0dXJlKSk7XG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xudmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoKFwiXjxcXFxcL1wiICsgcW5hbWVDYXB0dXJlICsgXCJbXj5dKj5cIikpO1xudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbi8vICM3Mjk4OiBlc2NhcGUgLSB0byBhdm9pZCBiZWluZyBwYXNlZCBhcyBIVE1MIGNvbW1lbnQgd2hlbiBpbmxpbmVkIGluIHBhZ2VcbnZhciBjb21tZW50ID0gL148IVxcLS0vO1xudmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG52YXIgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGZhbHNlO1xuJ3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtLCBnKSB7XG4gIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBnID09PSAnJztcbn0pO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciByZUNhY2hlID0ge307XG5cbnZhciBkZWNvZGluZ01hcCA9IHtcbiAgJyZsdDsnOiAnPCcsXG4gICcmZ3Q7JzogJz4nLFxuICAnJnF1b3Q7JzogJ1wiJyxcbiAgJyZhbXA7JzogJyYnLFxuICAnJiMxMDsnOiAnXFxuJyxcbiAgJyYjOTsnOiAnXFx0J1xufTtcbnZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXApOy9nO1xudmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMTB8IzkpOy9nO1xuXG4vLyAjNTk5MlxudmFyIGlzSWdub3JlTmV3bGluZVRhZyA9IG1ha2VNYXAoJ3ByZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHNob3VsZElnbm9yZUZpcnN0TmV3bGluZSA9IGZ1bmN0aW9uICh0YWcsIGh0bWwpIHsgcmV0dXJuIHRhZyAmJiBpc0lnbm9yZU5ld2xpbmVUYWcodGFnKSAmJiBodG1sWzBdID09PSAnXFxuJzsgfTtcblxuZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gIHZhciByZSA9IHNob3VsZERlY29kZU5ld2xpbmVzID8gZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgOiBlbmNvZGVkQXR0cjtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gZGVjb2RpbmdNYXBbbWF0Y2hdOyB9KVxufVxuXG5mdW5jdGlvbiBwYXJzZUhUTUwgKGh0bWwsIG9wdGlvbnMpIHtcbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICB2YXIgaXNVbmFyeVRhZyQkMSA9IG9wdGlvbnMuaXNVbmFyeVRhZyB8fCBubztcbiAgdmFyIGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0LCBsYXN0VGFnO1xuICB3aGlsZSAoaHRtbCkge1xuICAgIGxhc3QgPSBodG1sO1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSdyZSBub3QgaW4gYSBwbGFpbnRleHQgY29udGVudCBlbGVtZW50IGxpa2Ugc2NyaXB0L3N0eWxlXG4gICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcbiAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAvLyBDb21tZW50OlxuICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbW1lbnRFbmQgPSBodG1sLmluZGV4T2YoJy0tPicpO1xuXG4gICAgICAgICAgaWYgKGNvbW1lbnRFbmQgPj0gMCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkS2VlcENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50KGh0bWwuc3Vic3RyaW5nKDQsIGNvbW1lbnRFbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkdmFuY2UoY29tbWVudEVuZCArIDMpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbmFsRW5kID0gaHRtbC5pbmRleE9mKCddPicpO1xuXG4gICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgIGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9jdHlwZTpcbiAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcbiAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbmQgdGFnOlxuICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgIGlmIChlbmRUYWdNYXRjaCkge1xuICAgICAgICAgIHZhciBjdXJJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgdGFnOlxuICAgICAgICB2YXIgc3RhcnRUYWdNYXRjaCA9IHBhcnNlU3RhcnRUYWcoKTtcbiAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICBoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcbiAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKGxhc3RUYWcsIGh0bWwpKSB7XG4gICAgICAgICAgICBhZHZhbmNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgaWYgKHRleHRFbmQgPj0gMCkge1xuICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICFlbmRUYWcudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdClcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICBuZXh0ID0gcmVzdC5pbmRleE9mKCc8JywgMSk7XG4gICAgICAgICAgaWYgKG5leHQgPCAwKSB7IGJyZWFrIH1cbiAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgICBhZHZhbmNlKHRleHRFbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dEVuZCA8IDApIHtcbiAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICAgIGh0bWwgPSAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgIHZhciBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuICAgICAgdmFyIHJlc3QkMSA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICBpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJykgLy8gIzcyOThcbiAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhY2tlZFRhZywgdGV4dCkpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9KTtcbiAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdCQxLmxlbmd0aDtcbiAgICAgIGh0bWwgPSByZXN0JDE7XG4gICAgICBwYXJzZUVuZFRhZyhzdGFja2VkVGFnLCBpbmRleCAtIGVuZFRhZ0xlbmd0aCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGlmIChodG1sID09PSBsYXN0KSB7XG4gICAgICBvcHRpb25zLmNoYXJzICYmIG9wdGlvbnMuY2hhcnMoaHRtbCk7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XG4gICAgICAgIGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5hdHRycy5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgIHZhciB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcblxuICAgIGlmIChleHBlY3RIVE1MKSB7XG4gICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcobGFzdFRhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmFyeSA9IGlzVW5hcnlUYWckJDEodGFnTmFtZSkgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgLy8gaGFja2lzaCB3b3JrIGFyb3VuZCBGRiBidWcgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MzY5Nzc4XG4gICAgICBpZiAoSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiAmJiBhcmdzWzBdLmluZGV4T2YoJ1wiXCInKSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKGFyZ3NbM10gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzNdOyB9XG4gICAgICAgIGlmIChhcmdzWzRdID09PSAnJykgeyBkZWxldGUgYXJnc1s0XTsgfVxuICAgICAgICBpZiAoYXJnc1s1XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNV07IH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgdmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gdGFnTmFtZSA9PT0gJ2EnICYmIGFyZ3NbMV0gPT09ICdocmVmJ1xuICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghdW5hcnkpIHtcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzIH0pO1xuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cblxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgICAgICAoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcbiAgICAgICAgICBvcHRpb25zLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgb3B0aW9ucy53YXJuKFxuICAgICAgICAgICAgKFwidGFnIDxcIiArIChzdGFja1tpXS50YWcpICsgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgIHN0YWNrLmxlbmd0aCA9IHBvcztcbiAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcbnZhciBkaXJSRSA9IC9edi18XkB8XjovO1xudmFyIGZvckFsaWFzUkUgPSAvKFteXSo/KVxccysoPzppbnxvZilcXHMrKFteXSopLztcbnZhciBmb3JJdGVyYXRvclJFID0gLywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvO1xudmFyIHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XG5cbnZhciBhcmdSRSA9IC86KC4qKSQvO1xudmFyIGJpbmRSRSA9IC9eOnxedi1iaW5kOi87XG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5dKy9nO1xuXG52YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChoZS5kZWNvZGUpO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcbnZhciB3YXJuJDI7XG52YXIgZGVsaW1pdGVycztcbnZhciB0cmFuc2Zvcm1zO1xudmFyIHByZVRyYW5zZm9ybXM7XG52YXIgcG9zdFRyYW5zZm9ybXM7XG52YXIgcGxhdGZvcm1Jc1ByZVRhZztcbnZhciBwbGF0Zm9ybU11c3RVc2VQcm9wO1xudmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xuXG5cblxuZnVuY3Rpb24gY3JlYXRlQVNURWxlbWVudCAoXG4gIHRhZyxcbiAgYXR0cnMsXG4gIHBhcmVudFxuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMSxcbiAgICB0YWc6IHRhZyxcbiAgICBhdHRyc0xpc3Q6IGF0dHJzLFxuICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgIHBhcmVudDogcGFyZW50LFxuICAgIGNoaWxkcmVuOiBbXVxuICB9XG59XG5cbi8qKlxuICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChcbiAgdGVtcGxhdGUsXG4gIG9wdGlvbnNcbikge1xuICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG5cbiAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XG4gIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuXG4gIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcbiAgcHJlVHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncHJlVHJhbnNmb3JtTm9kZScpO1xuICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICB2YXIgcm9vdDtcbiAgdmFyIGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBpblZQcmUgPSBmYWxzZTtcbiAgdmFyIGluUHJlID0gZmFsc2U7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiB3YXJuT25jZSAobXNnKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB3YXJuJDIobXNnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQgKGVsZW1lbnQpIHtcbiAgICAvLyBjaGVjayBwcmUgc3RhdGVcbiAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgIGluUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvc3RUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgIHdhcm46IHdhcm4kMixcbiAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgaXNVbmFyeVRhZzogb3B0aW9ucy5pc1VuYXJ5VGFnLFxuICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmLFxuICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnkpIHtcbiAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgdmFyIG5zID0gKGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5ucykgfHwgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UodGFnKTtcblxuICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XG4gICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlQVNURWxlbWVudCh0YWcsIGF0dHJzLCBjdXJyZW50UGFyZW50KTtcbiAgICAgIGlmIChucykge1xuICAgICAgICBlbGVtZW50Lm5zID0gbnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuICAgICAgICAgICdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcbiAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcbiAgICAgICAgICBcIjxcIiArIHRhZyArIFwiPlwiICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsZW1lbnQgPSBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICBpblByZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5WUHJlKSB7XG4gICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlc1xuICAgICAgICBwcm9jZXNzRm9yKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgICAvLyBlbGVtZW50LXNjb3BlIHN0dWZmXG4gICAgICAgIHByb2Nlc3NFbGVtZW50KGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjaGVja1Jvb3RDb25zdHJhaW50cyAoZWwpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoZWwudGFnID09PSAnc2xvdCcgfHwgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgXCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuICAgICAgICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHRyZWUgbWFuYWdlbWVudFxuICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgIHJvb3QgPSBlbGVtZW50O1xuICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YWNrLmxlbmd0aCkge1xuICAgICAgICAvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2VcbiAgICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcbiAgICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBcIkNvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQuIFwiICtcbiAgICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgICBcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgICAgICAgY3VycmVudFBhcmVudC5wbGFpbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciBuYW1lID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIic7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgZWxlbWVudC5wYXJlbnQgPSBjdXJyZW50UGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBsYXN0Tm9kZSA9IGVsZW1lbnQuY2hpbGRyZW5bZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0Tm9kZSAmJiBsYXN0Tm9kZS50eXBlID09PSAzICYmIGxhc3ROb2RlLnRleHQgPT09ICcgJyAmJiAhaW5QcmUpIHtcbiAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRleHQgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIChcInRleHQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgdGV4dCA9IGluUHJlIHx8IHRleHQudHJpbSgpXG4gICAgICAgID8gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dClcbiAgICAgICAgLy8gb25seSBwcmVzZXJ2ZSB3aGl0ZXNwYWNlIGlmIGl0cyBub3QgcmlnaHQgYWZ0ZXIgYSBzdGFydGluZyB0YWdcbiAgICAgICAgOiBwcmVzZXJ2ZVdoaXRlc3BhY2UgJiYgY2hpbGRyZW4ubGVuZ3RoID8gJyAnIDogJyc7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKHJlcyA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDIsXG4gICAgICAgICAgICBleHByZXNzaW9uOiByZXMuZXhwcmVzc2lvbixcbiAgICAgICAgICAgIHRva2VuczogcmVzLnRva2VucyxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbW1lbnQ6IGZ1bmN0aW9uIGNvbW1lbnQgKHRleHQpIHtcbiAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgIHR5cGU6IDMsXG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIGlzQ29tbWVudDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJvb3Rcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1ByZSAoZWwpIHtcbiAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcbiAgICBlbC5wcmUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSYXdBdHRycyAoZWwpIHtcbiAgdmFyIGwgPSBlbC5hdHRyc0xpc3QubGVuZ3RoO1xuICBpZiAobCkge1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgbmFtZTogZWwuYXR0cnNMaXN0W2ldLm5hbWUsXG4gICAgICAgIHZhbHVlOiBKU09OLnN0cmluZ2lmeShlbC5hdHRyc0xpc3RbaV0udmFsdWUpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmICghZWwucHJlKSB7XG4gICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xuICAgIGVsLnBsYWluID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzRWxlbWVudCAoZWxlbWVudCwgb3B0aW9ucykge1xuICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xuXG4gIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xuICBlbGVtZW50LnBsYWluID0gIWVsZW1lbnQua2V5ICYmICFlbGVtZW50LmF0dHJzTGlzdC5sZW5ndGg7XG5cbiAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgcHJvY2Vzc1Nsb3QoZWxlbWVudCk7XG4gIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgIGVsZW1lbnQgPSB0cmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gIH1cbiAgcHJvY2Vzc0F0dHJzKGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzS2V5IChlbCkge1xuICB2YXIgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcbiAgaWYgKGV4cCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgd2FybiQyKFwiPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICBpZiAocmVmKSB7XG4gICAgZWwucmVmID0gcmVmO1xuICAgIGVsLnJlZkluRm9yID0gY2hlY2tJbkZvcihlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgdmFyIGV4cDtcbiAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VGb3IoZXhwKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICBleHRlbmQoZWwsIHJlcyk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5cblxuZnVuY3Rpb24gcGFyc2VGb3IgKGV4cCkge1xuICB2YXIgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcbiAgaWYgKCFpbk1hdGNoKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgcmVzLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuICB2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKS5yZXBsYWNlKHN0cmlwUGFyZW5zUkUsICcnKTtcbiAgdmFyIGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICByZXMuYWxpYXMgPSBhbGlhcy5yZXBsYWNlKGZvckl0ZXJhdG9yUkUsICcnKTtcbiAgICByZXMuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgIHJlcy5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzLmFsaWFzID0gYWxpYXM7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICBpZiAoZXhwKSB7XG4gICAgZWwuaWYgPSBleHA7XG4gICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgIGV4cDogZXhwLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG4gICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICBpZiAoZWxzZWlmKSB7XG4gICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcbiAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgaWYgKHByZXYgJiYgcHJldi5pZikge1xuICAgIGFkZElmQ29uZGl0aW9uKHByZXYsIHtcbiAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgYmxvY2s6IGVsXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4kMihcbiAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiICsgKGVsLnRhZykgKyBcIj4gd2l0aG91dCBjb3JyZXNwb25kaW5nIHYtaWYuXCJcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcbiAgdmFyIGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0ZXh0IFxcXCJcIiArIChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArXG4gICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuLnBvcCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xuICB9XG4gIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xuICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgaWYgKG9uY2UkJDEgIT0gbnVsbCkge1xuICAgIGVsLm9uY2UgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NTbG90IChlbCkge1xuICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICBlbC5zbG90TmFtZSA9IGdldEJpbmRpbmdBdHRyKGVsLCAnbmFtZScpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmtleSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICBcImFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIFwiICtcbiAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3RTY29wZTtcbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICBzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdFNjb3BlKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRoZSBcXFwic2NvcGVcXFwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBcIiArXG4gICAgICAgICAgXCJyZXBsYWNlZCBieSBcXFwic2xvdC1zY29wZVxcXCIgc2luY2UgMi41LiBUaGUgbmV3IFxcXCJzbG90LXNjb3BlXFxcIiBhdHRyaWJ1dGUgXCIgK1xuICAgICAgICAgIFwiY2FuIGFsc28gYmUgdXNlZCBvbiBwbGFpbiBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byA8dGVtcGxhdGU+IHRvIFwiICtcbiAgICAgICAgICBcImRlbm90ZSBzY29wZWQgc2xvdHMuXCIsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlIHx8IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJyk7XG4gICAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwuYXR0cnNNYXBbJ3YtZm9yJ10pIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwiQW1iaWd1b3VzIGNvbWJpbmVkIHVzYWdlIG9mIHNsb3Qtc2NvcGUgYW5kIHYtZm9yIG9uIDxcIiArIChlbC50YWcpICsgXCI+IFwiICtcbiAgICAgICAgICBcIih2LWZvciB0YWtlcyBoaWdoZXIgcHJpb3JpdHkpLiBVc2UgYSB3cmFwcGVyIDx0ZW1wbGF0ZT4gZm9yIHRoZSBcIiArXG4gICAgICAgICAgXCJzY29wZWQgc2xvdCB0byBtYWtlIGl0IGNsZWFyZXIuXCIsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xuICAgIH1cbiAgICB2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuICAgIGlmIChzbG90VGFyZ2V0KSB7XG4gICAgICBlbC5zbG90VGFyZ2V0ID0gc2xvdFRhcmdldCA9PT0gJ1wiXCInID8gJ1wiZGVmYXVsdFwiJyA6IHNsb3RUYXJnZXQ7XG4gICAgICAvLyBwcmVzZXJ2ZSBzbG90IGFzIGFuIGF0dHJpYnV0ZSBmb3IgbmF0aXZlIHNoYWRvdyBET00gY29tcGF0XG4gICAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzLlxuICAgICAgaWYgKGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFNjb3BlKSB7XG4gICAgICAgIGFkZEF0dHIoZWwsICdzbG90Jywgc2xvdFRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gIHZhciBiaW5kaW5nO1xuICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG4gICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgfVxuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGlzUHJvcDtcbiAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgdmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuICAgICAgZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lKTtcbiAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXG4gICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgIHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcbiAgICAgICAgaXNQcm9wID0gZmFsc2U7XG4gICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3ApIHtcbiAgICAgICAgICAgIGlzUHJvcCA9IHRydWU7XG4gICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwpIHtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICBhZGRIYW5kbGVyKFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGNhbWVsaXplKG5hbWUpKSksXG4gICAgICAgICAgICAgIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBcIiRldmVudFwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJvcCB8fCAoXG4gICAgICAgICAgIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSlcbiAgICAgICAgKSkge1xuICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7IC8vIHYtb25cbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG4gICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGZhbHNlLCB3YXJuJDIpO1xuICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAvLyBwYXJzZSBhcmdcbiAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgIHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcbiAgICAgICAgaWYgKGFyZykge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAvLyBldmVuIGltbWVkaWF0ZWx5IGFmdGVyIGVsZW1lbnQgY3JlYXRpb25cbiAgICAgIGlmICghZWwuY29tcG9uZW50ICYmXG4gICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyAobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICBpZiAobWF0Y2gpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuICB2YXIgbWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcbiAgICApIHtcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUpO1xuICAgIH1cbiAgICBtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbi8vIGZvciBzY3JpcHQgKGUuZy4gdHlwZT1cIngvdGVtcGxhdGVcIikgb3Igc3R5bGUsIGRvIG5vdCBkZWNvZGUgY29udGVudFxuZnVuY3Rpb24gaXNUZXh0VGFnIChlbCkge1xuICByZXR1cm4gZWwudGFnID09PSAnc2NyaXB0JyB8fCBlbC50YWcgPT09ICdzdHlsZSdcbn1cblxuZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcgKGVsKSB7XG4gIHJldHVybiAoXG4gICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgKGVsLnRhZyA9PT0gJ3NjcmlwdCcgJiYgKFxuICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcbiAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgKSlcbiAgKVxufVxuXG52YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcbnZhciBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgcmVzLnB1c2goYXR0cik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgdmFyIF9lbCA9IGVsO1xuICB3aGlsZSAoX2VsKSB7XG4gICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcbiAgICAgICAgXCJ3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBcIiArXG4gICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogRXhwYW5kIGlucHV0W3YtbW9kZWxdIHdpdGggZHlhbm1pYyB0eXBlIGJpbmRpbmdzIGludG8gdi1pZi1lbHNlIGNoYWluc1xuICogVHVybiB0aGlzOlxuICogICA8aW5wdXQgdi1tb2RlbD1cImRhdGFbdHlwZV1cIiA6dHlwZT1cInR5cGVcIj5cbiAqIGludG8gdGhpczpcbiAqICAgPGlucHV0IHYtaWY9XCJ0eXBlID09PSAnY2hlY2tib3gnXCIgdHlwZT1cImNoZWNrYm94XCIgdi1tb2RlbD1cImRhdGFbdHlwZV1cIj5cbiAqICAgPGlucHV0IHYtZWxzZS1pZj1cInR5cGUgPT09ICdyYWRpbydcIiB0eXBlPVwicmFkaW9cIiB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiPlxuICogICA8aW5wdXQgdi1lbHNlIDp0eXBlPVwidHlwZVwiIHYtbW9kZWw9XCJkYXRhW3R5cGVdXCI+XG4gKi9cblxuZnVuY3Rpb24gcHJlVHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ2lucHV0Jykge1xuICAgIHZhciBtYXAgPSBlbC5hdHRyc01hcDtcbiAgICBpZiAoIW1hcFsndi1tb2RlbCddKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgdHlwZUJpbmRpbmc7XG4gICAgaWYgKG1hcFsnOnR5cGUnXSB8fCBtYXBbJ3YtYmluZDp0eXBlJ10pIHtcbiAgICAgIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgfVxuICAgIGlmICghbWFwLnR5cGUgJiYgIXR5cGVCaW5kaW5nICYmIG1hcFsndi1iaW5kJ10pIHtcbiAgICAgIHR5cGVCaW5kaW5nID0gXCIoXCIgKyAobWFwWyd2LWJpbmQnXSkgKyBcIikudHlwZVwiO1xuICAgIH1cblxuICAgIGlmICh0eXBlQmluZGluZykge1xuICAgICAgdmFyIGlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnLCB0cnVlKTtcbiAgICAgIHZhciBpZkNvbmRpdGlvbkV4dHJhID0gaWZDb25kaXRpb24gPyAoXCImJihcIiArIGlmQ29uZGl0aW9uICsgXCIpXCIpIDogXCJcIjtcbiAgICAgIHZhciBoYXNFbHNlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScsIHRydWUpICE9IG51bGw7XG4gICAgICB2YXIgZWxzZUlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicsIHRydWUpO1xuICAgICAgLy8gMS4gY2hlY2tib3hcbiAgICAgIHZhciBicmFuY2gwID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIC8vIHByb2Nlc3MgZm9yIG9uIHRoZSBtYWluIG5vZGVcbiAgICAgIHByb2Nlc3NGb3IoYnJhbmNoMCk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDAsICd0eXBlJywgJ2NoZWNrYm94Jyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gwLCBvcHRpb25zKTtcbiAgICAgIGJyYW5jaDAucHJvY2Vzc2VkID0gdHJ1ZTsgLy8gcHJldmVudCBpdCBmcm9tIGRvdWJsZS1wcm9jZXNzZWRcbiAgICAgIGJyYW5jaDAuaWYgPSBcIihcIiArIHR5cGVCaW5kaW5nICsgXCIpPT09J2NoZWNrYm94J1wiICsgaWZDb25kaXRpb25FeHRyYTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBicmFuY2gwLmlmLFxuICAgICAgICBibG9jazogYnJhbmNoMFxuICAgICAgfSk7XG4gICAgICAvLyAyLiBhZGQgcmFkaW8gZWxzZS1pZiBjb25kaXRpb25cbiAgICAgIHZhciBicmFuY2gxID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMSwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDEsICd0eXBlJywgJ3JhZGlvJyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gxLCBvcHRpb25zKTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBcIihcIiArIHR5cGVCaW5kaW5nICsgXCIpPT09J3JhZGlvJ1wiICsgaWZDb25kaXRpb25FeHRyYSxcbiAgICAgICAgYmxvY2s6IGJyYW5jaDFcbiAgICAgIH0pO1xuICAgICAgLy8gMy4gb3RoZXJcbiAgICAgIHZhciBicmFuY2gyID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMiwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDIsICc6dHlwZScsIHR5cGVCaW5kaW5nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDIsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGlmQ29uZGl0aW9uLFxuICAgICAgICBibG9jazogYnJhbmNoMlxuICAgICAgfSk7XG5cbiAgICAgIGlmIChoYXNFbHNlKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xuICAgICAgICBicmFuY2gwLmVsc2VpZiA9IGVsc2VJZkNvbmRpdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJyYW5jaDBcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBU1RFbGVtZW50IChlbCkge1xuICByZXR1cm4gY3JlYXRlQVNURWxlbWVudChlbC50YWcsIGVsLmF0dHJzTGlzdC5zbGljZSgpLCBlbC5wYXJlbnQpXG59XG5cbnZhciBtb2RlbCQyID0ge1xuICBwcmVUcmFuc2Zvcm1Ob2RlOiBwcmVUcmFuc2Zvcm1Ob2RlXG59XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDEsXG4gIG1vZGVsJDJcbl1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICB0ZXh0OiB0ZXh0LFxuICBodG1sOiBodG1sXG59XG5cbi8qICAqL1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxuLyogICovXG5cbnZhciBpc1N0YXRpY0tleTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzJyArXG4gICAgKGtleXMgPyAnLCcgKyBrZXlzIDogJycpXG4gIClcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyQxIChub2RlKSB7XG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXG4gICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgIGlmIChcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXG4gICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICBub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICB2YXIgYmxvY2sgPSBub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrO1xuICAgICAgICBtYXJrU3RhdGljJDEoYmxvY2spO1xuICAgICAgICBpZiAoIWJsb2NrLnN0YXRpYykge1xuICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY1Jvb3RzIChub2RlLCBpc0luRm9yKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XG4gICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcbiAgICB9XG4gICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcbiAgICAvLyBhcmUgbm90IGp1c3Qgc3RhdGljIHRleHQuIE90aGVyd2lzZSB0aGUgY29zdCBvZiBob2lzdGluZyBvdXQgd2lsbFxuICAgIC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cbiAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcbiAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IDNcbiAgICApKSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2ssIGlzSW5Gb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyAobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAyKSB7IC8vIGV4cHJlc3Npb25cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAzKSB7IC8vIHRleHRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiAhIShub2RlLnByZSB8fCAoXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcbiAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgIWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXG4gICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XG4gIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobm9kZS5mb3IpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxudmFyIGZuRXhwUkUgPSAvXihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyBLZXlib2FyZEV2ZW50LmtleSBhbGlhc2VzXG52YXIga2V5TmFtZXMgPSB7XG4gIGVzYzogJ0VzY2FwZScsXG4gIHRhYjogJ1RhYicsXG4gIGVudGVyOiAnRW50ZXInLFxuICBzcGFjZTogJyAnLFxuICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxuICB1cDogWydVcCcsICdBcnJvd1VwJ10sXG4gIGxlZnQ6IFsnTGVmdCcsICdBcnJvd0xlZnQnXSxcbiAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxuICBkb3duOiBbJ0Rvd24nLCAnQXJyb3dEb3duJ10sXG4gICdkZWxldGUnOiBbJ0JhY2tzcGFjZScsICdEZWxldGUnXVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG52YXIgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcbiAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlLFxuICB3YXJuXG4pIHtcbiAgdmFyIHJlcyA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOnsnIDogJ29uOnsnO1xuICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgIHJlcyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyAoZ2VuSGFuZGxlcihuYW1lLCBldmVudHNbbmFtZV0pKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ30nXG59XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXIgKFxuICBuYW1lLFxuICBoYW5kbGVyXG4pIHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcbiAgfVxuXG4gIHZhciBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICBpZiAoaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci52YWx1ZVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIChoYW5kbGVyLnZhbHVlKSArIFwifVwiKSAvLyBpbmxpbmUgc3RhdGVtZW50XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvZGUgPSAnJztcbiAgICB2YXIgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdleGFjdCcpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IChoYW5kbGVyLm1vZGlmaWVycyk7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBnZW5HdWFyZChcbiAgICAgICAgICBbJ2N0cmwnLCAnc2hpZnQnLCAnYWx0JywgJ21ldGEnXVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuICFtb2RpZmllcnNba2V5TW9kaWZpZXJdOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuIChcIiRldmVudC5cIiArIGtleU1vZGlmaWVyICsgXCJLZXlcIik7IH0pXG4gICAgICAgICAgICAuam9pbignfHwnKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgfVxuICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIigkZXZlbnQpXCIpXG4gICAgICA6IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICAgID8gKFwicmV0dXJuIChcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXG4gICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFwiaWYoISgnYnV0dG9uJyBpbiAkZXZlbnQpJiZcIiArIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiKVxufVxuXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcbiAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIChcIiRldmVudC5rZXlDb2RlIT09XCIgKyBrZXlWYWwpXG4gIH1cbiAgdmFyIGtleUNvZGUgPSBrZXlDb2Rlc1trZXldO1xuICB2YXIga2V5TmFtZSA9IGtleU5hbWVzW2tleV07XG4gIHJldHVybiAoXG4gICAgXCJfaygkZXZlbnQua2V5Q29kZSxcIiArXG4gICAgKEpTT04uc3RyaW5naWZ5KGtleSkpICsgXCIsXCIgK1xuICAgIChKU09OLnN0cmluZ2lmeShrZXlDb2RlKSkgKyBcIixcIiArXG4gICAgXCIkZXZlbnQua2V5LFwiICtcbiAgICBcIlwiICsgKEpTT04uc3RyaW5naWZ5KGtleU5hbWUpKSArXG4gICAgXCIpXCJcbiAgKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGlyLm1vZGlmaWVycykge1xuICAgIHdhcm4oXCJ2LW9uIHdpdGhvdXQgYXJndW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllcnMuXCIpO1xuICB9XG4gIGVsLndyYXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiX2coXCIgKyBjb2RlICsgXCIsXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKTsgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuICBlbC53cmFwRGF0YSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyBcIixcIiArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZScpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIGJhc2VEaXJlY3RpdmVzID0ge1xuICBvbjogb24sXG4gIGJpbmQ6IGJpbmQkMSxcbiAgY2xvYWs6IG5vb3Bcbn1cblxuLyogICovXG5cbnZhciBDb2RlZ2VuU3RhdGUgPSBmdW5jdGlvbiBDb2RlZ2VuU3RhdGUgKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgdGhpcy5kYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XG4gIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIHRoaXMubWF5YmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7IH07XG4gIHRoaXMub25jZUlkID0gMDtcbiAgdGhpcy5zdGF0aWNSZW5kZXJGbnMgPSBbXTtcbn07XG5cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZSAoXG4gIGFzdCxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBzdGF0ZSA9IG5ldyBDb2RlZ2VuU3RhdGUob3B0aW9ucyk7XG4gIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QsIHN0YXRlKSA6ICdfYyhcImRpdlwiKSc7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCkge1xuICAgIHJldHVybiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd2b2lkIDAnXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICByZXR1cm4gZ2VuU2xvdChlbCwgc3RhdGUpXG4gIH0gZWxzZSB7XG4gICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICB2YXIgY29kZTtcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwsIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhdGEgPSBlbC5wbGFpbiA/IHVuZGVmaW5lZCA6IGdlbkRhdGEkMihlbCwgc3RhdGUpO1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgICAgY29kZSA9IFwiX2MoJ1wiICsgKGVsLnRhZykgKyBcIidcIiArIChkYXRhID8gKFwiLFwiICsgZGF0YSkgOiAnJykgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLnRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS50cmFuc2Zvcm1zW2ldKGVsLCBjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfVxufVxuXG4vLyBob2lzdCBzdGF0aWMgc3ViLXRyZWVzIG91dFxuZnVuY3Rpb24gZ2VuU3RhdGljIChlbCwgc3RhdGUpIHtcbiAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiKSk7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0ZS53YXJuKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICB9XG4gICAgcmV0dXJuIChcIl9vKFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIixcIiArIChzdGF0ZS5vbmNlSWQrKykgKyBcIixcIiArIGtleSArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklmIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoXG4gIGNvbmRpdGlvbnMsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcbiAgfVxuXG4gIHZhciBjb25kaXRpb24gPSBjb25kaXRpb25zLnNoaWZ0KCk7XG4gIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgcmV0dXJuIChcIihcIiArIChjb25kaXRpb24uZXhwKSArIFwiKT9cIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpICsgXCI6XCIgKyAoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGFsdEdlblxuICAgICAgPyBhbHRHZW4oZWwsIHN0YXRlKVxuICAgICAgOiBlbC5vbmNlXG4gICAgICAgID8gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEhlbHBlclxuKSB7XG4gIHZhciBleHAgPSBlbC5mb3I7XG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSAmJlxuICAgIGVsLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgIWVsLmtleVxuICApIHtcbiAgICBzdGF0ZS53YXJuKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcbiAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gKGFsdEhlbHBlciB8fCAnX2wnKSArIFwiKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKChhbHRHZW4gfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsLCBzdGF0ZSk7XG4gIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxuXG4gIC8vIGtleVxuICBpZiAoZWwua2V5KSB7XG4gICAgZGF0YSArPSBcImtleTpcIiArIChlbC5rZXkpICsgXCIsXCI7XG4gIH1cbiAgLy8gcmVmXG4gIGlmIChlbC5yZWYpIHtcbiAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZGF0YSArPSBcInRhZzpcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIjtcbiAgfVxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xuICB9XG4gIC8vIGF0dHJpYnV0ZXNcbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgZGF0YSArPSBcImF0dHJzOntcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIERPTSBwcm9wc1xuICBpZiAoZWwucHJvcHMpIHtcbiAgICBkYXRhICs9IFwiZG9tUHJvcHM6e1wiICsgKGdlblByb3BzKGVsLnByb3BzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UsIHN0YXRlLndhcm4pKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUsIHN0YXRlLndhcm4pKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNsb3RUYXJnZXQgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLnNjb3BlZFNsb3RzLCBzdGF0ZSkpICsgXCIsXCI7XG4gIH1cbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgaWYgKGVsLm1vZGVsKSB7XG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCwgc3RhdGUpO1xuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgLy8gdi1vbiBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcbiAgICBkYXRhID0gZWwud3JhcExpc3RlbmVycyhkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgdmFyIGdlbiA9IHN0YXRlLmRpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XFxcIlwiICsgKGRpci5hcmcpICsgXCJcXFwiXCIpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgc3RhdGUud2FybignSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyk7XG4gIH1cbiAgaWYgKGFzdC50eXBlID09PSAxKSB7XG4gICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XG4gICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoXG4gIHNsb3RzLFxuICBzdGF0ZVxuKSB7XG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyAoT2JqZWN0LmtleXMoc2xvdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gZ2VuU2NvcGVkU2xvdChrZXksIHNsb3RzW2tleV0sIHN0YXRlKVxuICAgIH0pLmpvaW4oJywnKSkgKyBcIl0pXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKFxuICBrZXksXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3JTY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKVxuICB9XG4gIHZhciBmbiA9IFwiZnVuY3Rpb24oXCIgKyAoU3RyaW5nKGVsLnNsb3RTY29wZSkpICsgXCIpe1wiICtcbiAgICBcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgID8gZWwuaWZcbiAgICAgICAgPyAoKGVsLmlmKSArIFwiP1wiICsgKGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCcpICsgXCI6dW5kZWZpbmVkXCIpXG4gICAgICAgIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ1xuICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCI7XG4gIHJldHVybiAoXCJ7a2V5OlwiICsga2V5ICsgXCIsZm46XCIgKyBmbiArIFwifVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Gb3JTY29wZWRTbG90IChcbiAga2V5LFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArIChnZW5TY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKFxuICBlbCxcbiAgc3RhdGUsXG4gIGNoZWNrU2tpcCxcbiAgYWx0R2VuRWxlbWVudCxcbiAgYWx0R2VuTm9kZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcbiAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBlbCQxLmZvciAmJlxuICAgICAgZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgIGVsJDEudGFnICE9PSAnc2xvdCdcbiAgICApIHtcbiAgICAgIHJldHVybiAoYWx0R2VuRWxlbWVudCB8fCBnZW5FbGVtZW50KShlbCQxLCBzdGF0ZSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICA/IGdldE5vcm1hbGl6YXRpb25UeXBlKGNoaWxkcmVuLCBzdGF0ZS5tYXliZUNvbXBvbmVudClcbiAgICAgIDogMDtcbiAgICB2YXIgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgIHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBnZW4oYywgc3RhdGUpOyB9KS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChcbiAgY2hpbGRyZW4sXG4gIG1heWJlQ29tcG9uZW50XG4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBpZiAobm9kZS50eXBlID09PSAzICYmIG5vZGUuaXNDb21tZW50KSB7XG4gICAgcmV0dXJuIGdlbkNvbW1lbnQobm9kZSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblRleHQgKHRleHQpIHtcbiAgcmV0dXJuIChcIl92KFwiICsgKHRleHQudHlwZSA9PT0gMlxuICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcbiAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuQ29tbWVudCAoY29tbWVudCkge1xuICByZXR1cm4gKFwiX2UoXCIgKyAoSlNPTi5zdHJpbmdpZnkoY29tbWVudC50ZXh0KSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2xvdCAoZWwsIHN0YXRlKSB7XG4gIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSk7XG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gIHZhciBhdHRycyA9IGVsLmF0dHJzICYmIChcIntcIiArIChlbC5hdHRycy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoY2FtZWxpemUoYS5uYW1lKSkgKyBcIjpcIiArIChhLnZhbHVlKSk7IH0pLmpvaW4oJywnKSkgKyBcIn1cIik7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXG4gIGNvbXBvbmVudE5hbWUsXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhJDIoZWwsIHN0YXRlKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAge1xuICAgICAgcmVzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyAodHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpKSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxufVxuXG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICByZXR1cm4gdGV4dFxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxufVxuXG4vKiAgKi9cblxuLy8gdGhlc2Uga2V5d29yZHMgc2hvdWxkIG5vdCBhcHBlYXIgaW5zaWRlIGV4cHJlc3Npb25zLCBidXQgb3BlcmF0b3JzIGxpa2Vcbi8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcbiAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgJ2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXGJ8XFxcXGInKSArICdcXFxcYicpO1xuXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xudmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkZWxldGUsdHlwZW9mLHZvaWQnXG4pLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xudmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0KSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgaWYgKGFzdCkge1xuICAgIGNoZWNrTm9kZShhc3QsIGVycm9ycyk7XG4gIH1cbiAgcmV0dXJuIGVycm9yc1xufVxuXG5mdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIGVycm9ycykge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG4gICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gJ3YtZm9yJykge1xuICAgICAgICAgICAgY2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIGNoZWNrRXZlbnQodmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGVja05vZGUobm9kZS5jaGlsZHJlbltpXSwgZXJyb3JzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCBlcnJvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHZhciBzdGlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuICB2YXIga2V5d29yZE1hdGNoID0gc3RpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgaWYgKGtleXdvcmRNYXRjaCAmJiBzdGlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XG4gICAgZXJyb3JzLnB1c2goXG4gICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxuICAgICk7XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3IgKG5vZGUsIHRleHQsIGVycm9ycykge1xuICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjEsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChcbiAgaWRlbnQsXG4gIHR5cGUsXG4gIHRleHQsXG4gIGVycm9yc1xuKSB7XG4gIGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGdW5jdGlvbigoXCJ2YXIgXCIgKyBpZGVudCArIFwiPV9cIikpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9ycy5wdXNoKChcImludmFsaWQgXCIgKyB0eXBlICsgXCIgXFxcIlwiICsgaWRlbnQgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRnVuY3Rpb24oKFwicmV0dXJuIFwiICsgZXhwKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICBcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCJcXG4gIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ycy5wdXNoKFxuICAgICAgICBcImludmFsaWQgZXhwcmVzc2lvbjogXCIgKyAoZS5tZXNzYWdlKSArIFwiIGluXFxuXFxuXCIgK1xuICAgICAgICBcIiAgICBcIiArIGV4cCArIFwiXFxuXFxuXCIgK1xuICAgICAgICBcIiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSArIFwiXFxuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcnMucHVzaCh7IGVycjogZXJyLCBjb2RlOiBjb2RlIH0pO1xuICAgIHJldHVybiBub29wXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiAoY29tcGlsZSkge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnMsXG4gICAgdm1cbiAgKSB7XG4gICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gICAgdmFyIHdhcm4kJDEgPSBvcHRpb25zLndhcm4gfHwgd2FybjtcbiAgICBkZWxldGUgb3B0aW9ucy53YXJuO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FjaGVcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBjYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbXBpbGVkLmVycm9ycyAmJiBjb21waWxlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIChcIi0gXCIgKyBlKTsgfSkuam9pbignXFxuJykgKyAnXFxuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcbiAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBmbkdlbkVycm9ycyA9IFtdO1xuICAgIHJlcy5yZW5kZXIgPSBjcmVhdGVGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcbiAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGZuR2VuRXJyb3JzKVxuICAgIH0pO1xuXG4gICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgLy8gdGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlcmUgaXMgYSBidWcgaW4gdGhlIGNvbXBpbGVyIGl0c2VsZi5cbiAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgXCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcblwiICtcbiAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdmFyIGVyciA9IHJlZi5lcnI7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xuXG4gICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xuICAgICAgICB9KS5qb2luKCdcXG4nKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoY2FjaGVba2V5XSA9IHJlcylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJDcmVhdG9yIChiYXNlQ29tcGlsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIgKGJhc2VPcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gY29tcGlsZSAoXG4gICAgICB0ZW1wbGF0ZSxcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIHZhciBmaW5hbE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zKTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIHZhciB0aXBzID0gW107XG4gICAgICBmaW5hbE9wdGlvbnMud2FybiA9IGZ1bmN0aW9uIChtc2csIHRpcCkge1xuICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgICAgfTtcblxuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgICAgaWYgKG9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5tb2R1bGVzID1cbiAgICAgICAgICAgIChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoXG4gICAgICAgICAgICBPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMgfHwgbnVsbCksXG4gICAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLCBmaW5hbE9wdGlvbnMpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0KSk7XG4gICAgICB9XG4gICAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICBjb21waWxlZC50aXBzID0gdGlwcztcbiAgICAgIHJldHVybiBjb21waWxlZFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb21waWxlOiBjb21waWxlLFxuICAgICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuKGNvbXBpbGUpXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBgY3JlYXRlQ29tcGlsZXJDcmVhdG9yYCBhbGxvd3MgY3JlYXRpbmcgY29tcGlsZXJzIHRoYXQgdXNlIGFsdGVybmF0aXZlXG4vLyBwYXJzZXIvb3B0aW1pemVyL2NvZGVnZW4sIGUuZyB0aGUgU1NSIG9wdGltaXppbmcgY29tcGlsZXIuXG4vLyBIZXJlIHdlIGp1c3QgZXhwb3J0IGEgZGVmYXVsdCBjb21waWxlciB1c2luZyB0aGUgZGVmYXVsdCBwYXJ0cy5cbnZhciBjcmVhdGVDb21waWxlciA9IGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcihmdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLm9wdGltaXplICE9PSBmYWxzZSkge1xuICAgIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gIH1cbiAgdmFyIGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIGFzdDogYXN0LFxuICAgIHJlbmRlcjogY29kZS5yZW5kZXIsXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59KTtcblxuLyogICovXG5cbnZhciByZWYkMSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcbnZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYkMS5jb21waWxlVG9GdW5jdGlvbnM7XG5cbi8qICAqL1xuXG4vLyBjaGVjayB3aGV0aGVyIGN1cnJlbnQgYnJvd3NlciBlbmNvZGVzIGEgY2hhciBpbnNpZGUgYXR0cmlidXRlIHZhbHVlc1xudmFyIGRpdjtcbmZ1bmN0aW9uIGdldFNob3VsZERlY29kZSAoaHJlZikge1xuICBkaXYgPSBkaXYgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBocmVmID8gXCI8YSBocmVmPVxcXCJcXG5cXFwiLz5cIiA6IFwiPGRpdiBhPVxcXCJcXG5cXFwiLz5cIjtcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZignJiMxMDsnKSA+IDBcbn1cblxuLy8gIzM2NjM6IElFIGVuY29kZXMgbmV3bGluZXMgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZG9uJ3RcbnZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZShmYWxzZSkgOiBmYWxzZTtcbi8vICM2ODI4OiBjaHJvbWUgZW5jb2RlcyBjb250ZW50IGluIGFbaHJlZl1cbnZhciBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUodHJ1ZSkgOiBmYWxzZTtcblxuLyogICovXG5cbnZhciBpZFRvVGVtcGxhdGUgPSBjYWNoZWQoZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBlbCA9IHF1ZXJ5KGlkKTtcbiAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxufSk7XG5cbnZhciBtb3VudCA9IFZ1ZS5wcm90b3R5cGUuJG1vdW50O1xuVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkRvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAvLyByZXNvbHZlIHRlbXBsYXRlL2VsIGFuZCBjb252ZXJ0IHRvIHJlbmRlciBmdW5jdGlvblxuICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XG4gICAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgIHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIChcIlRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiBcIiArIChvcHRpb25zLnRlbXBsYXRlKSksXG4gICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZScpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVmID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgICAgIGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVycyxcbiAgICAgICAgY29tbWVudHM6IG9wdGlvbnMuY29tbWVudHNcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgfVxufVxuXG5WdWUuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuZXhwb3J0IGRlZmF1bHQgVnVlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgVnVlIGZyb20gJ3Z1ZS9kaXN0L3Z1ZS5jb21tb24nO1xuXG4vKipcbiAqIFRoZSBBY2NvcmRpb24gbW9kdWxlXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgQWNjb3JkaW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IFRoZSBBY2NvcmRpb24gRE9NIGVsZW1lbnRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgLyoqIEB0eXBlIHtPYmplY3R9IFRoZSB2dWUgb2JqZWN0ICovXG4gICAgdGhpcy5fdnVlID0ge1xuICAgICAgZGVsaW1pdGVyczogWyd2eycsICd9J10sXG4gICAgICBlbDogYCMke2VsZW1lbnQuaWR9YCxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgYWN0aXZlOiBCb29sZWFuKGVsZW1lbnQuZGF0YXNldC5qc0FjdGl2ZSlcbiAgICAgIH0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHRvZ2dsZTogQWNjb3JkaW9uLnRvZ2dsZSxcbiAgICAgICAgYXJpYUhpZGRlbjogQWNjb3JkaW9uLmFyaWFIaWRkZW5cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtb2R1bGVcbiAgICovXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fdnVlID0gbmV3IFZ1ZSh0aGlzLl92dWUpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIHRvZ2dsZSBtZXRob2QgZm9yIHRoZSBhY3RpdmUgY2xhc3NcbiAqIEBwYXJhbSAge29iamVjdH0gIGV2ZW50IFRoZSBvbiBjbGljayBldmVudCBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgIFRoZSB0b2dnbGVkIGFjdGl2ZSBzdGF0ZVxuICovXG5BY2NvcmRpb24udG9nZ2xlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgdGhpcy5hY3RpdmUgPSAodGhpcy5hY3RpdmUpID8gZmFsc2UgOiB0cnVlO1xuICByZXR1cm4gdGhpcy5hY3RpdmU7XG59O1xuXG4vKipcbiAqIFRoZSBhcmlhIGhpZGRlbiBtZXRob2QgYmFzZWQgb24gd2V0aGVyIHRoZSBjb21wb25lbnQgaXMgYWN0aXZlIG9yIG5vdFxuICogQHBhcmFtICB7Ym9vbGVhbn0gYWN0aXZlIE9wdGlvbmFsbHkgdG8gcGFzcyBhIGJvb2xlYW4gdG8gdGhlIGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgVGhlIGFyaWEtaGlkZGVuIGF0dHJpYnV0ZSBzdHJpbmcgYmFzZWQgb24gYWN0aXZlXG4gKi9cbkFjY29yZGlvbi5hcmlhSGlkZGVuID0gZnVuY3Rpb24oYWN0aXZlID0gdGhpcy5hY3RpdmUpIHtcbiAgcmV0dXJuIChhY3RpdmUpID8gJ2ZhbHNlJyA6ICd0cnVlJztcbn07XG5cbi8qKlxuICogVGhlIGRvbSBzZWxlY3RvciBmb3IgdGhlIG1vZHVsZVxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuQWNjb3JkaW9uLnNlbGVjdG9yID0gJ1tkYXRhLWpzPVwiYWNjb3JkaW9uXCJdJztcblxuZXhwb3J0IGRlZmF1bHQgQWNjb3JkaW9uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgTW9kdWxlIGZyb20gJy4vbW9kdWxlcy9tb2R1bGUnO1xuaW1wb3J0IFRvZ2dsZSBmcm9tICcuL21vZHVsZXMvdG9nZ2xlJztcbmltcG9ydCBBY2NvcmRpb24gZnJvbSAnLi4vY29tcG9uZW50cy9hY2NvcmRpb24vYWNjb3JkaW9uJztcbi8qKiBpbXBvcnQgY29tcG9uZW50cyBoZXJlIGFzIHRoZXkgYXJlIHdyaXR0ZW4uICovXG5cbi8qKlxuICogVGhlIE1haW4gbW9kdWxlXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgbWFpbiB7XG4gIC8qKlxuICAgKiBQbGFjZWhvbGRlciBtb2R1bGUgZm9yIHN0eWxlIHJlZmVyZW5jZS5cbiAgICogQHBhcmFtICB7b2JqZWN0fSBzZXR0aW5ncyBUaGlzIGNvdWxkIGJlIHNvbWUgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgb3IgbW9kdWxlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGRhdGEgICAgIFRoaXMgY291bGQgYmUgYSBzZXQgb2YgZGF0YSB0aGF0IGlzIG5lZWRlZCBmb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgY29tcG9uZW50IG9yIG1vZHVsZSB0byByZW5kZXIuXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgVGhlIG1vZHVsZVxuICAgKi9cbiAgbW9kdWxlKHNldHRpbmdzLCBkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBNb2R1bGUoc2V0dGluZ3MsIGRhdGEpLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBbdG9nZ2xlIGRlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIHRvZ2dsZSgpIHtcbiAgICByZXR1cm4gbmV3IFRvZ2dsZSgpLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBbZmlsdGVyIGRlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtbdHlwZV19IFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIGZpbHRlcigpIHtcbiAgICByZXR1cm4gbmV3IFRvZ2dsZSh7XG4gICAgICBzZWxlY3RvcjogJ1tkYXRhLWpzPVwiZmlsdGVyXCJdJyxcbiAgICAgIG5hbWVzcGFjZTogJ2ZpbHRlcicsXG4gICAgICBpbmFjdGl2ZUNsYXNzOiAnaW5hY3RpdmUnXG4gICAgfSkuaW5pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIEFQSSBmb3IgdGhlIEFjY29yZGlvbiBDb21wb25lbnRcbiAgICovXG4gIGFjY29yZGlvbigpIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKEFjY29yZGlvbi5zZWxlY3RvcilcbiAgICAgIC5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGFjY29yZGlvbiA9IG5ldyBBY2NvcmRpb24oZWxlbWVudCk7XG4gICAgICAgIGFjY29yZGlvbi5pbml0KCk7XG4gICAgICB9KTtcbiAgfVxuICAvKiogYWRkIEFQSXMgaGVyZSBhcyB0aGV5IGFyZSB3cml0dGVuICovXG59XG5cbmV4cG9ydCBkZWZhdWx0IG1haW47XG4iXSwibmFtZXMiOlsiQ29uc3RhbnRzIiwiU1RSSU5HIiwiTlVNQkVSIiwiRkxPQVQiLCJNb2R1bGUiLCJzZXR0aW5ncyIsImRhdGEiLCJjb25zb2xlIiwibG9nIiwiX2NvbnN0YW50cyIsInBhcmFtIiwiZGlyIiwiVG9nZ2xlIiwicyIsIl9zZXR0aW5ncyIsInNlbGVjdG9yIiwibmFtZXNwYWNlIiwiaW5hY3RpdmVDbGFzcyIsImFjdGl2ZUNsYXNzIiwiYm9keSIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsIm1ldGhvZCIsInRhcmdldCIsIm1hdGNoZXMiLCJwcmV2ZW50RGVmYXVsdCIsIl90b2dnbGUiLCJlbCIsImdldEF0dHJpYnV0ZSIsImRhdGFzZXQiLCJfZWxlbWVudFRvZ2dsZSIsIndpbmRvdyIsImxvY2F0aW9uIiwiaGFzaCIsInVuZG8iLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2xhc3NMaXN0IiwidG9nZ2xlIiwic2V0QXR0cmlidXRlIiwiY29udGFpbnMiLCJlbXB0eU9iamVjdCIsIk9iamVjdCIsImZyZWV6ZSIsImlzVW5kZWYiLCJ2IiwidW5kZWZpbmVkIiwiaXNEZWYiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNQcmltaXRpdmUiLCJ2YWx1ZSIsImlzT2JqZWN0Iiwib2JqIiwiX3RvU3RyaW5nIiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJ0b1Jhd1R5cGUiLCJjYWxsIiwic2xpY2UiLCJpc1BsYWluT2JqZWN0IiwiaXNSZWdFeHAiLCJpc1ZhbGlkQXJyYXlJbmRleCIsInZhbCIsIm4iLCJwYXJzZUZsb2F0IiwiU3RyaW5nIiwiTWF0aCIsImZsb29yIiwiaXNGaW5pdGUiLCJKU09OIiwic3RyaW5naWZ5IiwidG9OdW1iZXIiLCJpc05hTiIsIm1ha2VNYXAiLCJzdHIiLCJleHBlY3RzTG93ZXJDYXNlIiwibWFwIiwiY3JlYXRlIiwibGlzdCIsInNwbGl0IiwiaSIsImxlbmd0aCIsInRvTG93ZXJDYXNlIiwiaXNCdWlsdEluVGFnIiwiaXNSZXNlcnZlZEF0dHJpYnV0ZSIsInJlbW92ZSIsImFyciIsIml0ZW0iLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImhhc093biIsImtleSIsImNhY2hlZCIsImZuIiwiY2FjaGUiLCJjYWNoZWRGbiIsImhpdCIsImNhbWVsaXplUkUiLCJjYW1lbGl6ZSIsInJlcGxhY2UiLCJfIiwiYyIsInRvVXBwZXJDYXNlIiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwicG9seWZpbGxCaW5kIiwiY3R4IiwiYm91bmRGbiIsImEiLCJsIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJfbGVuZ3RoIiwibmF0aXZlQmluZCIsImJpbmQiLCJGdW5jdGlvbiIsInRvQXJyYXkiLCJzdGFydCIsInJldCIsIkFycmF5IiwiZXh0ZW5kIiwidG8iLCJfZnJvbSIsInRvT2JqZWN0IiwicmVzIiwibm9vcCIsImIiLCJubyIsImlkZW50aXR5IiwiZ2VuU3RhdGljS2V5cyIsIm1vZHVsZXMiLCJyZWR1Y2UiLCJrZXlzIiwibSIsImNvbmNhdCIsInN0YXRpY0tleXMiLCJqb2luIiwibG9vc2VFcXVhbCIsImlzT2JqZWN0QSIsImlzT2JqZWN0QiIsImlzQXJyYXlBIiwiaXNBcnJheSIsImlzQXJyYXlCIiwiZXZlcnkiLCJlIiwia2V5c0EiLCJrZXlzQiIsImxvb3NlSW5kZXhPZiIsIm9uY2UiLCJjYWxsZWQiLCJTU1JfQVRUUiIsIkFTU0VUX1RZUEVTIiwiTElGRUNZQ0xFX0hPT0tTIiwiY29uZmlnIiwib3B0aW9uTWVyZ2VTdHJhdGVnaWVzIiwic2lsZW50IiwicHJvZHVjdGlvblRpcCIsInByb2Nlc3MiLCJkZXZ0b29scyIsInBlcmZvcm1hbmNlIiwiZXJyb3JIYW5kbGVyIiwid2FybkhhbmRsZXIiLCJpZ25vcmVkRWxlbWVudHMiLCJrZXlDb2RlcyIsImlzUmVzZXJ2ZWRUYWciLCJpc1Jlc2VydmVkQXR0ciIsImlzVW5rbm93bkVsZW1lbnQiLCJnZXRUYWdOYW1lc3BhY2UiLCJwYXJzZVBsYXRmb3JtVGFnTmFtZSIsIm11c3RVc2VQcm9wIiwiX2xpZmVjeWNsZUhvb2tzIiwiaXNSZXNlcnZlZCIsImNoYXJDb2RlQXQiLCJkZWYiLCJlbnVtZXJhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImJhaWxSRSIsInBhcnNlUGF0aCIsInBhdGgiLCJ0ZXN0Iiwic2VnbWVudHMiLCJoYXNQcm90byIsImluQnJvd3NlciIsImluV2VleCIsIldYRW52aXJvbm1lbnQiLCJwbGF0Zm9ybSIsIndlZXhQbGF0Zm9ybSIsIlVBIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNJRSIsImlzSUU5IiwiaXNFZGdlIiwiaXNBbmRyb2lkIiwiaXNJT1MiLCJpc0Nocm9tZSIsIm5hdGl2ZVdhdGNoIiwid2F0Y2giLCJzdXBwb3J0c1Bhc3NpdmUiLCJvcHRzIiwiZ2V0IiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXJSZW5kZXJpbmciLCJnbG9iYWwiLCJlbnYiLCJWVUVfRU5WIiwiX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImlzTmF0aXZlIiwiQ3RvciIsImhhc1N5bWJvbCIsIlN5bWJvbCIsIlJlZmxlY3QiLCJvd25LZXlzIiwiX1NldCIsIlNldCIsInNldCIsImhhcyIsImFkZCIsImNsZWFyIiwid2FybiIsInVpZCIsIkRlcCIsImlkIiwic3VicyIsImFkZFN1YiIsInN1YiIsInB1c2giLCJyZW1vdmVTdWIiLCJkZXBlbmQiLCJhZGREZXAiLCJub3RpZnkiLCJ1cGRhdGUiLCJ0YXJnZXRTdGFjayIsInB1c2hUYXJnZXQiLCJfdGFyZ2V0IiwicG9wVGFyZ2V0IiwicG9wIiwiVk5vZGUiLCJ0YWciLCJjaGlsZHJlbiIsInRleHQiLCJlbG0iLCJjb250ZXh0IiwiY29tcG9uZW50T3B0aW9ucyIsImFzeW5jRmFjdG9yeSIsIm5zIiwiZm5Db250ZXh0IiwiZm5PcHRpb25zIiwiZm5TY29wZUlkIiwiY29tcG9uZW50SW5zdGFuY2UiLCJwYXJlbnQiLCJyYXciLCJpc1N0YXRpYyIsImlzUm9vdEluc2VydCIsImlzQ29tbWVudCIsImlzQ2xvbmVkIiwiaXNPbmNlIiwiYXN5bmNNZXRhIiwiaXNBc3luY1BsYWNlaG9sZGVyIiwicHJvdG90eXBlQWNjZXNzb3JzIiwiY2hpbGQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY3JlYXRlRW1wdHlWTm9kZSIsIm5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwidm5vZGUiLCJjbG9uZWQiLCJhcnJheVByb3RvIiwiYXJyYXlNZXRob2RzIiwibWV0aG9kc1RvUGF0Y2giLCJmb3JFYWNoIiwib3JpZ2luYWwiLCJtdXRhdG9yIiwiYXJncyIsImxlbiIsInJlc3VsdCIsIm9iIiwiX19vYl9fIiwiaW5zZXJ0ZWQiLCJvYnNlcnZlQXJyYXkiLCJkZXAiLCJhcnJheUtleXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwic2hvdWxkT2JzZXJ2ZSIsInRvZ2dsZU9ic2VydmluZyIsIk9ic2VydmVyIiwidm1Db3VudCIsImF1Z21lbnQiLCJwcm90b0F1Z21lbnQiLCJjb3B5QXVnbWVudCIsIndhbGsiLCJkZWZpbmVSZWFjdGl2ZSIsIml0ZW1zIiwib2JzZXJ2ZSIsInNyYyIsIl9fcHJvdG9fXyIsImFzUm9vdERhdGEiLCJpc0V4dGVuc2libGUiLCJfaXNWdWUiLCJjdXN0b21TZXR0ZXIiLCJzaGFsbG93IiwicHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnZXR0ZXIiLCJzZXR0ZXIiLCJjaGlsZE9iIiwicmVhY3RpdmVHZXR0ZXIiLCJkZXBlbmRBcnJheSIsInJlYWN0aXZlU2V0dGVyIiwibmV3VmFsIiwibWF4IiwiZGVsIiwic3RyYXRzIiwibWVyZ2VEYXRhIiwiZnJvbSIsInRvVmFsIiwiZnJvbVZhbCIsIm1lcmdlRGF0YU9yRm4iLCJwYXJlbnRWYWwiLCJjaGlsZFZhbCIsInZtIiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkSW5zdGFuY2VEYXRhRm4iLCJpbnN0YW5jZURhdGEiLCJkZWZhdWx0RGF0YSIsIm1lcmdlSG9vayIsImhvb2siLCJtZXJnZUFzc2V0cyIsInR5cGUiLCJrZXkkMSIsInByb3BzIiwibWV0aG9kcyIsImluamVjdCIsImNvbXB1dGVkIiwiYXNzZXJ0T2JqZWN0VHlwZSIsInByb3ZpZGUiLCJkZWZhdWx0U3RyYXQiLCJub3JtYWxpemVQcm9wcyIsIm9wdGlvbnMiLCJuYW1lIiwibm9ybWFsaXplSW5qZWN0Iiwibm9ybWFsaXplZCIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMiLCJkaXJzIiwiZGlyZWN0aXZlcyIsIm1lcmdlT3B0aW9ucyIsImV4dGVuZHNGcm9tIiwiZXh0ZW5kcyIsIm1peGlucyIsIm1lcmdlRmllbGQiLCJzdHJhdCIsInJlc29sdmVBc3NldCIsIndhcm5NaXNzaW5nIiwiYXNzZXRzIiwiY2FtZWxpemVkSWQiLCJQYXNjYWxDYXNlSWQiLCJ2YWxpZGF0ZVByb3AiLCJwcm9wT3B0aW9ucyIsInByb3BzRGF0YSIsInByb3AiLCJhYnNlbnQiLCJib29sZWFuSW5kZXgiLCJnZXRUeXBlSW5kZXgiLCJCb29sZWFuIiwic3RyaW5nSW5kZXgiLCJnZXRQcm9wRGVmYXVsdFZhbHVlIiwicHJldlNob3VsZE9ic2VydmUiLCJkZWZhdWx0IiwiJG9wdGlvbnMiLCJfcHJvcHMiLCJnZXRUeXBlIiwibWF0Y2giLCJpc1NhbWVUeXBlIiwiZXhwZWN0ZWRUeXBlcyIsImhhbmRsZUVycm9yIiwiZXJyIiwiaW5mbyIsImN1ciIsIiRwYXJlbnQiLCJob29rcyIsImVycm9yQ2FwdHVyZWQiLCJjYXB0dXJlIiwiZ2xvYmFsSGFuZGxlRXJyb3IiLCJsb2dFcnJvciIsImVycm9yIiwiY2FsbGJhY2tzIiwicGVuZGluZyIsImZsdXNoQ2FsbGJhY2tzIiwiY29waWVzIiwibWljcm9UaW1lckZ1bmMiLCJtYWNyb1RpbWVyRnVuYyIsInVzZU1hY3JvVGFzayIsInNldEltbWVkaWF0ZSIsIk1lc3NhZ2VDaGFubmVsIiwiY2hhbm5lbCIsInBvcnQiLCJwb3J0MiIsInBvcnQxIiwib25tZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJzZXRUaW1lb3V0IiwiUHJvbWlzZSIsInAiLCJyZXNvbHZlIiwidGhlbiIsIndpdGhNYWNyb1Rhc2siLCJfd2l0aFRhc2siLCJuZXh0VGljayIsImNiIiwiX3Jlc29sdmUiLCJtYXJrIiwic2Vlbk9iamVjdHMiLCJ0cmF2ZXJzZSIsIl90cmF2ZXJzZSIsInNlZW4iLCJpc0EiLCJpc0Zyb3plbiIsImRlcElkIiwibm9ybWFsaXplRXZlbnQiLCJwYXNzaXZlIiwib25jZSQkMSIsImNyZWF0ZUZuSW52b2tlciIsImZucyIsImludm9rZXIiLCJhcmd1bWVudHMkMSIsInVwZGF0ZUxpc3RlbmVycyIsIm9uIiwib2xkT24iLCJyZW1vdmUkJDEiLCJvbGQiLCJwYXJhbXMiLCJtZXJnZVZOb2RlSG9vayIsImhvb2tLZXkiLCJvbGRIb29rIiwid3JhcHBlZEhvb2siLCJtZXJnZWQiLCJleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIiwiYXR0cnMiLCJhbHRLZXkiLCJjaGVja1Byb3AiLCJwcmVzZXJ2ZSIsInNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQ2hpbGRyZW4iLCJub3JtYWxpemVBcnJheUNoaWxkcmVuIiwiaXNUZXh0Tm9kZSIsIm5lc3RlZEluZGV4IiwibGFzdEluZGV4IiwibGFzdCIsInNoaWZ0IiwiX2lzVkxpc3QiLCJlbnN1cmVDdG9yIiwiY29tcCIsImJhc2UiLCJfX2VzTW9kdWxlIiwidG9TdHJpbmdUYWciLCJjcmVhdGVBc3luY1BsYWNlaG9sZGVyIiwiZmFjdG9yeSIsInJlc29sdmVBc3luY0NvbXBvbmVudCIsImJhc2VDdG9yIiwiZXJyb3JDb21wIiwicmVzb2x2ZWQiLCJsb2FkaW5nIiwibG9hZGluZ0NvbXAiLCJjb250ZXh0cyIsInN5bmMiLCJmb3JjZVJlbmRlciIsIiRmb3JjZVVwZGF0ZSIsInJlamVjdCIsInJlYXNvbiIsImNvbXBvbmVudCIsImRlbGF5IiwidGltZW91dCIsImdldEZpcnN0Q29tcG9uZW50Q2hpbGQiLCJpbml0RXZlbnRzIiwiX2V2ZW50cyIsIl9oYXNIb29rRXZlbnQiLCJsaXN0ZW5lcnMiLCJfcGFyZW50TGlzdGVuZXJzIiwidXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIiwiJG9uY2UiLCIkb24iLCJyZW1vdmUkMSIsIiRvZmYiLCJvbGRMaXN0ZW5lcnMiLCJldmVudHNNaXhpbiIsIlZ1ZSIsImhvb2tSRSIsInRoaXMkMSIsImNicyIsImkkMSIsIiRlbWl0IiwicmVzb2x2ZVNsb3RzIiwic2xvdHMiLCJzbG90IiwibmFtZSQxIiwiaXNXaGl0ZXNwYWNlIiwicmVzb2x2ZVNjb3BlZFNsb3RzIiwiYWN0aXZlSW5zdGFuY2UiLCJpbml0TGlmZWN5Y2xlIiwiYWJzdHJhY3QiLCIkY2hpbGRyZW4iLCIkcm9vdCIsIiRyZWZzIiwiX3dhdGNoZXIiLCJfaW5hY3RpdmUiLCJfZGlyZWN0SW5hY3RpdmUiLCJfaXNNb3VudGVkIiwiX2lzRGVzdHJveWVkIiwiX2lzQmVpbmdEZXN0cm95ZWQiLCJsaWZlY3ljbGVNaXhpbiIsIl91cGRhdGUiLCJoeWRyYXRpbmciLCJjYWxsSG9vayIsInByZXZFbCIsIiRlbCIsInByZXZWbm9kZSIsIl92bm9kZSIsInByZXZBY3RpdmVJbnN0YW5jZSIsIl9fcGF0Y2hfXyIsIl9wYXJlbnRFbG0iLCJfcmVmRWxtIiwiX192dWVfXyIsIiR2bm9kZSIsIiRkZXN0cm95IiwidGVhcmRvd24iLCJfd2F0Y2hlcnMiLCJfZGF0YSIsIm1vdW50Q29tcG9uZW50IiwicmVuZGVyIiwidXBkYXRlQ29tcG9uZW50IiwiX3JlbmRlciIsIldhdGNoZXIiLCJ1cGRhdGVDaGlsZENvbXBvbmVudCIsInBhcmVudFZub2RlIiwicmVuZGVyQ2hpbGRyZW4iLCJoYXNDaGlsZHJlbiIsIl9yZW5kZXJDaGlsZHJlbiIsInNjb3BlZFNsb3RzIiwiJHNjb3BlZFNsb3RzIiwiX3BhcmVudFZub2RlIiwiJGF0dHJzIiwiJGxpc3RlbmVycyIsInByb3BLZXlzIiwiX3Byb3BLZXlzIiwiJHNsb3RzIiwiaXNJbkluYWN0aXZlVHJlZSIsImFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJkaXJlY3QiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJoYW5kbGVycyIsImoiLCJxdWV1ZSIsImFjdGl2YXRlZENoaWxkcmVuIiwid2FpdGluZyIsImZsdXNoaW5nIiwicmVzZXRTY2hlZHVsZXJTdGF0ZSIsImZsdXNoU2NoZWR1bGVyUXVldWUiLCJ3YXRjaGVyIiwic29ydCIsInJ1biIsImFjdGl2YXRlZFF1ZXVlIiwidXBkYXRlZFF1ZXVlIiwiY2FsbEFjdGl2YXRlZEhvb2tzIiwiY2FsbFVwZGF0ZWRIb29rcyIsImVtaXQiLCJxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCIsInF1ZXVlV2F0Y2hlciIsInVpZCQxIiwiZXhwT3JGbiIsImlzUmVuZGVyV2F0Y2hlciIsImRlZXAiLCJ1c2VyIiwibGF6eSIsImFjdGl2ZSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJleHByZXNzaW9uIiwiY2xlYW51cERlcHMiLCJ0bXAiLCJvbGRWYWx1ZSIsImV2YWx1YXRlIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsInByb3BzT3B0aW9ucyIsImlzUm9vdCIsImxvb3AiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJpc1NTUiIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsInNob3VsZENhY2hlIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJjb21wdXRlZEdldHRlciIsImhhbmRsZXIiLCJjcmVhdGVXYXRjaGVyIiwiJHdhdGNoIiwic3RhdGVNaXhpbiIsImRhdGFEZWYiLCJwcm9wc0RlZiIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwiaW5pdFByb3ZpZGUiLCJfcHJvdmlkZWQiLCJpbml0SW5qZWN0aW9ucyIsInJlc29sdmVJbmplY3QiLCJmaWx0ZXIiLCJwcm92aWRlS2V5Iiwic291cmNlIiwicHJvdmlkZURlZmF1bHQiLCJyZW5kZXJMaXN0IiwicmVuZGVyU2xvdCIsImZhbGxiYWNrIiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsIm5vZGVzIiwic2xvdE5vZGVzIiwiX3JlbmRlcmVkIiwiJGNyZWF0ZUVsZW1lbnQiLCJyZXNvbHZlRmlsdGVyIiwiaXNLZXlOb3RNYXRjaCIsImV4cGVjdCIsImFjdHVhbCIsImNoZWNrS2V5Q29kZXMiLCJldmVudEtleUNvZGUiLCJidWlsdEluS2V5Q29kZSIsImV2ZW50S2V5TmFtZSIsImJ1aWx0SW5LZXlOYW1lIiwibWFwcGVkS2V5Q29kZSIsImJpbmRPYmplY3RQcm9wcyIsImFzUHJvcCIsImlzU3luYyIsImRvbVByb3BzIiwiJGV2ZW50IiwicmVuZGVyU3RhdGljIiwiaXNJbkZvciIsIl9zdGF0aWNUcmVlcyIsInRyZWUiLCJzdGF0aWNSZW5kZXJGbnMiLCJfcmVuZGVyUHJveHkiLCJtYXJrU3RhdGljIiwibWFya09uY2UiLCJtYXJrU3RhdGljTm9kZSIsImJpbmRPYmplY3RMaXN0ZW5lcnMiLCJleGlzdGluZyIsIm91cnMiLCJpbnN0YWxsUmVuZGVySGVscGVycyIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJfZyIsIkZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IiwiY29udGV4dFZtIiwiX29yaWdpbmFsIiwiaXNDb21waWxlZCIsIl9jb21waWxlZCIsIm5lZWROb3JtYWxpemF0aW9uIiwiaW5qZWN0aW9ucyIsIl9zY29wZUlkIiwiX2MiLCJkIiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQiLCJtZXJnZVByb3BzIiwicmVuZGVyQ29udGV4dCIsImNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQiLCJ2bm9kZXMiLCJjbG9uZSIsImNvbXBvbmVudFZOb2RlSG9va3MiLCJpbml0IiwicGFyZW50RWxtIiwicmVmRWxtIiwia2VlcEFsaXZlIiwibW91bnRlZE5vZGUiLCJwcmVwYXRjaCIsImNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUiLCIkbW91bnQiLCJvbGRWbm9kZSIsImluc2VydCIsImRlc3Ryb3kiLCJob29rc1RvTWVyZ2UiLCJjcmVhdGVDb21wb25lbnQiLCJfYmFzZSIsImNpZCIsInJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMiLCJtb2RlbCIsInRyYW5zZm9ybU1vZGVsIiwiZnVuY3Rpb25hbCIsIm5hdGl2ZU9uIiwiaW5zdGFsbENvbXBvbmVudEhvb2tzIiwiX2lzQ29tcG9uZW50IiwiaW5saW5lVGVtcGxhdGUiLCJjYWxsYmFjayIsIlNJTVBMRV9OT1JNQUxJWkUiLCJBTFdBWVNfTk9STUFMSVpFIiwibm9ybWFsaXphdGlvblR5cGUiLCJhbHdheXNOb3JtYWxpemUiLCJfY3JlYXRlRWxlbWVudCIsImlzIiwiYXBwbHlOUyIsInJlZ2lzdGVyRGVlcEJpbmRpbmdzIiwiZm9yY2UiLCJzdHlsZSIsImNsYXNzIiwiaW5pdFJlbmRlciIsInBhcmVudERhdGEiLCJyZW5kZXJNaXhpbiIsIiRuZXh0VGljayIsInJlZiIsInVpZCQzIiwiaW5pdE1peGluIiwiX2luaXQiLCJfdWlkIiwiaW5pdEludGVybmFsQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJfc2VsZiIsInZub2RlQ29tcG9uZW50T3B0aW9ucyIsIl9jb21wb25lbnRUYWciLCJzdXBlciIsInN1cGVyT3B0aW9ucyIsImNhY2hlZFN1cGVyT3B0aW9ucyIsIm1vZGlmaWVkT3B0aW9ucyIsInJlc29sdmVNb2RpZmllZE9wdGlvbnMiLCJleHRlbmRPcHRpb25zIiwiY29tcG9uZW50cyIsIm1vZGlmaWVkIiwibGF0ZXN0IiwiZXh0ZW5kZWQiLCJzZWFsZWQiLCJzZWFsZWRPcHRpb25zIiwiZGVkdXBlIiwiaW5pdFVzZSIsInVzZSIsInBsdWdpbiIsImluc3RhbGxlZFBsdWdpbnMiLCJfaW5zdGFsbGVkUGx1Z2lucyIsInVuc2hpZnQiLCJpbnN0YWxsIiwiaW5pdE1peGluJDEiLCJtaXhpbiIsImluaXRFeHRlbmQiLCJTdXBlciIsIlN1cGVySWQiLCJjYWNoZWRDdG9ycyIsIl9DdG9yIiwiU3ViIiwiVnVlQ29tcG9uZW50IiwiaW5pdFByb3BzJDEiLCJpbml0Q29tcHV0ZWQkMSIsIkNvbXAiLCJpbml0QXNzZXRSZWdpc3RlcnMiLCJkZWZpbml0aW9uIiwiZ2V0Q29tcG9uZW50TmFtZSIsInBhdHRlcm4iLCJwcnVuZUNhY2hlIiwia2VlcEFsaXZlSW5zdGFuY2UiLCJjYWNoZWROb2RlIiwicHJ1bmVDYWNoZUVudHJ5IiwiY3VycmVudCIsImNhY2hlZCQkMSIsInBhdHRlcm5UeXBlcyIsIlJlZ0V4cCIsIktlZXBBbGl2ZSIsImluY2x1ZGUiLCJleGNsdWRlIiwiTnVtYmVyIiwiY3JlYXRlZCIsImRlc3Ryb3llZCIsIm1vdW50ZWQiLCJyZWYkMSIsInBhcnNlSW50IiwiYnVpbHRJbkNvbXBvbmVudHMiLCJpbml0R2xvYmFsQVBJIiwiY29uZmlnRGVmIiwidXRpbCIsImRlbGV0ZSIsInNzckNvbnRleHQiLCJ2ZXJzaW9uIiwiYWNjZXB0VmFsdWUiLCJhdHRyIiwiaXNFbnVtZXJhdGVkQXR0ciIsImlzQm9vbGVhbkF0dHIiLCJ4bGlua05TIiwiaXNYbGluayIsImdldFhsaW5rUHJvcCIsImlzRmFsc3lBdHRyVmFsdWUiLCJnZW5DbGFzc0ZvclZub2RlIiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwicmVuZGVyQ2xhc3MiLCJzdGF0aWNDbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsImlzUHJlVGFnIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsIkhUTUxVbmtub3duRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNUZXh0SW5wdXRUeXBlIiwicXVlcnkiLCJzZWxlY3RlZCIsImNyZWF0ZUVsZW1lbnQkMSIsInRhZ05hbWUiLCJtdWx0aXBsZSIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEJlZm9yZSIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsInNldFN0eWxlU2NvcGUiLCJzY29wZUlkIiwibm9kZU9wcyIsInJlZ2lzdGVyUmVmIiwiaXNSZW1vdmFsIiwicmVmcyIsInJlZkluRm9yIiwiZW1wdHlOb2RlIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJjcmVhdGVFbG0iLCJpbnNlcnRlZFZub2RlUXVldWUiLCJuZXN0ZWQiLCJvd25lckFycmF5Iiwic2V0U2NvcGUiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwicmVmJCQxIiwiYW5jZXN0b3IiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJ2bm9kZVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwiZmluZElkeEluT2xkIiwiZW5kIiwiaHlkcmF0ZSIsInBvc3RwYXRjaCIsImludm9rZUluc2VydEhvb2siLCJpbml0aWFsIiwiaXNSZW5kZXJlZE1vZHVsZSIsImluVlByZSIsInByZSIsImhhc0NoaWxkTm9kZXMiLCJpbm5lckhUTUwiLCJjaGlsZHJlbk1hdGNoIiwiZmlyc3RDaGlsZCIsImZ1bGxJbnZva2UiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsIm5vZGVUeXBlIiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwib2xkRWxtIiwicGFyZW50RWxtJDEiLCJfbGVhdmVDYiIsInBhdGNoYWJsZSIsImkkMiIsInVwZGF0ZURpcmVjdGl2ZXMiLCJ1bmJpbmREaXJlY3RpdmVzIiwiaXNDcmVhdGUiLCJpc0Rlc3Ryb3kiLCJvbGREaXJzIiwibm9ybWFsaXplRGlyZWN0aXZlcyQxIiwibmV3RGlycyIsImRpcnNXaXRoSW5zZXJ0IiwiZGlyc1dpdGhQb3N0cGF0Y2giLCJvbGREaXIiLCJjYWxsSG9vayQxIiwiY29tcG9uZW50VXBkYXRlZCIsImNhbGxJbnNlcnQiLCJlbXB0eU1vZGlmaWVycyIsIm1vZGlmaWVycyIsImdldFJhd0Rpck5hbWUiLCJyYXdOYW1lIiwiYmFzZU1vZHVsZXMiLCJ1cGRhdGVBdHRycyIsImluaGVyaXRBdHRycyIsIm9sZEF0dHJzIiwic2V0QXR0ciIsInJlbW92ZUF0dHJpYnV0ZU5TIiwiYmFzZVNldEF0dHIiLCJzZXRBdHRyaWJ1dGVOUyIsIl9faWVwaCIsImJsb2NrZXIiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJ1cGRhdGVDbGFzcyIsIm9sZERhdGEiLCJjbHMiLCJ0cmFuc2l0aW9uQ2xhc3MiLCJfdHJhbnNpdGlvbkNsYXNzZXMiLCJfcHJldkNsYXNzIiwia2xhc3MiLCJ2YWxpZERpdmlzaW9uQ2hhclJFIiwicGFyc2VGaWx0ZXJzIiwiZXhwIiwiaW5TaW5nbGUiLCJpbkRvdWJsZSIsImluVGVtcGxhdGVTdHJpbmciLCJpblJlZ2V4IiwiY3VybHkiLCJzcXVhcmUiLCJwYXJlbiIsImxhc3RGaWx0ZXJJbmRleCIsInByZXYiLCJmaWx0ZXJzIiwidHJpbSIsInB1c2hGaWx0ZXIiLCJ3cmFwRmlsdGVyIiwiYmFzZVdhcm4iLCJtc2ciLCJwbHVja01vZHVsZUZ1bmN0aW9uIiwiYWRkUHJvcCIsInBsYWluIiwiYWRkQXR0ciIsImFkZFJhd0F0dHIiLCJhdHRyc01hcCIsImF0dHJzTGlzdCIsImFkZERpcmVjdGl2ZSIsImFyZyIsImFkZEhhbmRsZXIiLCJpbXBvcnRhbnQiLCJyaWdodCIsIm1pZGRsZSIsImV2ZW50cyIsIm5hdGl2ZSIsIm5hdGl2ZUV2ZW50cyIsIm5ld0hhbmRsZXIiLCJnZXRCaW5kaW5nQXR0ciIsImdldFN0YXRpYyIsImR5bmFtaWNWYWx1ZSIsImdldEFuZFJlbW92ZUF0dHIiLCJzdGF0aWNWYWx1ZSIsInJlbW92ZUZyb21NYXAiLCJnZW5Db21wb25lbnRNb2RlbCIsIm51bWJlciIsImJhc2VWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZUV4cHJlc3Npb24iLCJhc3NpZ25tZW50IiwiZ2VuQXNzaWdubWVudENvZGUiLCJwYXJzZU1vZGVsIiwiY2hyIiwiaW5kZXgkMSIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwibGFzdEluZGV4T2YiLCJlb2YiLCJuZXh0IiwiaXNTdHJpbmdTdGFydCIsInBhcnNlU3RyaW5nIiwicGFyc2VCcmFja2V0IiwiaW5CcmFja2V0Iiwic3RyaW5nUXVvdGUiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwiX3dhcm4iLCJ3YXJuJDEiLCJnZW5TZWxlY3QiLCJnZW5DaGVja2JveE1vZGVsIiwiZ2VuUmFkaW9Nb2RlbCIsImdlbkRlZmF1bHRNb2RlbCIsInZhbHVlQmluZGluZyIsInRydWVWYWx1ZUJpbmRpbmciLCJmYWxzZVZhbHVlQmluZGluZyIsInNlbGVjdGVkVmFsIiwiY29kZSIsIm5lZWRDb21wb3NpdGlvbkd1YXJkIiwibm9ybWFsaXplRXZlbnRzIiwiY2hhbmdlIiwidGFyZ2V0JDEiLCJjcmVhdGVPbmNlSGFuZGxlciIsIm9uY2VIYW5kbGVyIiwicmVtb3ZlJDIiLCJhZGQkMSIsInVwZGF0ZURPTUxpc3RlbmVycyIsInVwZGF0ZURPTVByb3BzIiwib2xkUHJvcHMiLCJjaGlsZE5vZGVzIiwiX3ZhbHVlIiwic3RyQ3VyIiwic2hvdWxkVXBkYXRlVmFsdWUiLCJjaGVja1ZhbCIsImNvbXBvc2luZyIsImlzTm90SW5Gb2N1c0FuZERpcnR5IiwiaXNEaXJ0eVdpdGhNb2RpZmllcnMiLCJub3RJbkZvY3VzIiwiYWN0aXZlRWxlbWVudCIsIl92TW9kaWZpZXJzIiwicGFyc2VTdHlsZVRleHQiLCJjc3NUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJnZXRTdHlsZSIsImNoZWNrQ2hpbGQiLCJzdHlsZURhdGEiLCJjc3NWYXJSRSIsImltcG9ydGFudFJFIiwic2V0UHJvcCIsInNldFByb3BlcnR5Iiwibm9ybWFsaXplZE5hbWUiLCJub3JtYWxpemUiLCJ2ZW5kb3JOYW1lcyIsImVtcHR5U3R5bGUiLCJjYXBOYW1lIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm5vcm1hbGl6ZWRTdHlsZSIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVzb2x2ZVRyYW5zaXRpb24iLCJjc3MiLCJhdXRvQ3NzVHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJoYXNUcmFuc2l0aW9uIiwiVFJBTlNJVElPTiIsIkFOSU1BVElPTiIsInRyYW5zaXRpb25Qcm9wIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkVuZEV2ZW50Iiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInRyYW5zaXRpb25DbGFzc2VzIiwicmVtb3ZlVHJhbnNpdGlvbkNsYXNzIiwid2hlblRyYW5zaXRpb25FbmRzIiwiZXhwZWN0ZWRUeXBlIiwiZ2V0VHJhbnNpdGlvbkluZm8iLCJwcm9wQ291bnQiLCJlbmRlZCIsIm9uRW5kIiwidHJhbnNmb3JtUkUiLCJzdHlsZXMiLCJnZXRDb21wdXRlZFN0eWxlIiwidHJhbnNpdGlvbkRlbGF5cyIsInRyYW5zaXRpb25EdXJhdGlvbnMiLCJ0cmFuc2l0aW9uVGltZW91dCIsImdldFRpbWVvdXQiLCJhbmltYXRpb25EZWxheXMiLCJhbmltYXRpb25EdXJhdGlvbnMiLCJhbmltYXRpb25UaW1lb3V0IiwiaGFzVHJhbnNmb3JtIiwiZGVsYXlzIiwiZHVyYXRpb25zIiwidG9NcyIsImVudGVyIiwidG9nZ2xlRGlzcGxheSIsImNhbmNlbGxlZCIsIl9lbnRlckNiIiwiYXBwZWFyQ2xhc3MiLCJhcHBlYXJUb0NsYXNzIiwiYXBwZWFyQWN0aXZlQ2xhc3MiLCJiZWZvcmVFbnRlciIsImFmdGVyRW50ZXIiLCJlbnRlckNhbmNlbGxlZCIsImJlZm9yZUFwcGVhciIsImFwcGVhciIsImFmdGVyQXBwZWFyIiwiYXBwZWFyQ2FuY2VsbGVkIiwiZHVyYXRpb24iLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsInRvQ2xhc3MiLCJiZWZvcmVFbnRlckhvb2siLCJlbnRlckhvb2siLCJhZnRlckVudGVySG9vayIsImVudGVyQ2FuY2VsbGVkSG9vayIsImV4cGxpY2l0RW50ZXJEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInNob3ciLCJwZW5kaW5nTm9kZSIsIl9wZW5kaW5nIiwiaXNWYWxpZER1cmF0aW9uIiwibGVhdmUiLCJiZWZvcmVMZWF2ZSIsImFmdGVyTGVhdmUiLCJsZWF2ZUNhbmNlbGxlZCIsImRlbGF5TGVhdmUiLCJleHBsaWNpdExlYXZlRHVyYXRpb24iLCJwZXJmb3JtTGVhdmUiLCJpbnZva2VyRm5zIiwiX2VudGVyIiwicGxhdGZvcm1Nb2R1bGVzIiwidm1vZGVsIiwidHJpZ2dlciIsImRpcmVjdGl2ZSIsImJpbmRpbmciLCJfdk9wdGlvbnMiLCJzZXRTZWxlY3RlZCIsImdldFZhbHVlIiwib25Db21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvbkVuZCIsInByZXZPcHRpb25zIiwiY3VyT3B0aW9ucyIsInNvbWUiLCJvIiwibmVlZFJlc2V0IiwiaGFzTm9NYXRjaGluZ09wdGlvbiIsImFjdHVhbGx5U2V0U2VsZWN0ZWQiLCJpc011bHRpcGxlIiwib3B0aW9uIiwic2VsZWN0ZWRJbmRleCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImxvY2F0ZU5vZGUiLCJ0cmFuc2l0aW9uJCQxIiwib3JpZ2luYWxEaXNwbGF5IiwiX192T3JpZ2luYWxEaXNwbGF5IiwiZGlzcGxheSIsInVuYmluZCIsInBsYXRmb3JtRGlyZWN0aXZlcyIsInRyYW5zaXRpb25Qcm9wcyIsIm1vZGUiLCJnZXRSZWFsQ2hpbGQiLCJjb21wT3B0aW9ucyIsImV4dHJhY3RUcmFuc2l0aW9uRGF0YSIsInBsYWNlaG9sZGVyIiwiaCIsInJhd0NoaWxkIiwiaGFzUGFyZW50VHJhbnNpdGlvbiIsImlzU2FtZUNoaWxkIiwib2xkQ2hpbGQiLCJUcmFuc2l0aW9uIiwiX2xlYXZpbmciLCJvbGRSYXdDaGlsZCIsImRlbGF5ZWRMZWF2ZSIsIm1vdmVDbGFzcyIsIlRyYW5zaXRpb25Hcm91cCIsInByZXZDaGlsZHJlbiIsInJhd0NoaWxkcmVuIiwidHJhbnNpdGlvbkRhdGEiLCJrZXB0IiwicmVtb3ZlZCIsImMkMSIsInBvcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImJlZm9yZVVwZGF0ZSIsInVwZGF0ZWQiLCJoYXNNb3ZlIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsImFwcGx5VHJhbnNsYXRpb24iLCJfcmVmbG93Iiwib2Zmc2V0SGVpZ2h0IiwibW92ZWQiLCJ0cmFuc2Zvcm0iLCJXZWJraXRUcmFuc2Zvcm0iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJfbW92ZUNiIiwicHJvcGVydHlOYW1lIiwiX2hhc01vdmUiLCJjbG9uZU5vZGUiLCJuZXdQb3MiLCJvbGRQb3MiLCJkeCIsImxlZnQiLCJkeSIsInRvcCIsInBsYXRmb3JtQ29tcG9uZW50cyIsImRlZmF1bHRUYWdSRSIsInJlZ2V4RXNjYXBlUkUiLCJidWlsZFJlZ2V4IiwiZGVsaW1pdGVycyIsIm9wZW4iLCJjbG9zZSIsInBhcnNlVGV4dCIsInRhZ1JFIiwidG9rZW5zIiwicmF3VG9rZW5zIiwidG9rZW5WYWx1ZSIsImV4ZWMiLCJ0cmFuc2Zvcm1Ob2RlIiwiY2xhc3NCaW5kaW5nIiwiZ2VuRGF0YSIsImtsYXNzJDEiLCJ0cmFuc2Zvcm1Ob2RlJDEiLCJzdHlsZUJpbmRpbmciLCJnZW5EYXRhJDEiLCJzdHlsZSQxIiwiZGVjb2RlciIsImhlIiwiZGVjb2RlIiwiaHRtbCIsImlzVW5hcnlUYWciLCJjYW5CZUxlZnRPcGVuVGFnIiwiaXNOb25QaHJhc2luZ1RhZyIsImF0dHJpYnV0ZSIsIm5jbmFtZSIsInFuYW1lQ2FwdHVyZSIsInN0YXJ0VGFnT3BlbiIsInN0YXJ0VGFnQ2xvc2UiLCJlbmRUYWciLCJkb2N0eXBlIiwiY29tbWVudCIsImNvbmRpdGlvbmFsQ29tbWVudCIsIklTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4iLCJnIiwiaXNQbGFpblRleHRFbGVtZW50IiwicmVDYWNoZSIsImRlY29kaW5nTWFwIiwiZW5jb2RlZEF0dHIiLCJlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyIsImlzSWdub3JlTmV3bGluZVRhZyIsInNob3VsZElnbm9yZUZpcnN0TmV3bGluZSIsImRlY29kZUF0dHIiLCJzaG91bGREZWNvZGVOZXdsaW5lcyIsInJlIiwicGFyc2VIVE1MIiwic3RhY2siLCJleHBlY3RIVE1MIiwiaXNVbmFyeVRhZyQkMSIsImNhbkJlTGVmdE9wZW5UYWckJDEiLCJsYXN0VGFnIiwidGV4dEVuZCIsImNvbW1lbnRFbmQiLCJzaG91bGRLZWVwQ29tbWVudCIsInN1YnN0cmluZyIsImFkdmFuY2UiLCJjb25kaXRpb25hbEVuZCIsImRvY3R5cGVNYXRjaCIsImVuZFRhZ01hdGNoIiwiY3VySW5kZXgiLCJwYXJzZUVuZFRhZyIsInN0YXJ0VGFnTWF0Y2giLCJwYXJzZVN0YXJ0VGFnIiwiaGFuZGxlU3RhcnRUYWciLCJyZXN0IiwiY2hhcnMiLCJlbmRUYWdMZW5ndGgiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwicmVzdCQxIiwiYWxsIiwidW5hcnlTbGFzaCIsInVuYXJ5Iiwic2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmIiwibG93ZXJDYXNlZFRhZyIsImxvd2VyQ2FzZWRUYWdOYW1lIiwib25SRSIsImRpclJFIiwiZm9yQWxpYXNSRSIsImZvckl0ZXJhdG9yUkUiLCJzdHJpcFBhcmVuc1JFIiwiYXJnUkUiLCJiaW5kUkUiLCJtb2RpZmllclJFIiwiZGVjb2RlSFRNTENhY2hlZCIsIndhcm4kMiIsInRyYW5zZm9ybXMiLCJwcmVUcmFuc2Zvcm1zIiwicG9zdFRyYW5zZm9ybXMiLCJwbGF0Zm9ybUlzUHJlVGFnIiwicGxhdGZvcm1NdXN0VXNlUHJvcCIsInBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlIiwiY3JlYXRlQVNURWxlbWVudCIsIm1ha2VBdHRyc01hcCIsInBhcnNlIiwidGVtcGxhdGUiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJyb290IiwiY3VycmVudFBhcmVudCIsImluUHJlIiwiY2xvc2VFbGVtZW50IiwiZWxlbWVudCIsImNvbW1lbnRzIiwiZ3VhcmRJRVNWR0J1ZyIsImlzRm9yYmlkZGVuVGFnIiwiZm9yYmlkZGVuIiwicHJvY2Vzc1ByZSIsInByb2Nlc3NSYXdBdHRycyIsInByb2Nlc3NlZCIsInByb2Nlc3NGb3IiLCJwcm9jZXNzSWYiLCJwcm9jZXNzT25jZSIsInByb2Nlc3NFbGVtZW50IiwiY2hlY2tSb290Q29uc3RyYWludHMiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJhZGRJZkNvbmRpdGlvbiIsImJsb2NrIiwicHJvY2Vzc0lmQ29uZGl0aW9ucyIsInNsb3RTY29wZSIsInNsb3RUYXJnZXQiLCJsYXN0Tm9kZSIsImlzVGV4dFRhZyIsInByb2Nlc3NLZXkiLCJwcm9jZXNzUmVmIiwicHJvY2Vzc1Nsb3QiLCJwcm9jZXNzQ29tcG9uZW50IiwicHJvY2Vzc0F0dHJzIiwiY2hlY2tJbkZvciIsInBhcnNlRm9yIiwiaW5NYXRjaCIsImZvciIsImFsaWFzIiwiaXRlcmF0b3JNYXRjaCIsIml0ZXJhdG9yMSIsIml0ZXJhdG9yMiIsImZpbmRQcmV2RWxlbWVudCIsImNvbmRpdGlvbiIsImlmQ29uZGl0aW9ucyIsInNsb3ROYW1lIiwiaXNQcm9wIiwiaGFzQmluZGluZ3MiLCJwYXJzZU1vZGlmaWVycyIsImNhbWVsIiwiYXJnTWF0Y2giLCJpZU5TQnVnIiwiaWVOU1ByZWZpeCIsInByZVRyYW5zZm9ybU5vZGUiLCJ0eXBlQmluZGluZyIsImlmQ29uZGl0aW9uIiwiaWZDb25kaXRpb25FeHRyYSIsImhhc0Vsc2UiLCJlbHNlSWZDb25kaXRpb24iLCJicmFuY2gwIiwiY2xvbmVBU1RFbGVtZW50IiwiYnJhbmNoMSIsImJyYW5jaDIiLCJtb2RlbCQyIiwibW9kdWxlcyQxIiwiZGlyZWN0aXZlcyQxIiwiYmFzZU9wdGlvbnMiLCJpc1N0YXRpY0tleSIsImlzUGxhdGZvcm1SZXNlcnZlZFRhZyIsImdlblN0YXRpY0tleXNDYWNoZWQiLCJnZW5TdGF0aWNLZXlzJDEiLCJvcHRpbWl6ZSIsIm1hcmtTdGF0aWMkMSIsIm1hcmtTdGF0aWNSb290cyIsInN0YXRpYyIsImwkMSIsInN0YXRpY0luRm9yIiwic3RhdGljUm9vdCIsImlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIiwiZm5FeHBSRSIsInNpbXBsZVBhdGhSRSIsImVzYyIsInRhYiIsInNwYWNlIiwidXAiLCJkb3duIiwia2V5TmFtZXMiLCJnZW5HdWFyZCIsIm1vZGlmaWVyQ29kZSIsInN0b3AiLCJwcmV2ZW50Iiwic2VsZiIsImN0cmwiLCJhbHQiLCJtZXRhIiwiZ2VuSGFuZGxlcnMiLCJnZW5IYW5kbGVyIiwiaXNNZXRob2RQYXRoIiwiaXNGdW5jdGlvbkV4cHJlc3Npb24iLCJnZW5Nb2RpZmllckNvZGUiLCJrZXlNb2RpZmllciIsImdlbktleUZpbHRlciIsImhhbmRsZXJDb2RlIiwiZ2VuRmlsdGVyQ29kZSIsImtleVZhbCIsImtleUNvZGUiLCJrZXlOYW1lIiwid3JhcExpc3RlbmVycyIsImJpbmQkMSIsIndyYXBEYXRhIiwiYmFzZURpcmVjdGl2ZXMiLCJjbG9hayIsIkNvZGVnZW5TdGF0ZSIsImRhdGFHZW5GbnMiLCJtYXliZUNvbXBvbmVudCIsIm9uY2VJZCIsImdlbmVyYXRlIiwiYXN0Iiwic3RhdGUiLCJnZW5FbGVtZW50Iiwic3RhdGljUHJvY2Vzc2VkIiwiZ2VuU3RhdGljIiwib25jZVByb2Nlc3NlZCIsImdlbk9uY2UiLCJmb3JQcm9jZXNzZWQiLCJnZW5Gb3IiLCJpZlByb2Nlc3NlZCIsImdlbklmIiwiZ2VuQ2hpbGRyZW4iLCJnZW5TbG90IiwiZ2VuQ29tcG9uZW50IiwiZ2VuRGF0YSQyIiwiYWx0R2VuIiwiYWx0RW1wdHkiLCJnZW5JZkNvbmRpdGlvbnMiLCJjb25kaXRpb25zIiwiZ2VuVGVybmFyeUV4cCIsImFsdEhlbHBlciIsImdlbkRpcmVjdGl2ZXMiLCJnZW5Qcm9wcyIsImdlblNjb3BlZFNsb3RzIiwiZ2VuSW5saW5lVGVtcGxhdGUiLCJoYXNSdW50aW1lIiwibmVlZFJ1bnRpbWUiLCJnZW4iLCJpbmxpbmVSZW5kZXJGbnMiLCJnZW5TY29wZWRTbG90IiwiZ2VuRm9yU2NvcGVkU2xvdCIsImNoZWNrU2tpcCIsImFsdEdlbkVsZW1lbnQiLCJhbHRHZW5Ob2RlIiwiZWwkMSIsImdldE5vcm1hbGl6YXRpb25UeXBlIiwiZ2VuTm9kZSIsIm5lZWRzTm9ybWFsaXphdGlvbiIsImdlbkNvbW1lbnQiLCJnZW5UZXh0IiwidHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzIiwiYmluZCQkMSIsImNvbXBvbmVudE5hbWUiLCJwcm9oaWJpdGVkS2V5d29yZFJFIiwiY3JlYXRlRnVuY3Rpb24iLCJlcnJvcnMiLCJjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIiwiY29tcGlsZSIsImNvbXBpbGVUb0Z1bmN0aW9ucyIsIndhcm4kJDEiLCJjb21waWxlZCIsImZuR2VuRXJyb3JzIiwiY3JlYXRlQ29tcGlsZXJDcmVhdG9yIiwiYmFzZUNvbXBpbGUiLCJjcmVhdGVDb21waWxlciIsImZpbmFsT3B0aW9ucyIsInRpcHMiLCJ0aXAiLCJkaXYiLCJnZXRTaG91bGREZWNvZGUiLCJocmVmIiwiaWRUb1RlbXBsYXRlIiwibW91bnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRPdXRlckhUTUwiLCJvdXRlckhUTUwiLCJjb250YWluZXIiLCJBY2NvcmRpb24iLCJfdnVlIiwianNBY3RpdmUiLCJhcmlhSGlkZGVuIiwibWFpbiIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJhY2NvcmRpb24iXSwibWFwcGluZ3MiOiI7OztFQUVBLElBQU1BLFlBQVk7RUFDaEJDLFVBQVEsUUFEUTtFQUVoQkMsVUFBUSxDQUZRO0VBR2hCQyxTQUFPO0VBSFMsQ0FBbEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VDRUE7Ozs7O01BSU1DO0VBQ0o7Ozs7Ozs7RUFPQSxr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
